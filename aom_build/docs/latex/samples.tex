This S\+DK includes a number of sample applications. Each sample documents a feature of the S\+DK in both prose and the associated C code. The following samples are included\+:


\begin{DoxyItemize}
\item \hyperlink{example_decode_to_md5}{decode\+\_\+to\+\_\+md5} Frame by frame M\+D5 checksum.
\item \hyperlink{example_decode_with_drops}{decode\+\_\+with\+\_\+drops} Drops frames while decoding.
\item \hyperlink{example_simple_decoder}{simple\+\_\+decoder} Simplified decoder loop.
\item \hyperlink{example_lossless_encoder}{lossless\+\_\+encoder} Simplified lossless encoder.
\item \hyperlink{example_set_maps}{set\+\_\+maps} Set active and R\+OI maps.
\item \hyperlink{example_simple_encoder}{simple\+\_\+encoder} Simplified encoder loop.
\item \hyperlink{example_twopass_encoder}{twopass\+\_\+encoder} Two-\/pass encoder loop.
\item \hyperlink{example_scalable_encoder}{scalable\+\_\+encoder} Scalable encoder loop.
\item \hyperlink{example_aom_cx_set_ref}{aom\+\_\+cx\+\_\+set\+\_\+ref} Set encoder reference frame.
\item \hyperlink{example_lightfield_encoder}{lightfield\+\_\+encoder} Lightfield encoder example.
\item \hyperlink{example_lightfield_tile_list_decoder}{lightfield\+\_\+tile\+\_\+list\+\_\+decoder} Lightfield tile list decoder example.
\item \hyperlink{example_lightfield_decoder}{lightfield\+\_\+decoder} Lightfield decoder example.
\item \hyperlink{example_lightfield_bitstream_parsing}{lightfield\+\_\+bitstream\+\_\+parsing} Lightfield bitstream parsing example.
\end{DoxyItemize}

In addition, the S\+DK contains a number of utilities. Since these utilities are built upon the concepts described in the sample code listed above, they are not documented in pieces like the samples are. Their source is included here for reference. The following utilities are included\+:


\begin{DoxyItemize}
\item \hyperlink{example_aomdec}{aomdec} Full featured decoder.
\item \hyperlink{example_aomenc}{aomenc} Full featured encoder. 
\end{DoxyItemize}\hypertarget{example_decode_to_md5}{}\subsection{decode\+\_\+to\+\_\+md5}\label{example_decode_to_md5}

\begin{DoxyCodeInclude}
1 \textcolor{comment}{/*}
2 \textcolor{comment}{ * Copyright (c) 2016, Alliance for Open Media. All rights reserved}
3 \textcolor{comment}{ *}
4 \textcolor{comment}{ * This source code is subject to the terms of the BSD 2 Clause License and}
5 \textcolor{comment}{ * the Alliance for Open Media Patent License 1.0. If the BSD 2 Clause License}
6 \textcolor{comment}{ * was not distributed with this source code in the LICENSE file, you can}
7 \textcolor{comment}{ * obtain it at www.aomedia.org/license/software. If the Alliance for Open}
8 \textcolor{comment}{ * Media Patent License 1.0 was not distributed with this source code in the}
9 \textcolor{comment}{ * PATENTS file, you can obtain it at www.aomedia.org/license/patent.}
10 \textcolor{comment}{ */}
11 
12 \textcolor{comment}{// Frame-by-frame MD5 Checksum}
13 \textcolor{comment}{// ===========================}
14 \textcolor{comment}{//}
15 \textcolor{comment}{// This example builds upon the simple decoder loop to show how checksums}
16 \textcolor{comment}{// of the decoded output can be generated. These are used for validating}
17 \textcolor{comment}{// decoder implementations against the reference implementation, for example.}
18 \textcolor{comment}{//}
19 \textcolor{comment}{// MD5 algorithm}
20 \textcolor{comment}{// -------------}
21 \textcolor{comment}{// The Message-Digest 5 (MD5) is a well known hash function. We have provided}
22 \textcolor{comment}{// an implementation derived from the RSA Data Security, Inc. MD5 Message-Digest}
23 \textcolor{comment}{// Algorithm for your use. Our implmentation only changes the interface of this}
24 \textcolor{comment}{// reference code. You must include the `md5\_utils.h` header for access to these}
25 \textcolor{comment}{// functions.}
26 \textcolor{comment}{//}
27 \textcolor{comment}{// Processing The Decoded Data}
28 \textcolor{comment}{// ---------------------------}
29 \textcolor{comment}{// Each row of the image is passed to the MD5 accumulator. First the Y plane}
30 \textcolor{comment}{// is processed, then U, then V. It is important to honor the image's `stride`}
31 \textcolor{comment}{// values.}
32 
33 \textcolor{preprocessor}{#include <stdio.h>}
34 \textcolor{preprocessor}{#include <stdlib.h>}
35 \textcolor{preprocessor}{#include <string.h>}
36 
37 \textcolor{preprocessor}{#include "\hyperlink{aom__decoder_8h}{aom/aom\_decoder.h}"}
38 \textcolor{preprocessor}{#include "\hyperlink{aomdx_8h}{aom/aomdx.h}"}
39 \textcolor{preprocessor}{#include "common/md5\_utils.h"}
40 \textcolor{preprocessor}{#include "common/tools\_common.h"}
41 \textcolor{preprocessor}{#include "common/video\_reader.h"}
42 
43 \textcolor{keyword}{static} \textcolor{keywordtype}{void} get\_image\_md5(\textcolor{keyword}{const} \hyperlink{structaom__image}{aom\_image\_t} *img, \textcolor{keywordtype}{unsigned} \textcolor{keywordtype}{char} digest[16]) \{
44   \textcolor{keywordtype}{int} plane, y;
45   MD5Context md5;
46 
47   MD5Init(&md5);
48 
49   \textcolor{keywordflow}{for} (plane = 0; plane < 3; ++plane) \{
50     \textcolor{keyword}{const} \textcolor{keywordtype}{unsigned} \textcolor{keywordtype}{char} *buf = img->\hyperlink{structaom__image_ac54dbc5237ca2914f9ec30105dfbe302}{planes}[plane];
51     \textcolor{keyword}{const} \textcolor{keywordtype}{int} stride = img->\hyperlink{structaom__image_a6dc693d7dbc9eb06c0cdde307ca58372}{stride}[plane];
52     \textcolor{keyword}{const} \textcolor{keywordtype}{int} w = plane ? (img->\hyperlink{structaom__image_a89f80b1f58d608b9d2080635f4359034}{d\_w} + 1) >> 1 : img->\hyperlink{structaom__image_a89f80b1f58d608b9d2080635f4359034}{d\_w};
53     \textcolor{keyword}{const} \textcolor{keywordtype}{int} h = plane ? (img->\hyperlink{structaom__image_ab986419a1f0fff93a2dc505f47194988}{d\_h} + 1) >> 1 : img->\hyperlink{structaom__image_ab986419a1f0fff93a2dc505f47194988}{d\_h};
54 
55     \textcolor{keywordflow}{for} (y = 0; y < h; ++y) \{
56       MD5Update(&md5, buf, w);
57       buf += stride;
58     \}
59   \}
60 
61   MD5Final(digest, &md5);
62 \}
63 
64 \textcolor{keyword}{static} \textcolor{keywordtype}{void} print\_md5(FILE *stream, \textcolor{keywordtype}{unsigned} \textcolor{keywordtype}{char} digest[16]) \{
65   \textcolor{keywordtype}{int} i;
66 
67   \textcolor{keywordflow}{for} (i = 0; i < 16; ++i) fprintf(stream, \textcolor{stringliteral}{"%02x"}, digest[i]);
68 \}
69 
70 \textcolor{keyword}{static} \textcolor{keyword}{const} \textcolor{keywordtype}{char} *exec\_name;
71 
72 \textcolor{keywordtype}{void} usage\_exit(\textcolor{keywordtype}{void}) \{
73   fprintf(stderr, \textcolor{stringliteral}{"Usage: %s <infile> <outfile>\(\backslash\)n"}, exec\_name);
74   exit(EXIT\_FAILURE);
75 \}
76 
77 \textcolor{keywordtype}{int} main(\textcolor{keywordtype}{int} argc, \textcolor{keywordtype}{char} **argv) \{
78   \textcolor{keywordtype}{int} frame\_cnt = 0;
79   FILE *outfile = NULL;
80   \hyperlink{structaom__codec__ctx}{aom\_codec\_ctx\_t} codec;
81   AvxVideoReader *reader = NULL;
82   \textcolor{keyword}{const} AvxVideoInfo *info = NULL;
83   \textcolor{keyword}{const} AvxInterface *decoder = NULL;
84 
85   exec\_name = argv[0];
86 
87   \textcolor{keywordflow}{if} (argc != 3) die(\textcolor{stringliteral}{"Invalid number of arguments."});
88 
89   reader = aom\_video\_reader\_open(argv[1]);
90   \textcolor{keywordflow}{if} (!reader) die(\textcolor{stringliteral}{"Failed to open %s for reading."}, argv[1]);
91 
92   \textcolor{keywordflow}{if} (!(outfile = fopen(argv[2], \textcolor{stringliteral}{"wb"})))
93     die(\textcolor{stringliteral}{"Failed to open %s for writing."}, argv[2]);
94 
95   info = aom\_video\_reader\_get\_info(reader);
96 
97   decoder = get\_aom\_decoder\_by\_fourcc(info->codec\_fourcc);
98   \textcolor{keywordflow}{if} (!decoder) die(\textcolor{stringliteral}{"Unknown input codec."});
99 
100   printf(\textcolor{stringliteral}{"Using %s\(\backslash\)n"}, \hyperlink{group__codec_ga013b1f6d96b2cf9489396311a7e5179b}{aom\_codec\_iface\_name}(decoder->codec\_interface()));
101 
102   \textcolor{keywordflow}{if} (\hyperlink{group__decoder_gafdbfca65b19ab1f6d72b32cd01753b9b}{aom\_codec\_dec\_init}(&codec, decoder->codec\_interface(), NULL, 0))
103     die\_codec(&codec, \textcolor{stringliteral}{"Failed to initialize decoder"});
104 
105   \textcolor{keywordflow}{while} (aom\_video\_reader\_read\_frame(reader)) \{
106     \hyperlink{group__codec_gadf9e173c9e02788a9999399edab20a02}{aom\_codec\_iter\_t} iter = NULL;
107     \hyperlink{structaom__image}{aom\_image\_t} *img = NULL;
108     \textcolor{keywordtype}{size\_t} frame\_size = 0;
109     \textcolor{keyword}{const} \textcolor{keywordtype}{unsigned} \textcolor{keywordtype}{char} *frame =
110         aom\_video\_reader\_get\_frame(reader, &frame\_size);
111     \textcolor{keywordflow}{if} (\hyperlink{group__decoder_gab03fdb999d1f83a5896869a3ba5f68f7}{aom\_codec\_decode}(&codec, frame, frame\_size, NULL))
112       die\_codec(&codec, \textcolor{stringliteral}{"Failed to decode frame"});
113 
114     \textcolor{keywordflow}{while} ((img = \hyperlink{group__decoder_ga780aad27a2728abefab725faa3bc4f79}{aom\_codec\_get\_frame}(&codec, &iter)) != NULL) \{
115       \textcolor{keywordtype}{unsigned} \textcolor{keywordtype}{char} digest[16];
116 
117       get\_image\_md5(img, digest);
118       print\_md5(outfile, digest);
119       fprintf(outfile, \textcolor{stringliteral}{"  img-%dx%d-%04d.i420\(\backslash\)n"}, img->\hyperlink{structaom__image_a89f80b1f58d608b9d2080635f4359034}{d\_w}, img->\hyperlink{structaom__image_ab986419a1f0fff93a2dc505f47194988}{d\_h},
120               ++frame\_cnt);
121     \}
122   \}
123 
124   printf(\textcolor{stringliteral}{"Processed %d frames.\(\backslash\)n"}, frame\_cnt);
125   \textcolor{keywordflow}{if} (\hyperlink{group__codec_ga9b60e186f61ba2d6ab2b8069b76a15c5}{aom\_codec\_destroy}(&codec)) die\_codec(&codec, \textcolor{stringliteral}{"Failed to destroy codec."});
126 
127   aom\_video\_reader\_close(reader);
128 
129   fclose(outfile);
130   \textcolor{keywordflow}{return} EXIT\_SUCCESS;
131 \}
\end{DoxyCodeInclude}
 \hypertarget{example_decode_with_drops}{}\subsection{decode\+\_\+with\+\_\+drops}\label{example_decode_with_drops}

\begin{DoxyCodeInclude}
1 \textcolor{comment}{/*}
2 \textcolor{comment}{ * Copyright (c) 2016, Alliance for Open Media. All rights reserved}
3 \textcolor{comment}{ *}
4 \textcolor{comment}{ * This source code is subject to the terms of the BSD 2 Clause License and}
5 \textcolor{comment}{ * the Alliance for Open Media Patent License 1.0. If the BSD 2 Clause License}
6 \textcolor{comment}{ * was not distributed with this source code in the LICENSE file, you can}
7 \textcolor{comment}{ * obtain it at www.aomedia.org/license/software. If the Alliance for Open}
8 \textcolor{comment}{ * Media Patent License 1.0 was not distributed with this source code in the}
9 \textcolor{comment}{ * PATENTS file, you can obtain it at www.aomedia.org/license/patent.}
10 \textcolor{comment}{ */}
11 
12 \textcolor{comment}{// Decode With Drops Example}
13 \textcolor{comment}{// =========================}
14 \textcolor{comment}{//}
15 \textcolor{comment}{// This is an example utility which drops a series of frames, as specified}
16 \textcolor{comment}{// on the command line. This is useful for observing the error recovery}
17 \textcolor{comment}{// features of the codec.}
18 \textcolor{comment}{//}
19 \textcolor{comment}{// Usage}
20 \textcolor{comment}{// -----}
21 \textcolor{comment}{// This example adds a single argument to the `simple\_decoder` example,}
22 \textcolor{comment}{// which specifies the range or pattern of frames to drop. The parameter is}
23 \textcolor{comment}{// parsed as follows:}
24 \textcolor{comment}{//}
25 \textcolor{comment}{// Dropping A Range Of Frames}
26 \textcolor{comment}{// --------------------------}
27 \textcolor{comment}{// To drop a range of frames, specify the starting frame and the ending}
28 \textcolor{comment}{// frame to drop, separated by a dash. The following command will drop}
29 \textcolor{comment}{// frames 5 through 10 (base 1).}
30 \textcolor{comment}{//}
31 \textcolor{comment}{//  $ ./decode\_with\_drops in.ivf out.i420 5-10}
32 \textcolor{comment}{//}
33 \textcolor{comment}{//}
34 \textcolor{comment}{// Dropping A Pattern Of Frames}
35 \textcolor{comment}{// ----------------------------}
36 \textcolor{comment}{// To drop a pattern of frames, specify the number of frames to drop and}
37 \textcolor{comment}{// the number of frames after which to repeat the pattern, separated by}
38 \textcolor{comment}{// a forward-slash. The following command will drop 3 of 7 frames.}
39 \textcolor{comment}{// Specifically, it will decode 4 frames, then drop 3 frames, and then}
40 \textcolor{comment}{// repeat.}
41 \textcolor{comment}{//}
42 \textcolor{comment}{//  $ ./decode\_with\_drops in.ivf out.i420 3/7}
43 \textcolor{comment}{//}
44 \textcolor{comment}{//}
45 \textcolor{comment}{// Extra Variables}
46 \textcolor{comment}{// ---------------}
47 \textcolor{comment}{// This example maintains the pattern passed on the command line in the}
48 \textcolor{comment}{// `n`, `m`, and `is\_range` variables:}
49 \textcolor{comment}{//}
50 \textcolor{comment}{//}
51 \textcolor{comment}{// Making The Drop Decision}
52 \textcolor{comment}{// ------------------------}
53 \textcolor{comment}{// The example decides whether to drop the frame based on the current}
54 \textcolor{comment}{// frame number, immediately before decoding the frame.}
55 
56 \textcolor{preprocessor}{#include <stdio.h>}
57 \textcolor{preprocessor}{#include <stdlib.h>}
58 \textcolor{preprocessor}{#include <string.h>}
59 
60 \textcolor{preprocessor}{#include "\hyperlink{aom__decoder_8h}{aom/aom\_decoder.h}"}
61 \textcolor{preprocessor}{#include "\hyperlink{aomdx_8h}{aom/aomdx.h}"}
62 \textcolor{preprocessor}{#include "common/tools\_common.h"}
63 \textcolor{preprocessor}{#include "common/video\_reader.h"}
64 
65 \textcolor{keyword}{static} \textcolor{keyword}{const} \textcolor{keywordtype}{char} *exec\_name;
66 
67 \textcolor{keywordtype}{void} usage\_exit(\textcolor{keywordtype}{void}) \{
68   fprintf(stderr, \textcolor{stringliteral}{"Usage: %s <infile> <outfile> <N-M|N/M>\(\backslash\)n"}, exec\_name);
69   exit(EXIT\_FAILURE);
70 \}
71 
72 \textcolor{keywordtype}{int} main(\textcolor{keywordtype}{int} argc, \textcolor{keywordtype}{char} **argv) \{
73   \textcolor{keywordtype}{int} frame\_cnt = 0;
74   FILE *outfile = NULL;
75   \hyperlink{structaom__codec__ctx}{aom\_codec\_ctx\_t} codec;
76   \textcolor{keyword}{const} AvxInterface *decoder = NULL;
77   AvxVideoReader *reader = NULL;
78   \textcolor{keyword}{const} AvxVideoInfo *info = NULL;
79   \textcolor{keywordtype}{int} n = 0;
80   \textcolor{keywordtype}{int} m = 0;
81   \textcolor{keywordtype}{int} is\_range = 0;
82   \textcolor{keywordtype}{char} *nptr = NULL;
83 
84   exec\_name = argv[0];
85 
86   \textcolor{keywordflow}{if} (argc != 4) die(\textcolor{stringliteral}{"Invalid number of arguments."});
87 
88   reader = aom\_video\_reader\_open(argv[1]);
89   \textcolor{keywordflow}{if} (!reader) die(\textcolor{stringliteral}{"Failed to open %s for reading."}, argv[1]);
90 
91   \textcolor{keywordflow}{if} (!(outfile = fopen(argv[2], \textcolor{stringliteral}{"wb"})))
92     die(\textcolor{stringliteral}{"Failed to open %s for writing."}, argv[2]);
93 
94   n = (int)strtol(argv[3], &nptr, 0);
95   m = (int)strtol(nptr + 1, NULL, 0);
96   is\_range = (*nptr == \textcolor{charliteral}{'-'});
97   \textcolor{keywordflow}{if} (!n || !m || (*nptr != \textcolor{charliteral}{'-'} && *nptr != \textcolor{charliteral}{'/'}))
98     die(\textcolor{stringliteral}{"Couldn't parse pattern %s.\(\backslash\)n"}, argv[3]);
99 
100   info = aom\_video\_reader\_get\_info(reader);
101 
102   decoder = get\_aom\_decoder\_by\_fourcc(info->codec\_fourcc);
103   \textcolor{keywordflow}{if} (!decoder) die(\textcolor{stringliteral}{"Unknown input codec."});
104 
105   printf(\textcolor{stringliteral}{"Using %s\(\backslash\)n"}, \hyperlink{group__codec_ga013b1f6d96b2cf9489396311a7e5179b}{aom\_codec\_iface\_name}(decoder->codec\_interface()));
106 
107   \textcolor{keywordflow}{if} (\hyperlink{group__decoder_gafdbfca65b19ab1f6d72b32cd01753b9b}{aom\_codec\_dec\_init}(&codec, decoder->codec\_interface(), NULL, 0))
108     die\_codec(&codec, \textcolor{stringliteral}{"Failed to initialize decoder."});
109 
110   \textcolor{keywordflow}{while} (aom\_video\_reader\_read\_frame(reader)) \{
111     \hyperlink{group__codec_gadf9e173c9e02788a9999399edab20a02}{aom\_codec\_iter\_t} iter = NULL;
112     \hyperlink{structaom__image}{aom\_image\_t} *img = NULL;
113     \textcolor{keywordtype}{size\_t} frame\_size = 0;
114     \textcolor{keywordtype}{int} skip;
115     \textcolor{keyword}{const} \textcolor{keywordtype}{unsigned} \textcolor{keywordtype}{char} *frame =
116         aom\_video\_reader\_get\_frame(reader, &frame\_size);
117     ++frame\_cnt;
118 
119     skip = (is\_range && frame\_cnt >= n && frame\_cnt <= m) ||
120            (!is\_range && m - (frame\_cnt - 1) % m <= n);
121 
122     \textcolor{keywordflow}{if} (!skip) \{
123       putc(\textcolor{charliteral}{'.'}, stdout);
124       \textcolor{keywordflow}{if} (\hyperlink{group__decoder_gab03fdb999d1f83a5896869a3ba5f68f7}{aom\_codec\_decode}(&codec, frame, frame\_size, NULL))
125         die\_codec(&codec, \textcolor{stringliteral}{"Failed to decode frame."});
126 
127       \textcolor{keywordflow}{while} ((img = \hyperlink{group__decoder_ga780aad27a2728abefab725faa3bc4f79}{aom\_codec\_get\_frame}(&codec, &iter)) != NULL)
128         aom\_img\_write(img, outfile);
129     \} \textcolor{keywordflow}{else} \{
130       putc(\textcolor{charliteral}{'X'}, stdout);
131     \}
132 
133     fflush(stdout);
134   \}
135 
136   printf(\textcolor{stringliteral}{"Processed %d frames.\(\backslash\)n"}, frame\_cnt);
137   \textcolor{keywordflow}{if} (\hyperlink{group__codec_ga9b60e186f61ba2d6ab2b8069b76a15c5}{aom\_codec\_destroy}(&codec)) die\_codec(&codec, \textcolor{stringliteral}{"Failed to destroy codec."});
138 
139   printf(\textcolor{stringliteral}{"Play: ffplay -f rawvideo -pix\_fmt yuv420p -s %dx%d %s\(\backslash\)n"},
140          info->frame\_width, info->frame\_height, argv[2]);
141 
142   aom\_video\_reader\_close(reader);
143   fclose(outfile);
144 
145   \textcolor{keywordflow}{return} EXIT\_SUCCESS;
146 \}
\end{DoxyCodeInclude}
 \hypertarget{example_simple_decoder}{}\subsection{simple\+\_\+decoder}\label{example_simple_decoder}

\begin{DoxyCodeInclude}
1 \textcolor{comment}{/*}
2 \textcolor{comment}{ * Copyright (c) 2016, Alliance for Open Media. All rights reserved}
3 \textcolor{comment}{ *}
4 \textcolor{comment}{ * This source code is subject to the terms of the BSD 2 Clause License and}
5 \textcolor{comment}{ * the Alliance for Open Media Patent License 1.0. If the BSD 2 Clause License}
6 \textcolor{comment}{ * was not distributed with this source code in the LICENSE file, you can}
7 \textcolor{comment}{ * obtain it at www.aomedia.org/license/software. If the Alliance for Open}
8 \textcolor{comment}{ * Media Patent License 1.0 was not distributed with this source code in the}
9 \textcolor{comment}{ * PATENTS file, you can obtain it at www.aomedia.org/license/patent.}
10 \textcolor{comment}{ */}
11 
12 \textcolor{comment}{// Simple Decoder}
13 \textcolor{comment}{// ==============}
14 \textcolor{comment}{//}
15 \textcolor{comment}{// This is an example of a simple decoder loop. It takes an input file}
16 \textcolor{comment}{// containing the compressed data (in IVF format), passes it through the}
17 \textcolor{comment}{// decoder, and writes the decompressed frames to disk. Other decoder}
18 \textcolor{comment}{// examples build upon this one.}
19 \textcolor{comment}{//}
20 \textcolor{comment}{// The details of the IVF format have been elided from this example for}
21 \textcolor{comment}{// simplicity of presentation, as IVF files will not generally be used by}
22 \textcolor{comment}{// your application. In general, an IVF file consists of a file header,}
23 \textcolor{comment}{// followed by a variable number of frames. Each frame consists of a frame}
24 \textcolor{comment}{// header followed by a variable length payload. The length of the payload}
25 \textcolor{comment}{// is specified in the first four bytes of the frame header. The payload is}
26 \textcolor{comment}{// the raw compressed data.}
27 \textcolor{comment}{//}
28 \textcolor{comment}{// Standard Includes}
29 \textcolor{comment}{// -----------------}
30 \textcolor{comment}{// For decoders, you only have to include `aom\_decoder.h` and then any}
31 \textcolor{comment}{// header files for the specific codecs you use. In this case, we're using}
32 \textcolor{comment}{// aom.}
33 \textcolor{comment}{//}
34 \textcolor{comment}{// Initializing The Codec}
35 \textcolor{comment}{// ----------------------}
36 \textcolor{comment}{// The libaom decoder is initialized by the call to aom\_codec\_dec\_init().}
37 \textcolor{comment}{// Determining the codec interface to use is handled by AvxVideoReader and the}
38 \textcolor{comment}{// functions prefixed with aom\_video\_reader\_. Discussion of those functions is}
39 \textcolor{comment}{// beyond the scope of this example, but the main gist is to open the input file}
40 \textcolor{comment}{// and parse just enough of it to determine if it's a AVx file and which AVx}
41 \textcolor{comment}{// codec is contained within the file.}
42 \textcolor{comment}{// Note the NULL pointer passed to aom\_codec\_dec\_init(). We do that in this}
43 \textcolor{comment}{// example because we want the algorithm to determine the stream configuration}
44 \textcolor{comment}{// (width/height) and allocate memory automatically.}
45 \textcolor{comment}{//}
46 \textcolor{comment}{// Decoding A Frame}
47 \textcolor{comment}{// ----------------}
48 \textcolor{comment}{// Once the frame has been read into memory, it is decoded using the}
49 \textcolor{comment}{// `aom\_codec\_decode` function. The call takes a pointer to the data}
50 \textcolor{comment}{// (`frame`) and the length of the data (`frame\_size`). No application data}
51 \textcolor{comment}{// is associated with the frame in this example, so the `user\_priv`}
52 \textcolor{comment}{// parameter is NULL.}
53 \textcolor{comment}{//}
54 \textcolor{comment}{// Codecs may produce a variable number of output frames for every call to}
55 \textcolor{comment}{// `aom\_codec\_decode`. These frames are retrieved by the}
56 \textcolor{comment}{// `aom\_codec\_get\_frame` iterator function. The iterator variable `iter` is}
57 \textcolor{comment}{// initialized to NULL each time `aom\_codec\_decode` is called.}
58 \textcolor{comment}{// `aom\_codec\_get\_frame` is called in a loop, returning a pointer to a}
59 \textcolor{comment}{// decoded image or NULL to indicate the end of list.}
60 \textcolor{comment}{//}
61 \textcolor{comment}{// Processing The Decoded Data}
62 \textcolor{comment}{// ---------------------------}
63 \textcolor{comment}{// In this example, we simply write the encoded data to disk. It is}
64 \textcolor{comment}{// important to honor the image's `stride` values.}
65 \textcolor{comment}{//}
66 \textcolor{comment}{// Cleanup}
67 \textcolor{comment}{// -------}
68 \textcolor{comment}{// The `aom\_codec\_destroy` call frees any memory allocated by the codec.}
69 \textcolor{comment}{//}
70 \textcolor{comment}{// Error Handling}
71 \textcolor{comment}{// --------------}
72 \textcolor{comment}{// This example does not special case any error return codes. If there was}
73 \textcolor{comment}{// an error, a descriptive message is printed and the program exits. With}
74 \textcolor{comment}{// few exceptions, aom\_codec functions return an enumerated error status,}
75 \textcolor{comment}{// with the value `0` indicating success.}
76 
77 \textcolor{preprocessor}{#include <stdio.h>}
78 \textcolor{preprocessor}{#include <stdlib.h>}
79 \textcolor{preprocessor}{#include <string.h>}
80 
81 \textcolor{preprocessor}{#include "\hyperlink{aom__decoder_8h}{aom/aom\_decoder.h}"}
82 \textcolor{preprocessor}{#include "common/tools\_common.h"}
83 \textcolor{preprocessor}{#include "common/video\_reader.h"}
84 
85 \textcolor{keyword}{static} \textcolor{keyword}{const} \textcolor{keywordtype}{char} *exec\_name;
86 
87 \textcolor{keywordtype}{void} usage\_exit(\textcolor{keywordtype}{void}) \{
88   fprintf(stderr, \textcolor{stringliteral}{"Usage: %s <infile> <outfile>\(\backslash\)n"}, exec\_name);
89   exit(EXIT\_FAILURE);
90 \}
91 
92 \textcolor{keywordtype}{int} main(\textcolor{keywordtype}{int} argc, \textcolor{keywordtype}{char} **argv) \{
93   \textcolor{keywordtype}{int} frame\_cnt = 0;
94   FILE *outfile = NULL;
95   \hyperlink{structaom__codec__ctx}{aom\_codec\_ctx\_t} codec;
96   AvxVideoReader *reader = NULL;
97   \textcolor{keyword}{const} AvxInterface *decoder = NULL;
98   \textcolor{keyword}{const} AvxVideoInfo *info = NULL;
99 
100   exec\_name = argv[0];
101 
102   \textcolor{keywordflow}{if} (argc != 3) die(\textcolor{stringliteral}{"Invalid number of arguments."});
103 
104   reader = aom\_video\_reader\_open(argv[1]);
105   \textcolor{keywordflow}{if} (!reader) die(\textcolor{stringliteral}{"Failed to open %s for reading."}, argv[1]);
106 
107   \textcolor{keywordflow}{if} (!(outfile = fopen(argv[2], \textcolor{stringliteral}{"wb"})))
108     die(\textcolor{stringliteral}{"Failed to open %s for writing."}, argv[2]);
109 
110   info = aom\_video\_reader\_get\_info(reader);
111 
112   decoder = get\_aom\_decoder\_by\_fourcc(info->codec\_fourcc);
113   \textcolor{keywordflow}{if} (!decoder) die(\textcolor{stringliteral}{"Unknown input codec."});
114 
115   printf(\textcolor{stringliteral}{"Using %s\(\backslash\)n"}, \hyperlink{group__codec_ga013b1f6d96b2cf9489396311a7e5179b}{aom\_codec\_iface\_name}(decoder->codec\_interface()));
116 
117   \textcolor{keywordflow}{if} (\hyperlink{group__decoder_gafdbfca65b19ab1f6d72b32cd01753b9b}{aom\_codec\_dec\_init}(&codec, decoder->codec\_interface(), NULL, 0))
118     die\_codec(&codec, \textcolor{stringliteral}{"Failed to initialize decoder."});
119 
120   \textcolor{keywordflow}{while} (aom\_video\_reader\_read\_frame(reader)) \{
121     \hyperlink{group__codec_gadf9e173c9e02788a9999399edab20a02}{aom\_codec\_iter\_t} iter = NULL;
122     \hyperlink{structaom__image}{aom\_image\_t} *img = NULL;
123     \textcolor{keywordtype}{size\_t} frame\_size = 0;
124     \textcolor{keyword}{const} \textcolor{keywordtype}{unsigned} \textcolor{keywordtype}{char} *frame =
125         aom\_video\_reader\_get\_frame(reader, &frame\_size);
126     \textcolor{keywordflow}{if} (\hyperlink{group__decoder_gab03fdb999d1f83a5896869a3ba5f68f7}{aom\_codec\_decode}(&codec, frame, frame\_size, NULL))
127       die\_codec(&codec, \textcolor{stringliteral}{"Failed to decode frame."});
128 
129     \textcolor{keywordflow}{while} ((img = \hyperlink{group__decoder_ga780aad27a2728abefab725faa3bc4f79}{aom\_codec\_get\_frame}(&codec, &iter)) != NULL) \{
130       aom\_img\_write(img, outfile);
131       ++frame\_cnt;
132     \}
133   \}
134 
135   printf(\textcolor{stringliteral}{"Processed %d frames.\(\backslash\)n"}, frame\_cnt);
136   \textcolor{keywordflow}{if} (\hyperlink{group__codec_ga9b60e186f61ba2d6ab2b8069b76a15c5}{aom\_codec\_destroy}(&codec)) die\_codec(&codec, \textcolor{stringliteral}{"Failed to destroy codec"});
137 
138   printf(\textcolor{stringliteral}{"Play: ffplay -f rawvideo -pix\_fmt yuv420p -s %dx%d %s\(\backslash\)n"},
139          info->frame\_width, info->frame\_height, argv[2]);
140 
141   aom\_video\_reader\_close(reader);
142 
143   fclose(outfile);
144 
145   \textcolor{keywordflow}{return} EXIT\_SUCCESS;
146 \}
\end{DoxyCodeInclude}
 \hypertarget{example_lossless_encoder}{}\subsection{lossless\+\_\+encoder}\label{example_lossless_encoder}

\begin{DoxyCodeInclude}
1 \textcolor{comment}{/*}
2 \textcolor{comment}{ * Copyright (c) 2016, Alliance for Open Media. All rights reserved}
3 \textcolor{comment}{ *}
4 \textcolor{comment}{ * This source code is subject to the terms of the BSD 2 Clause License and}
5 \textcolor{comment}{ * the Alliance for Open Media Patent License 1.0. If the BSD 2 Clause License}
6 \textcolor{comment}{ * was not distributed with this source code in the LICENSE file, you can}
7 \textcolor{comment}{ * obtain it at www.aomedia.org/license/software. If the Alliance for Open}
8 \textcolor{comment}{ * Media Patent License 1.0 was not distributed with this source code in the}
9 \textcolor{comment}{ * PATENTS file, you can obtain it at www.aomedia.org/license/patent.}
10 \textcolor{comment}{ */}
11 
12 \textcolor{preprocessor}{#include <stdio.h>}
13 \textcolor{preprocessor}{#include <stdlib.h>}
14 \textcolor{preprocessor}{#include <string.h>}
15 
16 \textcolor{preprocessor}{#include "\hyperlink{aom__encoder_8h}{aom/aom\_encoder.h}"}
17 \textcolor{preprocessor}{#include "\hyperlink{aomcx_8h}{aom/aomcx.h}"}
18 \textcolor{preprocessor}{#include "common/tools\_common.h"}
19 \textcolor{preprocessor}{#include "common/video\_writer.h"}
20 
21 \textcolor{keyword}{static} \textcolor{keyword}{const} \textcolor{keywordtype}{char} *exec\_name;
22 
23 \textcolor{keywordtype}{void} usage\_exit(\textcolor{keywordtype}{void}) \{
24   fprintf(stderr,
25           \textcolor{stringliteral}{"lossless\_encoder: Example demonstrating lossless "}
26           \textcolor{stringliteral}{"encoding feature. Supports raw input only.\(\backslash\)n"});
27   fprintf(stderr, \textcolor{stringliteral}{"Usage: %s <width> <height> <infile> <outfile>\(\backslash\)n"}, exec\_name);
28   exit(EXIT\_FAILURE);
29 \}
30 
31 \textcolor{keyword}{static} \textcolor{keywordtype}{int} encode\_frame(\hyperlink{structaom__codec__ctx}{aom\_codec\_ctx\_t} *codec, \hyperlink{structaom__image}{aom\_image\_t} *img,
32                         \textcolor{keywordtype}{int} frame\_index, \textcolor{keywordtype}{int} flags, AvxVideoWriter *writer) \{
33   \textcolor{keywordtype}{int} got\_pkts = 0;
34   \hyperlink{group__codec_gadf9e173c9e02788a9999399edab20a02}{aom\_codec\_iter\_t} iter = NULL;
35   \textcolor{keyword}{const} \hyperlink{structaom__codec__cx__pkt}{aom\_codec\_cx\_pkt\_t} *pkt = NULL;
36   \textcolor{keyword}{const} \hyperlink{group__codec_gaaae61e0f8663e6137f1e228757248e7c}{aom\_codec\_err\_t} res =
37       \hyperlink{group__encoder_ga6f4a777de5389771e783df7ff1f116d4}{aom\_codec\_encode}(codec, img, frame\_index, 1, flags);
38   \textcolor{keywordflow}{if} (res != \hyperlink{group__codec_ggaaae61e0f8663e6137f1e228757248e7caf145dc2f86014a08ebad36ac2b140001}{AOM\_CODEC\_OK}) die\_codec(codec, \textcolor{stringliteral}{"Failed to encode frame"});
39 
40   \textcolor{keywordflow}{while} ((pkt = \hyperlink{group__encoder_gaedc4c56b60d4217677cb561066360884}{aom\_codec\_get\_cx\_data}(codec, &iter)) != NULL) \{
41     got\_pkts = 1;
42 
43     \textcolor{keywordflow}{if} (pkt->\hyperlink{structaom__codec__cx__pkt_a11e586120c689ece9a7690e72ff384be}{kind} == \hyperlink{group__encoder_ggafeb69da4a9649a54e805f59c26d8dfeda793165d0f219812342f69d5fd9b2b9c8}{AOM\_CODEC\_CX\_FRAME\_PKT}) \{
44       \textcolor{keyword}{const} \textcolor{keywordtype}{int} keyframe = (pkt->\hyperlink{structaom__codec__cx__pkt_afb379cd4bfa7692d1d6e85f4e4b2b410}{data}.\hyperlink{structaom__codec__cx__pkt_a4180a6ae59b0d295bc915d4689df4cb0}{frame}.flags & \hyperlink{group__encoder_gaf4a58f123913a5eef0a3796f0619e5f3}{AOM\_FRAME\_IS\_KEY}) != 0;
45       \textcolor{keywordflow}{if} (!aom\_video\_writer\_write\_frame(writer, pkt->\hyperlink{structaom__codec__cx__pkt_afb379cd4bfa7692d1d6e85f4e4b2b410}{data}.\hyperlink{structaom__codec__cx__pkt_a4180a6ae59b0d295bc915d4689df4cb0}{frame}.buf,
46                                         pkt->\hyperlink{structaom__codec__cx__pkt_afb379cd4bfa7692d1d6e85f4e4b2b410}{data}.\hyperlink{structaom__codec__cx__pkt_a4180a6ae59b0d295bc915d4689df4cb0}{frame}.sz,
47                                         pkt->\hyperlink{structaom__codec__cx__pkt_afb379cd4bfa7692d1d6e85f4e4b2b410}{data}.\hyperlink{structaom__codec__cx__pkt_a4180a6ae59b0d295bc915d4689df4cb0}{frame}.pts)) \{
48         die\_codec(codec, \textcolor{stringliteral}{"Failed to write compressed frame"});
49       \}
50       printf(keyframe ? \textcolor{stringliteral}{"K"} : \textcolor{stringliteral}{"."});
51       fflush(stdout);
52     \}
53   \}
54 
55   \textcolor{keywordflow}{return} got\_pkts;
56 \}
57 
58 \textcolor{keywordtype}{int} main(\textcolor{keywordtype}{int} argc, \textcolor{keywordtype}{char} **argv) \{
59   FILE *infile = NULL;
60   \hyperlink{structaom__codec__ctx}{aom\_codec\_ctx\_t} codec;
61   \hyperlink{structaom__codec__enc__cfg}{aom\_codec\_enc\_cfg\_t} cfg;
62   \textcolor{keywordtype}{int} frame\_count = 0;
63   \hyperlink{structaom__image}{aom\_image\_t} raw;
64   \hyperlink{group__codec_gaaae61e0f8663e6137f1e228757248e7c}{aom\_codec\_err\_t} res;
65   AvxVideoInfo info;
66   AvxVideoWriter *writer = NULL;
67   \textcolor{keyword}{const} AvxInterface *encoder = NULL;
68   \textcolor{keyword}{const} \textcolor{keywordtype}{int} fps = 30;
69 
70   exec\_name = argv[0];
71 
72   \textcolor{comment}{// Clear explicitly, as simply assigning "\{ 0 \}" generates}
73   \textcolor{comment}{// "missing-field-initializers" warning in some compilers.}
74   memset(&info, 0, \textcolor{keyword}{sizeof}(info));
75 
76   \textcolor{keywordflow}{if} (argc < 5) die(\textcolor{stringliteral}{"Invalid number of arguments"});
77 
78   encoder = get\_aom\_encoder\_by\_name(\textcolor{stringliteral}{"av1"});
79   \textcolor{keywordflow}{if} (!encoder) die(\textcolor{stringliteral}{"Unsupported codec."});
80 
81   info.codec\_fourcc = encoder->fourcc;
82   info.frame\_width = (int)strtol(argv[1], NULL, 0);
83   info.frame\_height = (int)strtol(argv[2], NULL, 0);
84   info.time\_base.numerator = 1;
85   info.time\_base.denominator = fps;
86 
87   \textcolor{keywordflow}{if} (info.frame\_width <= 0 || info.frame\_height <= 0 ||
88       (info.frame\_width % 2) != 0 || (info.frame\_height % 2) != 0) \{
89     die(\textcolor{stringliteral}{"Invalid frame size: %dx%d"}, info.frame\_width, info.frame\_height);
90   \}
91 
92   \textcolor{keywordflow}{if} (!\hyperlink{aom__image_8h_a570db29fbd122951235a08fe9375f6bb}{aom\_img\_alloc}(&raw, \hyperlink{aom__image_8h_a930317c04b4bd0a660bb5e744055523cabd778a3d697463e89d12a1117f417b60}{AOM\_IMG\_FMT\_I420}, info.frame\_width,
93                      info.frame\_height, 1)) \{
94     die(\textcolor{stringliteral}{"Failed to allocate image."});
95   \}
96 
97   printf(\textcolor{stringliteral}{"Using %s\(\backslash\)n"}, \hyperlink{group__codec_ga013b1f6d96b2cf9489396311a7e5179b}{aom\_codec\_iface\_name}(encoder->codec\_interface()));
98 
99   res = \hyperlink{group__encoder_gabe456ab6f99bdebc47018779b75d2521}{aom\_codec\_enc\_config\_default}(encoder->codec\_interface(), &cfg, 0);
100   \textcolor{keywordflow}{if} (res) die\_codec(&codec, \textcolor{stringliteral}{"Failed to get default codec config."});
101 
102   cfg.\hyperlink{structaom__codec__enc__cfg_a80cb459c5ef3c7e1516f617c4c9d6eab}{g\_w} = info.frame\_width;
103   cfg.\hyperlink{structaom__codec__enc__cfg_a37b0f57b63bec8d133df8901d4407ee6}{g\_h} = info.frame\_height;
104   cfg.\hyperlink{structaom__codec__enc__cfg_a10664f1fc5b6ec29b77ee13efeeecdf7}{g\_timebase}.\hyperlink{structaom__rational_a7b48174411798c780a15f132c4650839}{num} = info.time\_base.numerator;
105   cfg.\hyperlink{structaom__codec__enc__cfg_a10664f1fc5b6ec29b77ee13efeeecdf7}{g\_timebase}.\hyperlink{structaom__rational_adeddf2ea01c12b7be66536e0a0fb92c5}{den} = info.time\_base.denominator;
106 
107   writer = aom\_video\_writer\_open(argv[4], kContainerIVF, &info);
108   \textcolor{keywordflow}{if} (!writer) die(\textcolor{stringliteral}{"Failed to open %s for writing."}, argv[4]);
109 
110   \textcolor{keywordflow}{if} (!(infile = fopen(argv[3], \textcolor{stringliteral}{"rb"})))
111     die(\textcolor{stringliteral}{"Failed to open %s for reading."}, argv[3]);
112 
113   \textcolor{keywordflow}{if} (\hyperlink{group__encoder_gaade68a7d33d30f97dc9a596aa5e065d8}{aom\_codec\_enc\_init}(&codec, encoder->codec\_interface(), &cfg, 0))
114     die\_codec(&codec, \textcolor{stringliteral}{"Failed to initialize encoder"});
115 
116   \textcolor{keywordflow}{if} (\hyperlink{group__codec_ga51eb332a40dcacc39000ab8e0be36b79}{aom\_codec\_control\_}(&codec, \hyperlink{group__aom__encoder_ggae78dde67a6d78f332e9bdba0dde42db5afe875c6bb02f236be503c8c7b1f15875}{AV1E\_SET\_LOSSLESS}, 1))
117     die\_codec(&codec, \textcolor{stringliteral}{"Failed to use lossless mode"});
118 
119   \textcolor{comment}{// Encode frames.}
120   \textcolor{keywordflow}{while} (aom\_img\_read(&raw, infile)) \{
121     encode\_frame(&codec, &raw, frame\_count++, 0, writer);
122   \}
123 
124   \textcolor{comment}{// Flush encoder.}
125   \textcolor{keywordflow}{while} (encode\_frame(&codec, NULL, -1, 0, writer)) \{
126   \}
127 
128   printf(\textcolor{stringliteral}{"\(\backslash\)n"});
129   fclose(infile);
130   printf(\textcolor{stringliteral}{"Processed %d frames.\(\backslash\)n"}, frame\_count);
131 
132   \hyperlink{aom__image_8h_afff22f7f3eb9409c5b678d1962f110a8}{aom\_img\_free}(&raw);
133   \textcolor{keywordflow}{if} (\hyperlink{group__codec_ga9b60e186f61ba2d6ab2b8069b76a15c5}{aom\_codec\_destroy}(&codec)) die\_codec(&codec, \textcolor{stringliteral}{"Failed to destroy codec."});
134 
135   aom\_video\_writer\_close(writer);
136 
137   \textcolor{keywordflow}{return} EXIT\_SUCCESS;
138 \}
\end{DoxyCodeInclude}
 \hypertarget{example_set_maps}{}\subsection{set\+\_\+maps}\label{example_set_maps}

\begin{DoxyCodeInclude}
1 \textcolor{comment}{/*}
2 \textcolor{comment}{ * Copyright (c) 2016, Alliance for Open Media. All rights reserved}
3 \textcolor{comment}{ *}
4 \textcolor{comment}{ * This source code is subject to the terms of the BSD 2 Clause License and}
5 \textcolor{comment}{ * the Alliance for Open Media Patent License 1.0. If the BSD 2 Clause License}
6 \textcolor{comment}{ * was not distributed with this source code in the LICENSE file, you can}
7 \textcolor{comment}{ * obtain it at www.aomedia.org/license/software. If the Alliance for Open}
8 \textcolor{comment}{ * Media Patent License 1.0 was not distributed with this source code in the}
9 \textcolor{comment}{ * PATENTS file, you can obtain it at www.aomedia.org/license/patent.}
10 \textcolor{comment}{ */}
11 
12 \textcolor{comment}{// AOM Set Active and ROI Maps}
13 \textcolor{comment}{// ===========================}
14 \textcolor{comment}{//}
15 \textcolor{comment}{// This is an example demonstrating how to control the AOM encoder's}
16 \textcolor{comment}{// ROI and Active maps.}
17 \textcolor{comment}{//}
18 \textcolor{comment}{// ROI (Reigon of Interest) maps are a way for the application to assign}
19 \textcolor{comment}{// each macroblock in the image to a region, and then set quantizer and}
20 \textcolor{comment}{// filtering parameters on that image.}
21 \textcolor{comment}{//}
22 \textcolor{comment}{// Active maps are a way for the application to specify on a}
23 \textcolor{comment}{// macroblock-by-macroblock basis whether there is any activity in that}
24 \textcolor{comment}{// macroblock.}
25 \textcolor{comment}{//}
26 \textcolor{comment}{//}
27 \textcolor{comment}{// Configuration}
28 \textcolor{comment}{// -------------}
29 \textcolor{comment}{// An ROI map is set on frame 22. If the width of the image in macroblocks}
30 \textcolor{comment}{// is evenly divisble by 4, then the output will appear to have distinct}
31 \textcolor{comment}{// columns, where the quantizer, loopfilter, and static threshold differ}
32 \textcolor{comment}{// from column to column.}
33 \textcolor{comment}{//}
34 \textcolor{comment}{// An active map is set on frame 33. If the width of the image in macroblocks}
35 \textcolor{comment}{// is evenly divisble by 4, then the output will appear to have distinct}
36 \textcolor{comment}{// columns, where one column will have motion and the next will not.}
37 \textcolor{comment}{//}
38 \textcolor{comment}{// The active map is cleared on frame 44.}
39 \textcolor{comment}{//}
40 \textcolor{comment}{// Observing The Effects}
41 \textcolor{comment}{// ---------------------}
42 \textcolor{comment}{// Use the `simple\_decoder` example to decode this sample, and observe}
43 \textcolor{comment}{// the change in the image at frames 22, 33, and 44.}
44 
45 \textcolor{preprocessor}{#include <assert.h>}
46 \textcolor{preprocessor}{#include <stdio.h>}
47 \textcolor{preprocessor}{#include <stdlib.h>}
48 \textcolor{preprocessor}{#include <string.h>}
49 
50 \textcolor{preprocessor}{#include "\hyperlink{aom__encoder_8h}{aom/aom\_encoder.h}"}
51 \textcolor{preprocessor}{#include "\hyperlink{aomcx_8h}{aom/aomcx.h}"}
52 \textcolor{preprocessor}{#include "common/tools\_common.h"}
53 \textcolor{preprocessor}{#include "common/video\_writer.h"}
54 
55 \textcolor{keyword}{static} \textcolor{keyword}{const} \textcolor{keywordtype}{char} *exec\_name;
56 
57 \textcolor{keywordtype}{void} usage\_exit(\textcolor{keywordtype}{void}) \{
58   fprintf(stderr, \textcolor{stringliteral}{"Usage: %s <codec> <width> <height> <infile> <outfile>\(\backslash\)n"},
59           exec\_name);
60   exit(EXIT\_FAILURE);
61 \}
62 
63 \textcolor{keyword}{static} \textcolor{keywordtype}{void} set\_active\_map(\textcolor{keyword}{const} \hyperlink{structaom__codec__enc__cfg}{aom\_codec\_enc\_cfg\_t} *cfg,
64                            \hyperlink{structaom__codec__ctx}{aom\_codec\_ctx\_t} *codec) \{
65   \textcolor{keywordtype}{unsigned} \textcolor{keywordtype}{int} i;
66   \hyperlink{structaom__active__map}{aom\_active\_map\_t} map = \{ 0, 0, 0 \};
67 
68   map.\hyperlink{structaom__active__map_a0d7ce0e1050137bf9b88e8649ea7aec2}{rows} = (cfg->\hyperlink{structaom__codec__enc__cfg_a37b0f57b63bec8d133df8901d4407ee6}{g\_h} + 15) / 16;
69   map.\hyperlink{structaom__active__map_a3a105e0d8f2643cdc542e2f078b9e6b2}{cols} = (cfg->\hyperlink{structaom__codec__enc__cfg_a80cb459c5ef3c7e1516f617c4c9d6eab}{g\_w} + 15) / 16;
70 
71   map.\hyperlink{structaom__active__map_a8916917bce716b1d954a9f476d98142e}{active\_map} = (uint8\_t *)malloc(map.\hyperlink{structaom__active__map_a0d7ce0e1050137bf9b88e8649ea7aec2}{rows} * map.\hyperlink{structaom__active__map_a3a105e0d8f2643cdc542e2f078b9e6b2}{cols});
72   \textcolor{keywordflow}{for} (i = 0; i < map.\hyperlink{structaom__active__map_a0d7ce0e1050137bf9b88e8649ea7aec2}{rows} * map.\hyperlink{structaom__active__map_a3a105e0d8f2643cdc542e2f078b9e6b2}{cols}; ++i) map.\hyperlink{structaom__active__map_a8916917bce716b1d954a9f476d98142e}{active\_map}[i] = i % 2;
73 
74   if (\hyperlink{group__codec_ga6da974f4eeaba1fa74106b28d0fe6ac5}{aom\_codec\_control}(codec, \hyperlink{group__aom__encoder_ggae78dde67a6d78f332e9bdba0dde42db5a709937e1e0eb160e49720e6fd5164d1e}{AOME\_SET\_ACTIVEMAP}, &map))
75     die\_codec(codec, \textcolor{stringliteral}{"Failed to set active map"});
76 
77   free(map.\hyperlink{structaom__active__map_a8916917bce716b1d954a9f476d98142e}{active\_map});
78 \}
79 
80 \textcolor{keyword}{static} \textcolor{keywordtype}{void} unset\_active\_map(\textcolor{keyword}{const} \hyperlink{structaom__codec__enc__cfg}{aom\_codec\_enc\_cfg\_t} *cfg,
81                              \hyperlink{structaom__codec__ctx}{aom\_codec\_ctx\_t} *codec) \{
82   \hyperlink{structaom__active__map}{aom\_active\_map\_t} map = \{ 0, 0, 0 \};
83 
84   map.\hyperlink{structaom__active__map_a0d7ce0e1050137bf9b88e8649ea7aec2}{rows} = (cfg->\hyperlink{structaom__codec__enc__cfg_a37b0f57b63bec8d133df8901d4407ee6}{g\_h} + 15) / 16;
85   map.\hyperlink{structaom__active__map_a3a105e0d8f2643cdc542e2f078b9e6b2}{cols} = (cfg->\hyperlink{structaom__codec__enc__cfg_a80cb459c5ef3c7e1516f617c4c9d6eab}{g\_w} + 15) / 16;
86   map.\hyperlink{structaom__active__map_a8916917bce716b1d954a9f476d98142e}{active\_map} = NULL;
87 
88   \textcolor{keywordflow}{if} (\hyperlink{group__codec_ga6da974f4eeaba1fa74106b28d0fe6ac5}{aom\_codec\_control}(codec, \hyperlink{group__aom__encoder_ggae78dde67a6d78f332e9bdba0dde42db5a709937e1e0eb160e49720e6fd5164d1e}{AOME\_SET\_ACTIVEMAP}, &map))
89     die\_codec(codec, \textcolor{stringliteral}{"Failed to set active map"});
90 \}
91 
92 \textcolor{keyword}{static} \textcolor{keywordtype}{int} encode\_frame(\hyperlink{structaom__codec__ctx}{aom\_codec\_ctx\_t} *codec, \hyperlink{structaom__image}{aom\_image\_t} *img,
93                         \textcolor{keywordtype}{int} frame\_index, AvxVideoWriter *writer) \{
94   \textcolor{keywordtype}{int} got\_pkts = 0;
95   \hyperlink{group__codec_gadf9e173c9e02788a9999399edab20a02}{aom\_codec\_iter\_t} iter = NULL;
96   \textcolor{keyword}{const} \hyperlink{structaom__codec__cx__pkt}{aom\_codec\_cx\_pkt\_t} *pkt = NULL;
97   \textcolor{keyword}{const} \hyperlink{group__codec_gaaae61e0f8663e6137f1e228757248e7c}{aom\_codec\_err\_t} res = \hyperlink{group__encoder_ga6f4a777de5389771e783df7ff1f116d4}{aom\_codec\_encode}(codec, img, frame\_index, 1, 0
      );
98   \textcolor{keywordflow}{if} (res != \hyperlink{group__codec_ggaaae61e0f8663e6137f1e228757248e7caf145dc2f86014a08ebad36ac2b140001}{AOM\_CODEC\_OK}) die\_codec(codec, \textcolor{stringliteral}{"Failed to encode frame"});
99 
100   \textcolor{keywordflow}{while} ((pkt = \hyperlink{group__encoder_gaedc4c56b60d4217677cb561066360884}{aom\_codec\_get\_cx\_data}(codec, &iter)) != NULL) \{
101     got\_pkts = 1;
102 
103     \textcolor{keywordflow}{if} (pkt->\hyperlink{structaom__codec__cx__pkt_a11e586120c689ece9a7690e72ff384be}{kind} == \hyperlink{group__encoder_ggafeb69da4a9649a54e805f59c26d8dfeda793165d0f219812342f69d5fd9b2b9c8}{AOM\_CODEC\_CX\_FRAME\_PKT}) \{
104       \textcolor{keyword}{const} \textcolor{keywordtype}{int} keyframe = (pkt->\hyperlink{structaom__codec__cx__pkt_afb379cd4bfa7692d1d6e85f4e4b2b410}{data}.\hyperlink{structaom__codec__cx__pkt_a4180a6ae59b0d295bc915d4689df4cb0}{frame}.flags & \hyperlink{group__encoder_gaf4a58f123913a5eef0a3796f0619e5f3}{AOM\_FRAME\_IS\_KEY}) != 0;
105       \textcolor{keywordflow}{if} (!aom\_video\_writer\_write\_frame(writer, pkt->\hyperlink{structaom__codec__cx__pkt_afb379cd4bfa7692d1d6e85f4e4b2b410}{data}.\hyperlink{structaom__codec__cx__pkt_a4180a6ae59b0d295bc915d4689df4cb0}{frame}.buf,
106                                         pkt->\hyperlink{structaom__codec__cx__pkt_afb379cd4bfa7692d1d6e85f4e4b2b410}{data}.\hyperlink{structaom__codec__cx__pkt_a4180a6ae59b0d295bc915d4689df4cb0}{frame}.sz,
107                                         pkt->\hyperlink{structaom__codec__cx__pkt_afb379cd4bfa7692d1d6e85f4e4b2b410}{data}.\hyperlink{structaom__codec__cx__pkt_a4180a6ae59b0d295bc915d4689df4cb0}{frame}.pts)) \{
108         die\_codec(codec, \textcolor{stringliteral}{"Failed to write compressed frame"});
109       \}
110 
111       printf(keyframe ? \textcolor{stringliteral}{"K"} : \textcolor{stringliteral}{"."});
112       fflush(stdout);
113     \}
114   \}
115 
116   \textcolor{keywordflow}{return} got\_pkts;
117 \}
118 
119 \textcolor{keywordtype}{int} main(\textcolor{keywordtype}{int} argc, \textcolor{keywordtype}{char} **argv) \{
120   FILE *infile = NULL;
121   \hyperlink{structaom__codec__ctx}{aom\_codec\_ctx\_t} codec;
122   \hyperlink{structaom__codec__enc__cfg}{aom\_codec\_enc\_cfg\_t} cfg;
123   \textcolor{keywordtype}{int} frame\_count = 0;
124   \textcolor{keyword}{const} \textcolor{keywordtype}{int} limit = 15;
125   \hyperlink{structaom__image}{aom\_image\_t} raw;
126   \hyperlink{group__codec_gaaae61e0f8663e6137f1e228757248e7c}{aom\_codec\_err\_t} res;
127   AvxVideoInfo info;
128   AvxVideoWriter *writer = NULL;
129   \textcolor{keyword}{const} AvxInterface *encoder = NULL;
130   \textcolor{keyword}{const} \textcolor{keywordtype}{int} fps = 2;  \textcolor{comment}{// TODO(dkovalev) add command line argument}
131   \textcolor{keyword}{const} \textcolor{keywordtype}{double} bits\_per\_pixel\_per\_frame = 0.067;
132 
133   exec\_name = argv[0];
134   \textcolor{keywordflow}{if} (argc != 6) die(\textcolor{stringliteral}{"Invalid number of arguments"});
135 
136   memset(&info, 0, \textcolor{keyword}{sizeof}(info));
137 
138   encoder = get\_aom\_encoder\_by\_name(argv[1]);
139   \textcolor{keywordflow}{if} (encoder == NULL) \{
140     die(\textcolor{stringliteral}{"Unsupported codec."});
141   \}
142   assert(encoder != NULL);
143   info.codec\_fourcc = encoder->fourcc;
144   info.frame\_width = (int)strtol(argv[2], NULL, 0);
145   info.frame\_height = (int)strtol(argv[3], NULL, 0);
146   info.time\_base.numerator = 1;
147   info.time\_base.denominator = fps;
148 
149   \textcolor{keywordflow}{if} (info.frame\_width <= 0 || info.frame\_height <= 0 ||
150       (info.frame\_width % 2) != 0 || (info.frame\_height % 2) != 0) \{
151     die(\textcolor{stringliteral}{"Invalid frame size: %dx%d"}, info.frame\_width, info.frame\_height);
152   \}
153 
154   \textcolor{keywordflow}{if} (!\hyperlink{aom__image_8h_a570db29fbd122951235a08fe9375f6bb}{aom\_img\_alloc}(&raw, \hyperlink{aom__image_8h_a930317c04b4bd0a660bb5e744055523cabd778a3d697463e89d12a1117f417b60}{AOM\_IMG\_FMT\_I420}, info.frame\_width,
155                      info.frame\_height, 1)) \{
156     die(\textcolor{stringliteral}{"Failed to allocate image."});
157   \}
158 
159   printf(\textcolor{stringliteral}{"Using %s\(\backslash\)n"}, \hyperlink{group__codec_ga013b1f6d96b2cf9489396311a7e5179b}{aom\_codec\_iface\_name}(encoder->codec\_interface()));
160 
161   res = \hyperlink{group__encoder_gabe456ab6f99bdebc47018779b75d2521}{aom\_codec\_enc\_config\_default}(encoder->codec\_interface(), &cfg, 0);
162   \textcolor{keywordflow}{if} (res) die\_codec(&codec, \textcolor{stringliteral}{"Failed to get default codec config."});
163 
164   cfg.\hyperlink{structaom__codec__enc__cfg_a80cb459c5ef3c7e1516f617c4c9d6eab}{g\_w} = info.frame\_width;
165   cfg.\hyperlink{structaom__codec__enc__cfg_a37b0f57b63bec8d133df8901d4407ee6}{g\_h} = info.frame\_height;
166   cfg.\hyperlink{structaom__codec__enc__cfg_a10664f1fc5b6ec29b77ee13efeeecdf7}{g\_timebase}.\hyperlink{structaom__rational_a7b48174411798c780a15f132c4650839}{num} = info.time\_base.numerator;
167   cfg.\hyperlink{structaom__codec__enc__cfg_a10664f1fc5b6ec29b77ee13efeeecdf7}{g\_timebase}.\hyperlink{structaom__rational_adeddf2ea01c12b7be66536e0a0fb92c5}{den} = info.time\_base.denominator;
168   cfg.\hyperlink{structaom__codec__enc__cfg_ab21539da477dba7506d90353c27d218b}{rc\_target\_bitrate} =
169       (\textcolor{keywordtype}{unsigned} int)(bits\_per\_pixel\_per\_frame * cfg.\hyperlink{structaom__codec__enc__cfg_a80cb459c5ef3c7e1516f617c4c9d6eab}{g\_w} * cfg.\hyperlink{structaom__codec__enc__cfg_a37b0f57b63bec8d133df8901d4407ee6}{g\_h} * fps / 1000);
170   cfg.\hyperlink{structaom__codec__enc__cfg_a614a49318f2011cc8735d7e51b910fa4}{g\_lag\_in\_frames} = 0;
171 
172   writer = aom\_video\_writer\_open(argv[5], kContainerIVF, &info);
173   \textcolor{keywordflow}{if} (!writer) die(\textcolor{stringliteral}{"Failed to open %s for writing."}, argv[5]);
174 
175   \textcolor{keywordflow}{if} (!(infile = fopen(argv[4], \textcolor{stringliteral}{"rb"})))
176     die(\textcolor{stringliteral}{"Failed to open %s for reading."}, argv[4]);
177 
178   \textcolor{keywordflow}{if} (\hyperlink{group__encoder_gaade68a7d33d30f97dc9a596aa5e065d8}{aom\_codec\_enc\_init}(&codec, encoder->codec\_interface(), &cfg, 0))
179     die\_codec(&codec, \textcolor{stringliteral}{"Failed to initialize encoder"});
180 
181   \textcolor{comment}{// Encode frames.}
182   \textcolor{keywordflow}{while} (aom\_img\_read(&raw, infile) && frame\_count < limit) \{
183     ++frame\_count;
184 
185     \textcolor{keywordflow}{if} (frame\_count == 5) \{
186       set\_active\_map(&cfg, &codec);
187     \} \textcolor{keywordflow}{else} \textcolor{keywordflow}{if} (frame\_count == 11) \{
188       unset\_active\_map(&cfg, &codec);
189     \}
190 
191     encode\_frame(&codec, &raw, frame\_count, writer);
192   \}
193 
194   \textcolor{comment}{// Flush encoder.}
195   \textcolor{keywordflow}{while} (encode\_frame(&codec, NULL, -1, writer)) \{
196   \}
197 
198   printf(\textcolor{stringliteral}{"\(\backslash\)n"});
199   fclose(infile);
200   printf(\textcolor{stringliteral}{"Processed %d frames.\(\backslash\)n"}, frame\_count);
201 
202   \hyperlink{aom__image_8h_afff22f7f3eb9409c5b678d1962f110a8}{aom\_img\_free}(&raw);
203   \textcolor{keywordflow}{if} (\hyperlink{group__codec_ga9b60e186f61ba2d6ab2b8069b76a15c5}{aom\_codec\_destroy}(&codec)) die\_codec(&codec, \textcolor{stringliteral}{"Failed to destroy codec."});
204 
205   aom\_video\_writer\_close(writer);
206 
207   \textcolor{keywordflow}{return} EXIT\_SUCCESS;
208 \}
\end{DoxyCodeInclude}
 \hypertarget{example_simple_encoder}{}\subsection{simple\+\_\+encoder}\label{example_simple_encoder}

\begin{DoxyCodeInclude}
1 \textcolor{comment}{/*}
2 \textcolor{comment}{ * Copyright (c) 2016, Alliance for Open Media. All rights reserved}
3 \textcolor{comment}{ *}
4 \textcolor{comment}{ * This source code is subject to the terms of the BSD 2 Clause License and}
5 \textcolor{comment}{ * the Alliance for Open Media Patent License 1.0. If the BSD 2 Clause License}
6 \textcolor{comment}{ * was not distributed with this source code in the LICENSE file, you can}
7 \textcolor{comment}{ * obtain it at www.aomedia.org/license/software. If the Alliance for Open}
8 \textcolor{comment}{ * Media Patent License 1.0 was not distributed with this source code in the}
9 \textcolor{comment}{ * PATENTS file, you can obtain it at www.aomedia.org/license/patent.}
10 \textcolor{comment}{ */}
11 
12 \textcolor{comment}{// Simple Encoder}
13 \textcolor{comment}{// ==============}
14 \textcolor{comment}{//}
15 \textcolor{comment}{// This is an example of a simple encoder loop. It takes an input file in}
16 \textcolor{comment}{// YV12 format, passes it through the encoder, and writes the compressed}
17 \textcolor{comment}{// frames to disk in IVF format. Other decoder examples build upon this}
18 \textcolor{comment}{// one.}
19 \textcolor{comment}{//}
20 \textcolor{comment}{// The details of the IVF format have been elided from this example for}
21 \textcolor{comment}{// simplicity of presentation, as IVF files will not generally be used by}
22 \textcolor{comment}{// your application. In general, an IVF file consists of a file header,}
23 \textcolor{comment}{// followed by a variable number of frames. Each frame consists of a frame}
24 \textcolor{comment}{// header followed by a variable length payload. The length of the payload}
25 \textcolor{comment}{// is specified in the first four bytes of the frame header. The payload is}
26 \textcolor{comment}{// the raw compressed data.}
27 \textcolor{comment}{//}
28 \textcolor{comment}{// Standard Includes}
29 \textcolor{comment}{// -----------------}
30 \textcolor{comment}{// For encoders, you only have to include `aom\_encoder.h` and then any}
31 \textcolor{comment}{// header files for the specific codecs you use. In this case, we're using}
32 \textcolor{comment}{// aom.}
33 \textcolor{comment}{//}
34 \textcolor{comment}{// Getting The Default Configuration}
35 \textcolor{comment}{// ---------------------------------}
36 \textcolor{comment}{// Encoders have the notion of "usage profiles." For example, an encoder}
37 \textcolor{comment}{// may want to publish default configurations for both a video}
38 \textcolor{comment}{// conferencing application and a best quality offline encoder. These}
39 \textcolor{comment}{// obviously have very different default settings. Consult the}
40 \textcolor{comment}{// documentation for your codec to see if it provides any default}
41 \textcolor{comment}{// configurations. All codecs provide a default configuration, number 0,}
42 \textcolor{comment}{// which is valid for material in the vacinity of QCIF/QVGA.}
43 \textcolor{comment}{//}
44 \textcolor{comment}{// Updating The Configuration}
45 \textcolor{comment}{// ---------------------------------}
46 \textcolor{comment}{// Almost all applications will want to update the default configuration}
47 \textcolor{comment}{// with settings specific to their usage. Here we set the width and height}
48 \textcolor{comment}{// of the video file to that specified on the command line. We also scale}
49 \textcolor{comment}{// the default bitrate based on the ratio between the default resolution}
50 \textcolor{comment}{// and the resolution specified on the command line.}
51 \textcolor{comment}{//}
52 \textcolor{comment}{// Initializing The Codec}
53 \textcolor{comment}{// ----------------------}
54 \textcolor{comment}{// The encoder is initialized by the following code.}
55 \textcolor{comment}{//}
56 \textcolor{comment}{// Encoding A Frame}
57 \textcolor{comment}{// ----------------}
58 \textcolor{comment}{// The frame is read as a continuous block (size width * height * 3 / 2)}
59 \textcolor{comment}{// from the input file. If a frame was read (the input file has not hit}
60 \textcolor{comment}{// EOF) then the frame is passed to the encoder. Otherwise, a NULL}
61 \textcolor{comment}{// is passed, indicating the End-Of-Stream condition to the encoder. The}
62 \textcolor{comment}{// `frame\_cnt` is reused as the presentation time stamp (PTS) and each}
63 \textcolor{comment}{// frame is shown for one frame-time in duration. The flags parameter is}
64 \textcolor{comment}{// unused in this example.}
65 
66 \textcolor{comment}{// Forced Keyframes}
67 \textcolor{comment}{// ----------------}
68 \textcolor{comment}{// Keyframes can be forced by setting the AOM\_EFLAG\_FORCE\_KF bit of the}
69 \textcolor{comment}{// flags passed to `aom\_codec\_control()`. In this example, we force a}
70 \textcolor{comment}{// keyframe every <keyframe-interval> frames. Note, the output stream can}
71 \textcolor{comment}{// contain additional keyframes beyond those that have been forced using the}
72 \textcolor{comment}{// AOM\_EFLAG\_FORCE\_KF flag because of automatic keyframe placement by the}
73 \textcolor{comment}{// encoder.}
74 \textcolor{comment}{//}
75 \textcolor{comment}{// Processing The Encoded Data}
76 \textcolor{comment}{// ---------------------------}
77 \textcolor{comment}{// Each packet of type `AOM\_CODEC\_CX\_FRAME\_PKT` contains the encoded data}
78 \textcolor{comment}{// for this frame. We write a IVF frame header, followed by the raw data.}
79 \textcolor{comment}{//}
80 \textcolor{comment}{// Cleanup}
81 \textcolor{comment}{// -------}
82 \textcolor{comment}{// The `aom\_codec\_destroy` call frees any memory allocated by the codec.}
83 \textcolor{comment}{//}
84 \textcolor{comment}{// Error Handling}
85 \textcolor{comment}{// --------------}
86 \textcolor{comment}{// This example does not special case any error return codes. If there was}
87 \textcolor{comment}{// an error, a descriptive message is printed and the program exits. With}
88 \textcolor{comment}{// few exeptions, aom\_codec functions return an enumerated error status,}
89 \textcolor{comment}{// with the value `0` indicating success.}
90 \textcolor{comment}{//}
91 \textcolor{comment}{// Error Resiliency Features}
92 \textcolor{comment}{// -------------------------}
93 \textcolor{comment}{// Error resiliency is controlled by the g\_error\_resilient member of the}
94 \textcolor{comment}{// configuration structure. Use the `decode\_with\_drops` example to decode with}
95 \textcolor{comment}{// frames 5-10 dropped. Compare the output for a file encoded with this example}
96 \textcolor{comment}{// versus one encoded with the `simple\_encoder` example.}
97 
98 \textcolor{preprocessor}{#include <stdio.h>}
99 \textcolor{preprocessor}{#include <stdlib.h>}
100 \textcolor{preprocessor}{#include <string.h>}
101 
102 \textcolor{preprocessor}{#include "\hyperlink{aom__encoder_8h}{aom/aom\_encoder.h}"}
103 \textcolor{preprocessor}{#include "common/tools\_common.h"}
104 \textcolor{preprocessor}{#include "common/video\_writer.h"}
105 
106 \textcolor{keyword}{static} \textcolor{keyword}{const} \textcolor{keywordtype}{char} *exec\_name;
107 
108 \textcolor{keywordtype}{void} usage\_exit(\textcolor{keywordtype}{void}) \{
109   fprintf(stderr,
110           \textcolor{stringliteral}{"Usage: %s <codec> <width> <height> <infile> <outfile> "}
111           \textcolor{stringliteral}{"<keyframe-interval> <error-resilient> <frames to encode>\(\backslash\)n"}
112           \textcolor{stringliteral}{"See comments in simple\_encoder.c for more information.\(\backslash\)n"},
113           exec\_name);
114   exit(EXIT\_FAILURE);
115 \}
116 
117 \textcolor{keyword}{static} \textcolor{keywordtype}{int} encode\_frame(\hyperlink{structaom__codec__ctx}{aom\_codec\_ctx\_t} *codec, \hyperlink{structaom__image}{aom\_image\_t} *img,
118                         \textcolor{keywordtype}{int} frame\_index, \textcolor{keywordtype}{int} flags, AvxVideoWriter *writer) \{
119   \textcolor{keywordtype}{int} got\_pkts = 0;
120   \hyperlink{group__codec_gadf9e173c9e02788a9999399edab20a02}{aom\_codec\_iter\_t} iter = NULL;
121   \textcolor{keyword}{const} \hyperlink{structaom__codec__cx__pkt}{aom\_codec\_cx\_pkt\_t} *pkt = NULL;
122   \textcolor{keyword}{const} \hyperlink{group__codec_gaaae61e0f8663e6137f1e228757248e7c}{aom\_codec\_err\_t} res =
123       \hyperlink{group__encoder_ga6f4a777de5389771e783df7ff1f116d4}{aom\_codec\_encode}(codec, img, frame\_index, 1, flags);
124   \textcolor{keywordflow}{if} (res != \hyperlink{group__codec_ggaaae61e0f8663e6137f1e228757248e7caf145dc2f86014a08ebad36ac2b140001}{AOM\_CODEC\_OK}) die\_codec(codec, \textcolor{stringliteral}{"Failed to encode frame"});
125 
126   \textcolor{keywordflow}{while} ((pkt = \hyperlink{group__encoder_gaedc4c56b60d4217677cb561066360884}{aom\_codec\_get\_cx\_data}(codec, &iter)) != NULL) \{
127     got\_pkts = 1;
128 
129     \textcolor{keywordflow}{if} (pkt->\hyperlink{structaom__codec__cx__pkt_a11e586120c689ece9a7690e72ff384be}{kind} == \hyperlink{group__encoder_ggafeb69da4a9649a54e805f59c26d8dfeda793165d0f219812342f69d5fd9b2b9c8}{AOM\_CODEC\_CX\_FRAME\_PKT}) \{
130       \textcolor{keyword}{const} \textcolor{keywordtype}{int} keyframe = (pkt->\hyperlink{structaom__codec__cx__pkt_afb379cd4bfa7692d1d6e85f4e4b2b410}{data}.\hyperlink{structaom__codec__cx__pkt_a4180a6ae59b0d295bc915d4689df4cb0}{frame}.flags & \hyperlink{group__encoder_gaf4a58f123913a5eef0a3796f0619e5f3}{AOM\_FRAME\_IS\_KEY}) != 0;
131       \textcolor{keywordflow}{if} (!aom\_video\_writer\_write\_frame(writer, pkt->\hyperlink{structaom__codec__cx__pkt_afb379cd4bfa7692d1d6e85f4e4b2b410}{data}.\hyperlink{structaom__codec__cx__pkt_a4180a6ae59b0d295bc915d4689df4cb0}{frame}.buf,
132                                         pkt->\hyperlink{structaom__codec__cx__pkt_afb379cd4bfa7692d1d6e85f4e4b2b410}{data}.\hyperlink{structaom__codec__cx__pkt_a4180a6ae59b0d295bc915d4689df4cb0}{frame}.sz,
133                                         pkt->\hyperlink{structaom__codec__cx__pkt_afb379cd4bfa7692d1d6e85f4e4b2b410}{data}.\hyperlink{structaom__codec__cx__pkt_a4180a6ae59b0d295bc915d4689df4cb0}{frame}.pts)) \{
134         die\_codec(codec, \textcolor{stringliteral}{"Failed to write compressed frame"});
135       \}
136       printf(keyframe ? \textcolor{stringliteral}{"K"} : \textcolor{stringliteral}{"."});
137       fflush(stdout);
138     \}
139   \}
140 
141   \textcolor{keywordflow}{return} got\_pkts;
142 \}
143 
144 \textcolor{comment}{// TODO(tomfinegan): Improve command line parsing and add args for bitrate/fps.}
145 \textcolor{keywordtype}{int} main(\textcolor{keywordtype}{int} argc, \textcolor{keywordtype}{char} **argv) \{
146   FILE *infile = NULL;
147   \hyperlink{structaom__codec__ctx}{aom\_codec\_ctx\_t} codec;
148   \hyperlink{structaom__codec__enc__cfg}{aom\_codec\_enc\_cfg\_t} cfg;
149   \textcolor{keywordtype}{int} frame\_count = 0;
150   \hyperlink{structaom__image}{aom\_image\_t} raw;
151   \hyperlink{group__codec_gaaae61e0f8663e6137f1e228757248e7c}{aom\_codec\_err\_t} res;
152   AvxVideoInfo info;
153   AvxVideoWriter *writer = NULL;
154   \textcolor{keyword}{const} AvxInterface *encoder = NULL;
155   \textcolor{keyword}{const} \textcolor{keywordtype}{int} fps = 30;
156   \textcolor{keyword}{const} \textcolor{keywordtype}{int} bitrate = 200;
157   \textcolor{keywordtype}{int} keyframe\_interval = 0;
158   \textcolor{keywordtype}{int} max\_frames = 0;
159   \textcolor{keywordtype}{int} frames\_encoded = 0;
160   \textcolor{keyword}{const} \textcolor{keywordtype}{char} *codec\_arg = NULL;
161   \textcolor{keyword}{const} \textcolor{keywordtype}{char} *width\_arg = NULL;
162   \textcolor{keyword}{const} \textcolor{keywordtype}{char} *height\_arg = NULL;
163   \textcolor{keyword}{const} \textcolor{keywordtype}{char} *infile\_arg = NULL;
164   \textcolor{keyword}{const} \textcolor{keywordtype}{char} *outfile\_arg = NULL;
165   \textcolor{keyword}{const} \textcolor{keywordtype}{char} *keyframe\_interval\_arg = NULL;
166 
167   exec\_name = argv[0];
168 
169   \textcolor{comment}{// Clear explicitly, as simply assigning "\{ 0 \}" generates}
170   \textcolor{comment}{// "missing-field-initializers" warning in some compilers.}
171   memset(&info, 0, \textcolor{keyword}{sizeof}(info));
172 
173   \textcolor{keywordflow}{if} (argc != 9) die(\textcolor{stringliteral}{"Invalid number of arguments"});
174 
175   codec\_arg = argv[1];
176   width\_arg = argv[2];
177   height\_arg = argv[3];
178   infile\_arg = argv[4];
179   outfile\_arg = argv[5];
180   keyframe\_interval\_arg = argv[6];
181   max\_frames = (int)strtol(argv[8], NULL, 0);
182 
183   encoder = get\_aom\_encoder\_by\_name(codec\_arg);
184   \textcolor{keywordflow}{if} (!encoder) die(\textcolor{stringliteral}{"Unsupported codec."});
185 
186   info.codec\_fourcc = encoder->fourcc;
187   info.frame\_width = (int)strtol(width\_arg, NULL, 0);
188   info.frame\_height = (int)strtol(height\_arg, NULL, 0);
189   info.time\_base.numerator = 1;
190   info.time\_base.denominator = fps;
191 
192   \textcolor{keywordflow}{if} (info.frame\_width <= 0 || info.frame\_height <= 0 ||
193       (info.frame\_width % 2) != 0 || (info.frame\_height % 2) != 0) \{
194     die(\textcolor{stringliteral}{"Invalid frame size: %dx%d"}, info.frame\_width, info.frame\_height);
195   \}
196 
197   \textcolor{keywordflow}{if} (!\hyperlink{aom__image_8h_a570db29fbd122951235a08fe9375f6bb}{aom\_img\_alloc}(&raw, \hyperlink{aom__image_8h_a930317c04b4bd0a660bb5e744055523cabd778a3d697463e89d12a1117f417b60}{AOM\_IMG\_FMT\_I420}, info.frame\_width,
198                      info.frame\_height, 1)) \{
199     die(\textcolor{stringliteral}{"Failed to allocate image."});
200   \}
201 
202   keyframe\_interval = (int)strtol(keyframe\_interval\_arg, NULL, 0);
203   \textcolor{keywordflow}{if} (keyframe\_interval < 0) die(\textcolor{stringliteral}{"Invalid keyframe interval value."});
204 
205   printf(\textcolor{stringliteral}{"Using %s\(\backslash\)n"}, \hyperlink{group__codec_ga013b1f6d96b2cf9489396311a7e5179b}{aom\_codec\_iface\_name}(encoder->codec\_interface()));
206 
207   res = \hyperlink{group__encoder_gabe456ab6f99bdebc47018779b75d2521}{aom\_codec\_enc\_config\_default}(encoder->codec\_interface(), &cfg, 0);
208   \textcolor{keywordflow}{if} (res) die\_codec(&codec, \textcolor{stringliteral}{"Failed to get default codec config."});
209 
210   cfg.\hyperlink{structaom__codec__enc__cfg_a80cb459c5ef3c7e1516f617c4c9d6eab}{g\_w} = info.frame\_width;
211   cfg.\hyperlink{structaom__codec__enc__cfg_a37b0f57b63bec8d133df8901d4407ee6}{g\_h} = info.frame\_height;
212   cfg.\hyperlink{structaom__codec__enc__cfg_a10664f1fc5b6ec29b77ee13efeeecdf7}{g\_timebase}.\hyperlink{structaom__rational_a7b48174411798c780a15f132c4650839}{num} = info.time\_base.numerator;
213   cfg.\hyperlink{structaom__codec__enc__cfg_a10664f1fc5b6ec29b77ee13efeeecdf7}{g\_timebase}.\hyperlink{structaom__rational_adeddf2ea01c12b7be66536e0a0fb92c5}{den} = info.time\_base.denominator;
214   cfg.\hyperlink{structaom__codec__enc__cfg_ab21539da477dba7506d90353c27d218b}{rc\_target\_bitrate} = bitrate;
215   cfg.\hyperlink{structaom__codec__enc__cfg_a8f3763485bb1f6eea6466b2fe0da2304}{g\_error\_resilient} = (\hyperlink{group__encoder_ga5f326af84993f371bb165883bb5a5a59}{aom\_codec\_er\_flags\_t})strtoul(argv[7], NULL,
       0);
216 
217   writer = aom\_video\_writer\_open(outfile\_arg, kContainerIVF, &info);
218   \textcolor{keywordflow}{if} (!writer) die(\textcolor{stringliteral}{"Failed to open %s for writing."}, outfile\_arg);
219 
220   \textcolor{keywordflow}{if} (!(infile = fopen(infile\_arg, \textcolor{stringliteral}{"rb"})))
221     die(\textcolor{stringliteral}{"Failed to open %s for reading."}, infile\_arg);
222 
223   \textcolor{keywordflow}{if} (\hyperlink{group__encoder_gaade68a7d33d30f97dc9a596aa5e065d8}{aom\_codec\_enc\_init}(&codec, encoder->codec\_interface(), &cfg, 0))
224     die\_codec(&codec, \textcolor{stringliteral}{"Failed to initialize encoder"});
225 
226   \textcolor{comment}{// Encode frames.}
227   \textcolor{keywordflow}{while} (aom\_img\_read(&raw, infile)) \{
228     \textcolor{keywordtype}{int} flags = 0;
229     \textcolor{keywordflow}{if} (keyframe\_interval > 0 && frame\_count % keyframe\_interval == 0)
230       flags |= \hyperlink{group__encoder_ga86a6a9053205149cccc98481b5460337}{AOM\_EFLAG\_FORCE\_KF};
231     encode\_frame(&codec, &raw, frame\_count++, flags, writer);
232     frames\_encoded++;
233     \textcolor{keywordflow}{if} (max\_frames > 0 && frames\_encoded >= max\_frames) \textcolor{keywordflow}{break};
234   \}
235 
236   \textcolor{comment}{// Flush encoder.}
237   \textcolor{keywordflow}{while} (encode\_frame(&codec, NULL, -1, 0, writer)) \textcolor{keywordflow}{continue};
238 
239   printf(\textcolor{stringliteral}{"\(\backslash\)n"});
240   fclose(infile);
241   printf(\textcolor{stringliteral}{"Processed %d frames.\(\backslash\)n"}, frame\_count);
242 
243   \hyperlink{aom__image_8h_afff22f7f3eb9409c5b678d1962f110a8}{aom\_img\_free}(&raw);
244   \textcolor{keywordflow}{if} (\hyperlink{group__codec_ga9b60e186f61ba2d6ab2b8069b76a15c5}{aom\_codec\_destroy}(&codec)) die\_codec(&codec, \textcolor{stringliteral}{"Failed to destroy codec."});
245 
246   aom\_video\_writer\_close(writer);
247 
248   \textcolor{keywordflow}{return} EXIT\_SUCCESS;
249 \}
\end{DoxyCodeInclude}
 \hypertarget{example_twopass_encoder}{}\subsection{twopass\+\_\+encoder}\label{example_twopass_encoder}

\begin{DoxyCodeInclude}
1 \textcolor{comment}{/*}
2 \textcolor{comment}{ * Copyright (c) 2016, Alliance for Open Media. All rights reserved}
3 \textcolor{comment}{ *}
4 \textcolor{comment}{ * This source code is subject to the terms of the BSD 2 Clause License and}
5 \textcolor{comment}{ * the Alliance for Open Media Patent License 1.0. If the BSD 2 Clause License}
6 \textcolor{comment}{ * was not distributed with this source code in the LICENSE file, you can}
7 \textcolor{comment}{ * obtain it at www.aomedia.org/license/software. If the Alliance for Open}
8 \textcolor{comment}{ * Media Patent License 1.0 was not distributed with this source code in the}
9 \textcolor{comment}{ * PATENTS file, you can obtain it at www.aomedia.org/license/patent.}
10 \textcolor{comment}{ */}
11 
12 \textcolor{comment}{// Two Pass Encoder}
13 \textcolor{comment}{// ================}
14 \textcolor{comment}{//}
15 \textcolor{comment}{// This is an example of a two pass encoder loop. It takes an input file in}
16 \textcolor{comment}{// YV12 format, passes it through the encoder twice, and writes the compressed}
17 \textcolor{comment}{// frames to disk in IVF format. It builds upon the simple\_encoder example.}
18 \textcolor{comment}{//}
19 \textcolor{comment}{// Twopass Variables}
20 \textcolor{comment}{// -----------------}
21 \textcolor{comment}{// Twopass mode needs to track the current pass number and the buffer of}
22 \textcolor{comment}{// statistics packets.}
23 \textcolor{comment}{//}
24 \textcolor{comment}{// Updating The Configuration}
25 \textcolor{comment}{// ---------------------------------}
26 \textcolor{comment}{// In two pass mode, the configuration has to be updated on each pass. The}
27 \textcolor{comment}{// statistics buffer is passed on the last pass.}
28 \textcolor{comment}{//}
29 \textcolor{comment}{// Encoding A Frame}
30 \textcolor{comment}{// ----------------}
31 \textcolor{comment}{// Encoding a frame in two pass mode is identical to the simple encoder}
32 \textcolor{comment}{// example.}
33 \textcolor{comment}{//}
34 \textcolor{comment}{// Processing Statistics Packets}
35 \textcolor{comment}{// -----------------------------}
36 \textcolor{comment}{// Each packet of type `AOM\_CODEC\_CX\_FRAME\_PKT` contains the encoded data}
37 \textcolor{comment}{// for this frame. We write a IVF frame header, followed by the raw data.}
38 \textcolor{comment}{//}
39 \textcolor{comment}{//}
40 \textcolor{comment}{// Pass Progress Reporting}
41 \textcolor{comment}{// -----------------------------}
42 \textcolor{comment}{// It's sometimes helpful to see when each pass completes.}
43 \textcolor{comment}{//}
44 \textcolor{comment}{//}
45 \textcolor{comment}{// Clean-up}
46 \textcolor{comment}{// -----------------------------}
47 \textcolor{comment}{// Destruction of the encoder instance must be done on each pass. The}
48 \textcolor{comment}{// raw image should be destroyed at the end as usual.}
49 
50 \textcolor{preprocessor}{#include <stdio.h>}
51 \textcolor{preprocessor}{#include <stdlib.h>}
52 \textcolor{preprocessor}{#include <string.h>}
53 
54 \textcolor{preprocessor}{#include "\hyperlink{aom__encoder_8h}{aom/aom\_encoder.h}"}
55 \textcolor{preprocessor}{#include "common/tools\_common.h"}
56 \textcolor{preprocessor}{#include "common/video\_writer.h"}
57 
58 \textcolor{keyword}{static} \textcolor{keyword}{const} \textcolor{keywordtype}{char} *exec\_name;
59 
60 \textcolor{keywordtype}{void} usage\_exit(\textcolor{keywordtype}{void}) \{
61   fprintf(stderr,
62           \textcolor{stringliteral}{"Usage: %s <codec> <width> <height> <infile> <outfile> "}
63           \textcolor{stringliteral}{"<limit(optional)>\(\backslash\)n"},
64           exec\_name);
65   exit(EXIT\_FAILURE);
66 \}
67 
68 \textcolor{keyword}{static} \textcolor{keywordtype}{int} get\_frame\_stats(\hyperlink{structaom__codec__ctx}{aom\_codec\_ctx\_t} *ctx, \textcolor{keyword}{const} 
      \hyperlink{structaom__image}{aom\_image\_t} *img,
69                            \hyperlink{group__encoder_ga958524226c9a65251c9e4f7bb78fc606}{aom\_codec\_pts\_t} pts, \textcolor{keywordtype}{unsigned} \textcolor{keywordtype}{int} duration,
70                            \hyperlink{group__encoder_gacbef92200b831adb94283f84128f83de}{aom\_enc\_frame\_flags\_t} flags,
71                            \hyperlink{structaom__fixed__buf}{aom\_fixed\_buf\_t} *stats) \{
72   \textcolor{keywordtype}{int} got\_pkts = 0;
73   \hyperlink{group__codec_gadf9e173c9e02788a9999399edab20a02}{aom\_codec\_iter\_t} iter = NULL;
74   \textcolor{keyword}{const} \hyperlink{structaom__codec__cx__pkt}{aom\_codec\_cx\_pkt\_t} *pkt = NULL;
75   \textcolor{keyword}{const} \hyperlink{group__codec_gaaae61e0f8663e6137f1e228757248e7c}{aom\_codec\_err\_t} res = \hyperlink{group__encoder_ga6f4a777de5389771e783df7ff1f116d4}{aom\_codec\_encode}(ctx, img, pts, duration, 
      flags);
76   \textcolor{keywordflow}{if} (res != \hyperlink{group__codec_ggaaae61e0f8663e6137f1e228757248e7caf145dc2f86014a08ebad36ac2b140001}{AOM\_CODEC\_OK}) die\_codec(ctx, \textcolor{stringliteral}{"Failed to get frame stats."});
77 
78   \textcolor{keywordflow}{while} ((pkt = \hyperlink{group__encoder_gaedc4c56b60d4217677cb561066360884}{aom\_codec\_get\_cx\_data}(ctx, &iter)) != NULL) \{
79     got\_pkts = 1;
80 
81     \textcolor{keywordflow}{if} (pkt->\hyperlink{structaom__codec__cx__pkt_a11e586120c689ece9a7690e72ff384be}{kind} == \hyperlink{group__encoder_ggafeb69da4a9649a54e805f59c26d8dfeda7dcdcb6c401cac64ca98b51f52de8d4b}{AOM\_CODEC\_STATS\_PKT}) \{
82       \textcolor{keyword}{const} uint8\_t *\textcolor{keyword}{const} pkt\_buf = pkt->\hyperlink{structaom__codec__cx__pkt_afb379cd4bfa7692d1d6e85f4e4b2b410}{data}.\hyperlink{structaom__codec__cx__pkt_a40d469839bcd8195c3c8e80db6561dbb}{twopass\_stats}.
      \hyperlink{structaom__fixed__buf_ac1b22da152c9839329d3780208dffd38}{buf};
83       \textcolor{keyword}{const} \textcolor{keywordtype}{size\_t} pkt\_size = pkt->\hyperlink{structaom__codec__cx__pkt_afb379cd4bfa7692d1d6e85f4e4b2b410}{data}.\hyperlink{structaom__codec__cx__pkt_a40d469839bcd8195c3c8e80db6561dbb}{twopass\_stats}.\hyperlink{structaom__fixed__buf_a02f47e8b960c332c60a8aa4b7e37426f}{sz};
84       stats->\hyperlink{structaom__fixed__buf_ac1b22da152c9839329d3780208dffd38}{buf} = realloc(stats->\hyperlink{structaom__fixed__buf_ac1b22da152c9839329d3780208dffd38}{buf}, stats->\hyperlink{structaom__fixed__buf_a02f47e8b960c332c60a8aa4b7e37426f}{sz} + pkt\_size);
85       memcpy((uint8\_t *)stats->\hyperlink{structaom__fixed__buf_ac1b22da152c9839329d3780208dffd38}{buf} + stats->\hyperlink{structaom__fixed__buf_a02f47e8b960c332c60a8aa4b7e37426f}{sz}, pkt\_buf, pkt\_size);
86       stats->\hyperlink{structaom__fixed__buf_a02f47e8b960c332c60a8aa4b7e37426f}{sz} += pkt\_size;
87     \}
88   \}
89 
90   \textcolor{keywordflow}{return} got\_pkts;
91 \}
92 
93 \textcolor{keyword}{static} \textcolor{keywordtype}{int} encode\_frame(\hyperlink{structaom__codec__ctx}{aom\_codec\_ctx\_t} *ctx, \textcolor{keyword}{const} \hyperlink{structaom__image}{aom\_image\_t} *img,
94                         \hyperlink{group__encoder_ga958524226c9a65251c9e4f7bb78fc606}{aom\_codec\_pts\_t} pts, \textcolor{keywordtype}{unsigned} \textcolor{keywordtype}{int} duration,
95                         \hyperlink{group__encoder_gacbef92200b831adb94283f84128f83de}{aom\_enc\_frame\_flags\_t} flags, AvxVideoWriter *writer) \{
96   \textcolor{keywordtype}{int} got\_pkts = 0;
97   \hyperlink{group__codec_gadf9e173c9e02788a9999399edab20a02}{aom\_codec\_iter\_t} iter = NULL;
98   \textcolor{keyword}{const} \hyperlink{structaom__codec__cx__pkt}{aom\_codec\_cx\_pkt\_t} *pkt = NULL;
99   \textcolor{keyword}{const} \hyperlink{group__codec_gaaae61e0f8663e6137f1e228757248e7c}{aom\_codec\_err\_t} res = \hyperlink{group__encoder_ga6f4a777de5389771e783df7ff1f116d4}{aom\_codec\_encode}(ctx, img, pts, duration, 
      flags);
100   \textcolor{keywordflow}{if} (res != \hyperlink{group__codec_ggaaae61e0f8663e6137f1e228757248e7caf145dc2f86014a08ebad36ac2b140001}{AOM\_CODEC\_OK}) die\_codec(ctx, \textcolor{stringliteral}{"Failed to encode frame."});
101 
102   \textcolor{keywordflow}{while} ((pkt = \hyperlink{group__encoder_gaedc4c56b60d4217677cb561066360884}{aom\_codec\_get\_cx\_data}(ctx, &iter)) != NULL) \{
103     got\_pkts = 1;
104     \textcolor{keywordflow}{if} (pkt->\hyperlink{structaom__codec__cx__pkt_a11e586120c689ece9a7690e72ff384be}{kind} == \hyperlink{group__encoder_ggafeb69da4a9649a54e805f59c26d8dfeda793165d0f219812342f69d5fd9b2b9c8}{AOM\_CODEC\_CX\_FRAME\_PKT}) \{
105       \textcolor{keyword}{const} \textcolor{keywordtype}{int} keyframe = (pkt->\hyperlink{structaom__codec__cx__pkt_afb379cd4bfa7692d1d6e85f4e4b2b410}{data}.\hyperlink{structaom__codec__cx__pkt_a4180a6ae59b0d295bc915d4689df4cb0}{frame}.flags & \hyperlink{group__encoder_gaf4a58f123913a5eef0a3796f0619e5f3}{AOM\_FRAME\_IS\_KEY}) != 0;
106 
107       \textcolor{keywordflow}{if} (!aom\_video\_writer\_write\_frame(writer, pkt->\hyperlink{structaom__codec__cx__pkt_afb379cd4bfa7692d1d6e85f4e4b2b410}{data}.\hyperlink{structaom__codec__cx__pkt_a4180a6ae59b0d295bc915d4689df4cb0}{frame}.buf,
108                                         pkt->\hyperlink{structaom__codec__cx__pkt_afb379cd4bfa7692d1d6e85f4e4b2b410}{data}.\hyperlink{structaom__codec__cx__pkt_a4180a6ae59b0d295bc915d4689df4cb0}{frame}.sz,
109                                         pkt->\hyperlink{structaom__codec__cx__pkt_afb379cd4bfa7692d1d6e85f4e4b2b410}{data}.\hyperlink{structaom__codec__cx__pkt_a4180a6ae59b0d295bc915d4689df4cb0}{frame}.pts))
110         die\_codec(ctx, \textcolor{stringliteral}{"Failed to write compressed frame."});
111       printf(keyframe ? \textcolor{stringliteral}{"K"} : \textcolor{stringliteral}{"."});
112       fflush(stdout);
113     \}
114   \}
115 
116   \textcolor{keywordflow}{return} got\_pkts;
117 \}
118 
119 \textcolor{keyword}{static} \hyperlink{structaom__fixed__buf}{aom\_fixed\_buf\_t} pass0(\hyperlink{structaom__image}{aom\_image\_t} *raw, FILE *infile,
120                              \textcolor{keyword}{const} AvxInterface *encoder,
121                              \textcolor{keyword}{const} \hyperlink{structaom__codec__enc__cfg}{aom\_codec\_enc\_cfg\_t} *cfg, \textcolor{keywordtype}{int} limit) \{
122   \hyperlink{structaom__codec__ctx}{aom\_codec\_ctx\_t} codec;
123   \textcolor{keywordtype}{int} frame\_count = 0;
124   \hyperlink{structaom__fixed__buf}{aom\_fixed\_buf\_t} stats = \{ NULL, 0 \};
125 
126   \textcolor{keywordflow}{if} (\hyperlink{group__encoder_gaade68a7d33d30f97dc9a596aa5e065d8}{aom\_codec\_enc\_init}(&codec, encoder->codec\_interface(), cfg, 0))
127     die\_codec(&codec, \textcolor{stringliteral}{"Failed to initialize encoder"});
128 
129   \textcolor{comment}{// Calculate frame statistics.}
130   \textcolor{keywordflow}{while} (aom\_img\_read(raw, infile) && frame\_count < limit) \{
131     ++frame\_count;
132     get\_frame\_stats(&codec, raw, frame\_count, 1, 0, &stats);
133   \}
134 
135   \textcolor{comment}{// Flush encoder.}
136   \textcolor{keywordflow}{while} (get\_frame\_stats(&codec, NULL, frame\_count, 1, 0, &stats)) \{
137   \}
138 
139   printf(\textcolor{stringliteral}{"Pass 0 complete. Processed %d frames.\(\backslash\)n"}, frame\_count);
140   \textcolor{keywordflow}{if} (\hyperlink{group__codec_ga9b60e186f61ba2d6ab2b8069b76a15c5}{aom\_codec\_destroy}(&codec)) die\_codec(&codec, \textcolor{stringliteral}{"Failed to destroy codec."});
141 
142   \textcolor{keywordflow}{return} stats;
143 \}
144 
145 \textcolor{keyword}{static} \textcolor{keywordtype}{void} pass1(\hyperlink{structaom__image}{aom\_image\_t} *raw, FILE *infile, \textcolor{keyword}{const} \textcolor{keywordtype}{char} *outfile\_name,
146                   \textcolor{keyword}{const} AvxInterface *encoder, \textcolor{keyword}{const} \hyperlink{structaom__codec__enc__cfg}{aom\_codec\_enc\_cfg\_t} *cfg,
147                   \textcolor{keywordtype}{int} limit) \{
148   AvxVideoInfo info = \{ encoder->fourcc,
149                         cfg->\hyperlink{structaom__codec__enc__cfg_a80cb459c5ef3c7e1516f617c4c9d6eab}{g\_w},
150                         cfg->\hyperlink{structaom__codec__enc__cfg_a37b0f57b63bec8d133df8901d4407ee6}{g\_h},
151                         \{ cfg->\hyperlink{structaom__codec__enc__cfg_a10664f1fc5b6ec29b77ee13efeeecdf7}{g\_timebase}.\hyperlink{structaom__rational_a7b48174411798c780a15f132c4650839}{num}, cfg->\hyperlink{structaom__codec__enc__cfg_a10664f1fc5b6ec29b77ee13efeeecdf7}{g\_timebase}.
      \hyperlink{structaom__rational_adeddf2ea01c12b7be66536e0a0fb92c5}{den} \},
152                         0 \};
153   AvxVideoWriter *writer = NULL;
154   \hyperlink{structaom__codec__ctx}{aom\_codec\_ctx\_t} codec;
155   \textcolor{keywordtype}{int} frame\_count = 0;
156 
157   writer = aom\_video\_writer\_open(outfile\_name, kContainerIVF, &info);
158   \textcolor{keywordflow}{if} (!writer) die(\textcolor{stringliteral}{"Failed to open %s for writing"}, outfile\_name);
159 
160   \textcolor{keywordflow}{if} (\hyperlink{group__encoder_gaade68a7d33d30f97dc9a596aa5e065d8}{aom\_codec\_enc\_init}(&codec, encoder->codec\_interface(), cfg, 0))
161     die\_codec(&codec, \textcolor{stringliteral}{"Failed to initialize encoder"});
162 
163   \textcolor{comment}{// Encode frames.}
164   \textcolor{keywordflow}{while} (aom\_img\_read(raw, infile) && frame\_count < limit) \{
165     ++frame\_count;
166     encode\_frame(&codec, raw, frame\_count, 1, 0, writer);
167   \}
168 
169   \textcolor{comment}{// Flush encoder.}
170   \textcolor{keywordflow}{while} (encode\_frame(&codec, NULL, -1, 1, 0, writer)) \{
171   \}
172 
173   printf(\textcolor{stringliteral}{"\(\backslash\)n"});
174 
175   \textcolor{keywordflow}{if} (\hyperlink{group__codec_ga9b60e186f61ba2d6ab2b8069b76a15c5}{aom\_codec\_destroy}(&codec)) die\_codec(&codec, \textcolor{stringliteral}{"Failed to destroy codec."});
176 
177   aom\_video\_writer\_close(writer);
178 
179   printf(\textcolor{stringliteral}{"Pass 1 complete. Processed %d frames.\(\backslash\)n"}, frame\_count);
180 \}
181 
182 \textcolor{keywordtype}{int} main(\textcolor{keywordtype}{int} argc, \textcolor{keywordtype}{char} **argv) \{
183   FILE *infile = NULL;
184   \textcolor{keywordtype}{int} w, h;
185   \hyperlink{structaom__codec__ctx}{aom\_codec\_ctx\_t} codec;
186   \hyperlink{structaom__codec__enc__cfg}{aom\_codec\_enc\_cfg\_t} cfg;
187   \hyperlink{structaom__image}{aom\_image\_t} raw;
188   \hyperlink{group__codec_gaaae61e0f8663e6137f1e228757248e7c}{aom\_codec\_err\_t} res;
189   \hyperlink{structaom__fixed__buf}{aom\_fixed\_buf\_t} stats;
190 
191   \textcolor{keyword}{const} AvxInterface *encoder = NULL;
192   \textcolor{keyword}{const} \textcolor{keywordtype}{int} fps = 30;       \textcolor{comment}{// TODO(dkovalev) add command line argument}
193   \textcolor{keyword}{const} \textcolor{keywordtype}{int} bitrate = 200;  \textcolor{comment}{// kbit/s TODO(dkovalev) add command line argument}
194   \textcolor{keyword}{const} \textcolor{keywordtype}{char} *\textcolor{keyword}{const} codec\_arg = argv[1];
195   \textcolor{keyword}{const} \textcolor{keywordtype}{char} *\textcolor{keyword}{const} width\_arg = argv[2];
196   \textcolor{keyword}{const} \textcolor{keywordtype}{char} *\textcolor{keyword}{const} height\_arg = argv[3];
197   \textcolor{keyword}{const} \textcolor{keywordtype}{char} *\textcolor{keyword}{const} infile\_arg = argv[4];
198   \textcolor{keyword}{const} \textcolor{keywordtype}{char} *\textcolor{keyword}{const} outfile\_arg = argv[5];
199   \textcolor{keywordtype}{int} limit = 0;
200   exec\_name = argv[0];
201 
202   \textcolor{keywordflow}{if} (argc < 6) die(\textcolor{stringliteral}{"Invalid number of arguments"});
203 
204   \textcolor{keywordflow}{if} (argc > 6) limit = (int)strtol(argv[6], NULL, 0);
205 
206   \textcolor{keywordflow}{if} (limit == 0) limit = 100;
207 
208   encoder = get\_aom\_encoder\_by\_name(codec\_arg);
209   \textcolor{keywordflow}{if} (!encoder) die(\textcolor{stringliteral}{"Unsupported codec."});
210 
211   w = (int)strtol(width\_arg, NULL, 0);
212   h = (int)strtol(height\_arg, NULL, 0);
213 
214   \textcolor{keywordflow}{if} (w <= 0 || h <= 0 || (w % 2) != 0 || (h % 2) != 0)
215     die(\textcolor{stringliteral}{"Invalid frame size: %dx%d"}, w, h);
216 
217   \textcolor{keywordflow}{if} (!\hyperlink{aom__image_8h_a570db29fbd122951235a08fe9375f6bb}{aom\_img\_alloc}(&raw, \hyperlink{aom__image_8h_a930317c04b4bd0a660bb5e744055523cabd778a3d697463e89d12a1117f417b60}{AOM\_IMG\_FMT\_I420}, w, h, 1))
218     die(\textcolor{stringliteral}{"Failed to allocate image"}, w, h);
219 
220   printf(\textcolor{stringliteral}{"Using %s\(\backslash\)n"}, \hyperlink{group__codec_ga013b1f6d96b2cf9489396311a7e5179b}{aom\_codec\_iface\_name}(encoder->codec\_interface()));
221 
222   \textcolor{comment}{// Configuration}
223   res = \hyperlink{group__encoder_gabe456ab6f99bdebc47018779b75d2521}{aom\_codec\_enc\_config\_default}(encoder->codec\_interface(), &cfg, 0);
224   \textcolor{keywordflow}{if} (res) die\_codec(&codec, \textcolor{stringliteral}{"Failed to get default codec config."});
225 
226   cfg.\hyperlink{structaom__codec__enc__cfg_a80cb459c5ef3c7e1516f617c4c9d6eab}{g\_w} = w;
227   cfg.\hyperlink{structaom__codec__enc__cfg_a37b0f57b63bec8d133df8901d4407ee6}{g\_h} = h;
228   cfg.\hyperlink{structaom__codec__enc__cfg_a10664f1fc5b6ec29b77ee13efeeecdf7}{g\_timebase}.\hyperlink{structaom__rational_a7b48174411798c780a15f132c4650839}{num} = 1;
229   cfg.\hyperlink{structaom__codec__enc__cfg_a10664f1fc5b6ec29b77ee13efeeecdf7}{g\_timebase}.\hyperlink{structaom__rational_adeddf2ea01c12b7be66536e0a0fb92c5}{den} = fps;
230   cfg.\hyperlink{structaom__codec__enc__cfg_ab21539da477dba7506d90353c27d218b}{rc\_target\_bitrate} = bitrate;
231 
232   \textcolor{keywordflow}{if} (!(infile = fopen(infile\_arg, \textcolor{stringliteral}{"rb"})))
233     die(\textcolor{stringliteral}{"Failed to open %s for reading"}, infile\_arg);
234 
235   \textcolor{comment}{// Pass 0}
236   cfg.\hyperlink{structaom__codec__enc__cfg_aad58e4d10c7904d50ce959aef202dc64}{g\_pass} = \hyperlink{group__encoder_gga92b6709b58dc3435e3ba652da562eda1ad342b33a290482c20238bfde5d9bea1e}{AOM\_RC\_FIRST\_PASS};
237   stats = pass0(&raw, infile, encoder, &cfg, limit);
238 
239   \textcolor{comment}{// Pass 1}
240   rewind(infile);
241   cfg.\hyperlink{structaom__codec__enc__cfg_aad58e4d10c7904d50ce959aef202dc64}{g\_pass} = \hyperlink{group__encoder_gga92b6709b58dc3435e3ba652da562eda1a621c3f07937527618dc06e962425f6cc}{AOM\_RC\_LAST\_PASS};
242   cfg.\hyperlink{structaom__codec__enc__cfg_ad5c6f5c96ec54cabc71edb01045a1f04}{rc\_twopass\_stats\_in} = stats;
243   pass1(&raw, infile, outfile\_arg, encoder, &cfg, limit);
244   free(stats.\hyperlink{structaom__fixed__buf_ac1b22da152c9839329d3780208dffd38}{buf});
245 
246   \hyperlink{aom__image_8h_afff22f7f3eb9409c5b678d1962f110a8}{aom\_img\_free}(&raw);
247   fclose(infile);
248 
249   \textcolor{keywordflow}{return} EXIT\_SUCCESS;
250 \}
\end{DoxyCodeInclude}
 \hypertarget{example_scalable_encoder}{}\subsection{scalable\+\_\+encoder}\label{example_scalable_encoder}

\begin{DoxyCodeInclude}
1 \textcolor{comment}{/*}
2 \textcolor{comment}{ * Copyright (c) 2018, Alliance for Open Media. All rights reserved}
3 \textcolor{comment}{ *}
4 \textcolor{comment}{ * This source code is subject to the terms of the BSD 2 Clause License and}
5 \textcolor{comment}{ * the Alliance for Open Media Patent License 1.0. If the BSD 2 Clause License}
6 \textcolor{comment}{ * was not distributed with this source code in the LICENSE file, you can}
7 \textcolor{comment}{ * obtain it at www.aomedia.org/license/software. If the Alliance for Open}
8 \textcolor{comment}{ * Media Patent License 1.0 was not distributed with this source code in the}
9 \textcolor{comment}{ * PATENTS file, you can obtain it at www.aomedia.org/license/patent.}
10 \textcolor{comment}{ */}
11 
12 \textcolor{comment}{// Scalable Encoder}
13 \textcolor{comment}{// ==============}
14 \textcolor{comment}{//}
15 \textcolor{comment}{// This is an example of a scalable encoder loop. It takes two input files in}
16 \textcolor{comment}{// YV12 format, passes it through the encoder, and writes the compressed}
17 \textcolor{comment}{// frames to disk in OBU format.}
18 \textcolor{comment}{//}
19 \textcolor{comment}{// Getting The Default Configuration}
20 \textcolor{comment}{// ---------------------------------}
21 \textcolor{comment}{// Encoders have the notion of "usage profiles." For example, an encoder}
22 \textcolor{comment}{// may want to publish default configurations for both a video}
23 \textcolor{comment}{// conferencing application and a best quality offline encoder. These}
24 \textcolor{comment}{// obviously have very different default settings. Consult the}
25 \textcolor{comment}{// documentation for your codec to see if it provides any default}
26 \textcolor{comment}{// configurations. All codecs provide a default configuration, number 0,}
27 \textcolor{comment}{// which is valid for material in the vacinity of QCIF/QVGA.}
28 \textcolor{comment}{//}
29 \textcolor{comment}{// Updating The Configuration}
30 \textcolor{comment}{// ---------------------------------}
31 \textcolor{comment}{// Almost all applications will want to update the default configuration}
32 \textcolor{comment}{// with settings specific to their usage. Here we set the width and height}
33 \textcolor{comment}{// of the video file to that specified on the command line. We also scale}
34 \textcolor{comment}{// the default bitrate based on the ratio between the default resolution}
35 \textcolor{comment}{// and the resolution specified on the command line.}
36 \textcolor{comment}{//}
37 \textcolor{comment}{// Encoding A Frame}
38 \textcolor{comment}{// ----------------}
39 \textcolor{comment}{// The frame is read as a continuous block (size = width * height * 3 / 2)}
40 \textcolor{comment}{// from the input file. If a frame was read (the input file has not hit}
41 \textcolor{comment}{// EOF) then the frame is passed to the encoder. Otherwise, a NULL}
42 \textcolor{comment}{// is passed, indicating the End-Of-Stream condition to the encoder. The}
43 \textcolor{comment}{// `frame\_cnt` is reused as the presentation time stamp (PTS) and each}
44 \textcolor{comment}{// frame is shown for one frame-time in duration. The flags parameter is}
45 \textcolor{comment}{// unused in this example.}
46 
47 \textcolor{comment}{// Forced Keyframes}
48 \textcolor{comment}{// ----------------}
49 \textcolor{comment}{// Keyframes can be forced by setting the AOM\_EFLAG\_FORCE\_KF bit of the}
50 \textcolor{comment}{// flags passed to `aom\_codec\_control()`. In this example, we force a}
51 \textcolor{comment}{// keyframe every <keyframe-interval> frames. Note, the output stream can}
52 \textcolor{comment}{// contain additional keyframes beyond those that have been forced using the}
53 \textcolor{comment}{// AOM\_EFLAG\_FORCE\_KF flag because of automatic keyframe placement by the}
54 \textcolor{comment}{// encoder.}
55 \textcolor{comment}{//}
56 \textcolor{comment}{// Processing The Encoded Data}
57 \textcolor{comment}{// ---------------------------}
58 \textcolor{comment}{// Each packet of type `AOM\_CODEC\_CX\_FRAME\_PKT` contains the encoded data}
59 \textcolor{comment}{// for this frame. We write a IVF frame header, followed by the raw data.}
60 \textcolor{comment}{//}
61 \textcolor{comment}{// Cleanup}
62 \textcolor{comment}{// -------}
63 \textcolor{comment}{// The `aom\_codec\_destroy` call frees any memory allocated by the codec.}
64 \textcolor{comment}{//}
65 \textcolor{comment}{// Error Handling}
66 \textcolor{comment}{// --------------}
67 \textcolor{comment}{// This example does not special case any error return codes. If there was}
68 \textcolor{comment}{// an error, a descriptive message is printed and the program exits. With}
69 \textcolor{comment}{// few exeptions, aom\_codec functions return an enumerated error status,}
70 \textcolor{comment}{// with the value `0` indicating success.}
71 
72 \textcolor{preprocessor}{#include <stdio.h>}
73 \textcolor{preprocessor}{#include <stdlib.h>}
74 \textcolor{preprocessor}{#include <string.h>}
75 
76 \textcolor{preprocessor}{#include "\hyperlink{aom__encoder_8h}{aom/aom\_encoder.h}"}
77 \textcolor{preprocessor}{#include "\hyperlink{aomcx_8h}{aom/aomcx.h}"}
78 \textcolor{preprocessor}{#include "av1/common/enums.h"}
79 \textcolor{preprocessor}{#include "common/tools\_common.h"}
80 \textcolor{preprocessor}{#include "common/video\_writer.h"}
81 
82 \textcolor{keyword}{static} \textcolor{keyword}{const} \textcolor{keywordtype}{char} *exec\_name;
83 
84 \textcolor{keywordtype}{void} usage\_exit(\textcolor{keywordtype}{void}) \{
85   fprintf(stderr,
86           \textcolor{stringliteral}{"Usage: %s <codec> <width> <height> <infile0> <infile1> "}
87           \textcolor{stringliteral}{"<outfile> <frames to encode>\(\backslash\)n"}
88           \textcolor{stringliteral}{"See comments in scalable\_encoder.c for more information.\(\backslash\)n"},
89           exec\_name);
90   exit(EXIT\_FAILURE);
91 \}
92 
93 \textcolor{keyword}{static} \textcolor{keywordtype}{int} encode\_frame(\hyperlink{structaom__codec__ctx}{aom\_codec\_ctx\_t} *codec, \hyperlink{structaom__image}{aom\_image\_t} *img,
94                         \textcolor{keywordtype}{int} frame\_index, \textcolor{keywordtype}{int} flags, FILE *outfile) \{
95   \textcolor{keywordtype}{int} got\_pkts = 0;
96   \hyperlink{group__codec_gadf9e173c9e02788a9999399edab20a02}{aom\_codec\_iter\_t} iter = NULL;
97   \textcolor{keyword}{const} \hyperlink{structaom__codec__cx__pkt}{aom\_codec\_cx\_pkt\_t} *pkt = NULL;
98   \textcolor{keyword}{const} \hyperlink{group__codec_gaaae61e0f8663e6137f1e228757248e7c}{aom\_codec\_err\_t} res =
99       \hyperlink{group__encoder_ga6f4a777de5389771e783df7ff1f116d4}{aom\_codec\_encode}(codec, img, frame\_index, 1, flags);
100   \textcolor{keywordflow}{if} (res != \hyperlink{group__codec_ggaaae61e0f8663e6137f1e228757248e7caf145dc2f86014a08ebad36ac2b140001}{AOM\_CODEC\_OK}) die\_codec(codec, \textcolor{stringliteral}{"Failed to encode frame"});
101 
102   \textcolor{keywordflow}{while} ((pkt = \hyperlink{group__encoder_gaedc4c56b60d4217677cb561066360884}{aom\_codec\_get\_cx\_data}(codec, &iter)) != NULL) \{
103     got\_pkts = 1;
104 
105     \textcolor{keywordflow}{if} (pkt->\hyperlink{structaom__codec__cx__pkt_a11e586120c689ece9a7690e72ff384be}{kind} == \hyperlink{group__encoder_ggafeb69da4a9649a54e805f59c26d8dfeda793165d0f219812342f69d5fd9b2b9c8}{AOM\_CODEC\_CX\_FRAME\_PKT}) \{
106       \textcolor{keyword}{const} \textcolor{keywordtype}{int} keyframe = (pkt->\hyperlink{structaom__codec__cx__pkt_afb379cd4bfa7692d1d6e85f4e4b2b410}{data}.\hyperlink{structaom__codec__cx__pkt_a4180a6ae59b0d295bc915d4689df4cb0}{frame}.flags & \hyperlink{group__encoder_gaf4a58f123913a5eef0a3796f0619e5f3}{AOM\_FRAME\_IS\_KEY}) != 0;
107       \textcolor{keywordflow}{if} (fwrite(pkt->\hyperlink{structaom__codec__cx__pkt_afb379cd4bfa7692d1d6e85f4e4b2b410}{data}.\hyperlink{structaom__codec__cx__pkt_a4180a6ae59b0d295bc915d4689df4cb0}{frame}.buf, 1, pkt->\hyperlink{structaom__codec__cx__pkt_afb379cd4bfa7692d1d6e85f4e4b2b410}{data}.\hyperlink{structaom__codec__cx__pkt_a4180a6ae59b0d295bc915d4689df4cb0}{frame}.sz, outfile) !=
108           pkt->\hyperlink{structaom__codec__cx__pkt_afb379cd4bfa7692d1d6e85f4e4b2b410}{data}.\hyperlink{structaom__codec__cx__pkt_a4180a6ae59b0d295bc915d4689df4cb0}{frame}.sz) \{
109         die\_codec(codec, \textcolor{stringliteral}{"Failed to write compressed frame"});
110       \}
111       printf(keyframe ? \textcolor{stringliteral}{"K"} : \textcolor{stringliteral}{"."});
112       printf(\textcolor{stringliteral}{" %6d\(\backslash\)n"}, (\textcolor{keywordtype}{int})pkt->\hyperlink{structaom__codec__cx__pkt_afb379cd4bfa7692d1d6e85f4e4b2b410}{data}.\hyperlink{structaom__codec__cx__pkt_a4180a6ae59b0d295bc915d4689df4cb0}{frame}.sz);
113       fflush(stdout);
114     \}
115   \}
116 
117   \textcolor{keywordflow}{return} got\_pkts;
118 \}
119 
120 \textcolor{keywordtype}{int} main(\textcolor{keywordtype}{int} argc, \textcolor{keywordtype}{char} **argv) \{
121   FILE *infile0 = NULL;
122   FILE *infile1 = NULL;
123   \hyperlink{structaom__codec__ctx}{aom\_codec\_ctx\_t} codec;
124   \hyperlink{structaom__codec__enc__cfg}{aom\_codec\_enc\_cfg\_t} cfg;
125   \textcolor{keywordtype}{int} frame\_count = 0;
126   \hyperlink{structaom__image}{aom\_image\_t} raw0, raw1;
127   \hyperlink{group__codec_gaaae61e0f8663e6137f1e228757248e7c}{aom\_codec\_err\_t} res;
128   AvxVideoInfo info;
129   \textcolor{keyword}{const} AvxInterface *encoder = NULL;
130   \textcolor{keyword}{const} \textcolor{keywordtype}{int} fps = 30;
131   \textcolor{keyword}{const} \textcolor{keywordtype}{int} bitrate = 200;
132   \textcolor{keywordtype}{int} keyframe\_interval = 0;
133   \textcolor{keywordtype}{int} max\_frames = 0;
134   \textcolor{keywordtype}{int} frames\_encoded = 0;
135   \textcolor{keyword}{const} \textcolor{keywordtype}{char} *codec\_arg = NULL;
136   \textcolor{keyword}{const} \textcolor{keywordtype}{char} *width\_arg = NULL;
137   \textcolor{keyword}{const} \textcolor{keywordtype}{char} *height\_arg = NULL;
138   \textcolor{keyword}{const} \textcolor{keywordtype}{char} *infile0\_arg = NULL;
139   \textcolor{keyword}{const} \textcolor{keywordtype}{char} *infile1\_arg = NULL;
140   \textcolor{keyword}{const} \textcolor{keywordtype}{char} *outfile\_arg = NULL;
141   \textcolor{comment}{//  const char *keyframe\_interval\_arg = NULL;}
142   FILE *outfile = NULL;
143 
144   exec\_name = argv[0];
145 
146   \textcolor{comment}{// Clear explicitly, as simply assigning "\{ 0 \}" generates}
147   \textcolor{comment}{// "missing-field-initializers" warning in some compilers.}
148   memset(&info, 0, \textcolor{keyword}{sizeof}(info));
149 
150   \textcolor{keywordflow}{if} (argc != 8) die(\textcolor{stringliteral}{"Invalid number of arguments"});
151 
152   codec\_arg = argv[1];
153   width\_arg = argv[2];
154   height\_arg = argv[3];
155   infile0\_arg = argv[4];
156   infile1\_arg = argv[5];
157   outfile\_arg = argv[6];
158   max\_frames = (int)strtol(argv[7], NULL, 0);
159 
160   encoder = get\_aom\_encoder\_by\_name(codec\_arg);
161   \textcolor{keywordflow}{if} (!encoder) die(\textcolor{stringliteral}{"Unsupported codec."});
162 
163   info.codec\_fourcc = encoder->fourcc;
164   info.frame\_width = (int)strtol(width\_arg, NULL, 0);
165   info.frame\_height = (int)strtol(height\_arg, NULL, 0);
166   info.time\_base.numerator = 1;
167   info.time\_base.denominator = fps;
168 
169   \textcolor{keywordflow}{if} (info.frame\_width <= 0 || info.frame\_height <= 0 ||
170       (info.frame\_width % 2) != 0 || (info.frame\_height % 2) != 0) \{
171     die(\textcolor{stringliteral}{"Invalid frame size: %dx%d"}, info.frame\_width, info.frame\_height);
172   \}
173 
174   \textcolor{keywordflow}{if} (!\hyperlink{aom__image_8h_a570db29fbd122951235a08fe9375f6bb}{aom\_img\_alloc}(&raw0, \hyperlink{aom__image_8h_a930317c04b4bd0a660bb5e744055523cabd778a3d697463e89d12a1117f417b60}{AOM\_IMG\_FMT\_I420}, info.frame\_width,
175                      info.frame\_height, 1)) \{
176     die(\textcolor{stringliteral}{"Failed to allocate image for layer 0."});
177   \}
178   \textcolor{keywordflow}{if} (!\hyperlink{aom__image_8h_a570db29fbd122951235a08fe9375f6bb}{aom\_img\_alloc}(&raw1, \hyperlink{aom__image_8h_a930317c04b4bd0a660bb5e744055523cabd778a3d697463e89d12a1117f417b60}{AOM\_IMG\_FMT\_I420}, info.frame\_width,
179                      info.frame\_height, 1)) \{
180     die(\textcolor{stringliteral}{"Failed to allocate image for layer 1."});
181   \}
182 
183   \textcolor{comment}{//  keyframe\_interval = (int)strtol(keyframe\_interval\_arg, NULL, 0);}
184   keyframe\_interval = 100;
185   \textcolor{keywordflow}{if} (keyframe\_interval < 0) die(\textcolor{stringliteral}{"Invalid keyframe interval value."});
186 
187   printf(\textcolor{stringliteral}{"Using %s\(\backslash\)n"}, \hyperlink{group__codec_ga013b1f6d96b2cf9489396311a7e5179b}{aom\_codec\_iface\_name}(encoder->codec\_interface()));
188 
189   res = \hyperlink{group__encoder_gabe456ab6f99bdebc47018779b75d2521}{aom\_codec\_enc\_config\_default}(encoder->codec\_interface(), &cfg, 0);
190   \textcolor{keywordflow}{if} (res) die\_codec(&codec, \textcolor{stringliteral}{"Failed to get default codec config."});
191 
192   cfg.\hyperlink{structaom__codec__enc__cfg_a80cb459c5ef3c7e1516f617c4c9d6eab}{g\_w} = info.frame\_width;
193   cfg.\hyperlink{structaom__codec__enc__cfg_a37b0f57b63bec8d133df8901d4407ee6}{g\_h} = info.frame\_height;
194   cfg.\hyperlink{structaom__codec__enc__cfg_a10664f1fc5b6ec29b77ee13efeeecdf7}{g\_timebase}.\hyperlink{structaom__rational_a7b48174411798c780a15f132c4650839}{num} = info.time\_base.numerator;
195   cfg.\hyperlink{structaom__codec__enc__cfg_a10664f1fc5b6ec29b77ee13efeeecdf7}{g\_timebase}.\hyperlink{structaom__rational_adeddf2ea01c12b7be66536e0a0fb92c5}{den} = info.time\_base.denominator;
196   cfg.\hyperlink{structaom__codec__enc__cfg_ab21539da477dba7506d90353c27d218b}{rc\_target\_bitrate} = bitrate;
197   cfg.\hyperlink{structaom__codec__enc__cfg_a8f3763485bb1f6eea6466b2fe0da2304}{g\_error\_resilient} = 0;
198   cfg.\hyperlink{structaom__codec__enc__cfg_a614a49318f2011cc8735d7e51b910fa4}{g\_lag\_in\_frames} = 0;
199   cfg.\hyperlink{structaom__codec__enc__cfg_a3fd74d888658039d09bc4eacf163a495}{rc\_end\_usage} = \hyperlink{group__encoder_gga7c084d3ecef569aad166ce70b0e8a957aff3bbd4fe870b4b946c2093e59eb14e5}{AOM\_Q};
200   cfg.\hyperlink{structaom__codec__enc__cfg_adb3fe41c1ce39579a49b97bc2ca7b2f2}{save\_as\_annexb} = 0;
201 
202   outfile = fopen(outfile\_arg, \textcolor{stringliteral}{"wb"});
203   \textcolor{keywordflow}{if} (!outfile) die(\textcolor{stringliteral}{"Failed to open %s for writing."}, outfile\_arg);
204 
205   \textcolor{keywordflow}{if} (!(infile0 = fopen(infile0\_arg, \textcolor{stringliteral}{"rb"})))
206     die(\textcolor{stringliteral}{"Failed to open %s for reading."}, infile0\_arg);
207   \textcolor{keywordflow}{if} (!(infile1 = fopen(infile1\_arg, \textcolor{stringliteral}{"rb"})))
208     die(\textcolor{stringliteral}{"Failed to open %s for reading."}, infile0\_arg);
209 
210   \textcolor{keywordflow}{if} (\hyperlink{group__encoder_gaade68a7d33d30f97dc9a596aa5e065d8}{aom\_codec\_enc\_init}(&codec, encoder->codec\_interface(), &cfg, 0))
211     die\_codec(&codec, \textcolor{stringliteral}{"Failed to initialize encoder"});
212   \textcolor{keywordflow}{if} (\hyperlink{group__codec_ga6da974f4eeaba1fa74106b28d0fe6ac5}{aom\_codec\_control}(&codec, \hyperlink{group__aom__encoder_ggae78dde67a6d78f332e9bdba0dde42db5adac09e1a8da079b08fca5ccbf981f1a6}{AOME\_SET\_CPUUSED}, 8))
213     die\_codec(&codec, \textcolor{stringliteral}{"Failed to set cpu to 8"});
214 
215   \textcolor{keywordflow}{if} (\hyperlink{group__codec_ga6da974f4eeaba1fa74106b28d0fe6ac5}{aom\_codec\_control}(&codec, \hyperlink{group__aom__encoder_ggae78dde67a6d78f332e9bdba0dde42db5acf4ab1ff2fa8d76a78881ad7f1a1294d}{AV1E\_SET\_TILE\_COLUMNS}, 2))
216     die\_codec(&codec, \textcolor{stringliteral}{"Failed to set tile columns to 2"});
217   \textcolor{keywordflow}{if} (\hyperlink{group__codec_ga6da974f4eeaba1fa74106b28d0fe6ac5}{aom\_codec\_control}(&codec, \hyperlink{group__aom__encoder_ggae78dde67a6d78f332e9bdba0dde42db5a9ac0044ad63e6848a482db04f0858c44}{AV1E\_SET\_NUM\_TG}, 3))
218     die\_codec(&codec, \textcolor{stringliteral}{"Failed to set num of tile groups to 3"});
219 
220   \textcolor{keywordflow}{if} (\hyperlink{group__codec_ga6da974f4eeaba1fa74106b28d0fe6ac5}{aom\_codec\_control}(&codec, \hyperlink{group__aom__encoder_ggae78dde67a6d78f332e9bdba0dde42db5aef4facbd3745aa7f2a604faaf68316ff}{AOME\_SET\_NUMBER\_SPATIAL\_LAYERS}
      , 2))
221     die\_codec(&codec, \textcolor{stringliteral}{"Failed to set number of spatial layers to 2"});
222 
223   \textcolor{comment}{// Encode frames.}
224   \textcolor{keywordflow}{while} (aom\_img\_read(&raw0, infile0)) \{
225     \textcolor{keywordtype}{int} flags = 0;
226 
227     \textcolor{comment}{// configure and encode base layer}
228 
229     \textcolor{keywordflow}{if} (keyframe\_interval > 0 && frames\_encoded % keyframe\_interval == 0)
230       flags |= \hyperlink{group__encoder_ga86a6a9053205149cccc98481b5460337}{AOM\_EFLAG\_FORCE\_KF};
231     \textcolor{keywordflow}{else}
232       \textcolor{comment}{// use previous base layer (LAST) as sole reference}
233       \textcolor{comment}{// save this frame as LAST to be used as reference by enhanmcent layer}
234       \textcolor{comment}{// and next base layer}
235       flags |= \hyperlink{group__aom__encoder_ga50c2560ca6670298cfc614ecae96a391}{AOM\_EFLAG\_NO\_REF\_LAST2} | 
      \hyperlink{group__aom__encoder_gaa4bc8ae2b977b73f0ef57ba428ca1d2c}{AOM\_EFLAG\_NO\_REF\_LAST3} |
236                \hyperlink{group__aom__encoder_gaaef6fe76991abf87edd2f296eee999f8}{AOM\_EFLAG\_NO\_REF\_GF} | \hyperlink{group__aom__encoder_ga9e2f989737d63ddf4e987a525d186a46}{AOM\_EFLAG\_NO\_REF\_ARF} |
237                \hyperlink{group__aom__encoder_ga758649aa6cd9fefb15ad888489884a38}{AOM\_EFLAG\_NO\_REF\_BWD} | \hyperlink{group__aom__encoder_gad04799a74215e1b9609f7ccd1766f8c9}{AOM\_EFLAG\_NO\_REF\_ARF2} |
238                \hyperlink{group__aom__encoder_gaa81cc31f95fd463f51a158050d267a36}{AOM\_EFLAG\_NO\_UPD\_GF} | \hyperlink{group__aom__encoder_ga469b4cf5ff76cb30de951e129c25a786}{AOM\_EFLAG\_NO\_UPD\_ARF} |
239                \hyperlink{group__aom__encoder_gac5a69f04b0bc88f755587a1da815d754}{AOM\_EFLAG\_NO\_UPD\_ENTROPY};
240     cfg.\hyperlink{structaom__codec__enc__cfg_a80cb459c5ef3c7e1516f617c4c9d6eab}{g\_w} = info.frame\_width;
241     cfg.\hyperlink{structaom__codec__enc__cfg_a37b0f57b63bec8d133df8901d4407ee6}{g\_h} = info.frame\_height;
242     \textcolor{keywordflow}{if} (\hyperlink{group__encoder_gaf4a4c3c3c91dd92c960990f6e534271d}{aom\_codec\_enc\_config\_set}(&codec, &cfg))
243       die\_codec(&codec, \textcolor{stringliteral}{"Failed to set enc cfg for layer 0"});
244     \textcolor{keywordflow}{if} (\hyperlink{group__codec_ga6da974f4eeaba1fa74106b28d0fe6ac5}{aom\_codec\_control}(&codec, \hyperlink{group__aom__encoder_ggae78dde67a6d78f332e9bdba0dde42db5aac7fbd0de7295387d7821f1889c47790}{AOME\_SET\_SPATIAL\_LAYER\_ID}, 0))
245       die\_codec(&codec, \textcolor{stringliteral}{"Failed to set layer id to 0"});
246     \textcolor{keywordflow}{if} (\hyperlink{group__codec_ga6da974f4eeaba1fa74106b28d0fe6ac5}{aom\_codec\_control}(&codec, \hyperlink{group__aom__encoder_ggae78dde67a6d78f332e9bdba0dde42db5af67f265bf63bf8f1268b3a14ae26606c}{AOME\_SET\_CQ\_LEVEL}, 62))
247       die\_codec(&codec, \textcolor{stringliteral}{"Failed to set cq level"});
248     encode\_frame(&codec, &raw0, frame\_count++, flags, outfile);
249 
250     \textcolor{comment}{// configure and encode enhancement layer}
251 
252     \textcolor{comment}{//  use LAST (base layer) as sole reference}
253     flags = \hyperlink{group__aom__encoder_ga50c2560ca6670298cfc614ecae96a391}{AOM\_EFLAG\_NO\_REF\_LAST2} | 
      \hyperlink{group__aom__encoder_gaa4bc8ae2b977b73f0ef57ba428ca1d2c}{AOM\_EFLAG\_NO\_REF\_LAST3} |
254             \hyperlink{group__aom__encoder_gaaef6fe76991abf87edd2f296eee999f8}{AOM\_EFLAG\_NO\_REF\_GF} | \hyperlink{group__aom__encoder_ga9e2f989737d63ddf4e987a525d186a46}{AOM\_EFLAG\_NO\_REF\_ARF} | 
      \hyperlink{group__aom__encoder_ga758649aa6cd9fefb15ad888489884a38}{AOM\_EFLAG\_NO\_REF\_BWD} |
255             \hyperlink{group__aom__encoder_gad04799a74215e1b9609f7ccd1766f8c9}{AOM\_EFLAG\_NO\_REF\_ARF2} | \hyperlink{group__aom__encoder_ga7a55a46970c074b761319c5c46d87b6e}{AOM\_EFLAG\_NO\_UPD\_LAST} |
256             \hyperlink{group__aom__encoder_gaa81cc31f95fd463f51a158050d267a36}{AOM\_EFLAG\_NO\_UPD\_GF} | \hyperlink{group__aom__encoder_ga469b4cf5ff76cb30de951e129c25a786}{AOM\_EFLAG\_NO\_UPD\_ARF} |
257             \hyperlink{group__aom__encoder_gac5a69f04b0bc88f755587a1da815d754}{AOM\_EFLAG\_NO\_UPD\_ENTROPY};
258     cfg.\hyperlink{structaom__codec__enc__cfg_a80cb459c5ef3c7e1516f617c4c9d6eab}{g\_w} = info.frame\_width;
259     cfg.\hyperlink{structaom__codec__enc__cfg_a37b0f57b63bec8d133df8901d4407ee6}{g\_h} = info.frame\_height;
260     aom\_img\_read(&raw1, infile1);
261     \textcolor{keywordflow}{if} (\hyperlink{group__encoder_gaf4a4c3c3c91dd92c960990f6e534271d}{aom\_codec\_enc\_config\_set}(&codec, &cfg))
262       die\_codec(&codec, \textcolor{stringliteral}{"Failed to set enc cfg for layer 1"});
263     \textcolor{keywordflow}{if} (\hyperlink{group__codec_ga6da974f4eeaba1fa74106b28d0fe6ac5}{aom\_codec\_control}(&codec, \hyperlink{group__aom__encoder_ggae78dde67a6d78f332e9bdba0dde42db5aac7fbd0de7295387d7821f1889c47790}{AOME\_SET\_SPATIAL\_LAYER\_ID}, 1))
264       die\_codec(&codec, \textcolor{stringliteral}{"Failed to set layer id to 1"});
265     \textcolor{keywordflow}{if} (\hyperlink{group__codec_ga6da974f4eeaba1fa74106b28d0fe6ac5}{aom\_codec\_control}(&codec, \hyperlink{group__aom__encoder_ggae78dde67a6d78f332e9bdba0dde42db5af67f265bf63bf8f1268b3a14ae26606c}{AOME\_SET\_CQ\_LEVEL}, 10))
266       die\_codec(&codec, \textcolor{stringliteral}{"Failed to set cq level"});
267     encode\_frame(&codec, &raw1, frame\_count++, flags, outfile);
268 
269     frames\_encoded++;
270 
271     \textcolor{keywordflow}{if} (max\_frames > 0 && frames\_encoded >= max\_frames) \textcolor{keywordflow}{break};
272   \}
273 
274   \textcolor{comment}{// Flush encoder.}
275   \textcolor{keywordflow}{while} (encode\_frame(&codec, NULL, -1, 0, outfile)) \textcolor{keywordflow}{continue};
276 
277   printf(\textcolor{stringliteral}{"\(\backslash\)n"});
278   fclose(infile0);
279   fclose(infile1);
280   printf(\textcolor{stringliteral}{"Processed %d frames.\(\backslash\)n"}, frame\_count / 2);
281 
282   \hyperlink{aom__image_8h_afff22f7f3eb9409c5b678d1962f110a8}{aom\_img\_free}(&raw0);
283   \hyperlink{aom__image_8h_afff22f7f3eb9409c5b678d1962f110a8}{aom\_img\_free}(&raw1);
284   \textcolor{keywordflow}{if} (\hyperlink{group__codec_ga9b60e186f61ba2d6ab2b8069b76a15c5}{aom\_codec\_destroy}(&codec)) die\_codec(&codec, \textcolor{stringliteral}{"Failed to destroy codec."});
285 
286   fclose(outfile);
287 
288   \textcolor{keywordflow}{return} EXIT\_SUCCESS;
289 \}
\end{DoxyCodeInclude}
 \hypertarget{example_aom_cx_set_ref}{}\subsection{aom\+\_\+cx\+\_\+set\+\_\+ref}\label{example_aom_cx_set_ref}

\begin{DoxyCodeInclude}
1 \textcolor{comment}{/*}
2 \textcolor{comment}{ * Copyright (c) 2016, Alliance for Open Media. All rights reserved}
3 \textcolor{comment}{ *}
4 \textcolor{comment}{ * This source code is subject to the terms of the BSD 2 Clause License and}
5 \textcolor{comment}{ * the Alliance for Open Media Patent License 1.0. If the BSD 2 Clause License}
6 \textcolor{comment}{ * was not distributed with this source code in the LICENSE file, you can}
7 \textcolor{comment}{ * obtain it at www.aomedia.org/license/software. If the Alliance for Open}
8 \textcolor{comment}{ * Media Patent License 1.0 was not distributed with this source code in the}
9 \textcolor{comment}{ * PATENTS file, you can obtain it at www.aomedia.org/license/patent.}
10 \textcolor{comment}{ */}
11 
12 \textcolor{comment}{// AV1 Set Reference Frame}
13 \textcolor{comment}{// ============================}
14 \textcolor{comment}{//}
15 \textcolor{comment}{// This is an example demonstrating how to overwrite the AV1 encoder's}
16 \textcolor{comment}{// internal reference frame. In the sample we set the last frame to the}
17 \textcolor{comment}{// current frame. This technique could be used to bounce between two cameras.}
18 \textcolor{comment}{//}
19 \textcolor{comment}{// The decoder would also have to set the reference frame to the same value}
20 \textcolor{comment}{// on the same frame, or the video will become corrupt. The 'test\_decode'}
21 \textcolor{comment}{// variable is set to 1 in this example that tests if the encoder and decoder}
22 \textcolor{comment}{// results are matching.}
23 \textcolor{comment}{//}
24 \textcolor{comment}{// Usage}
25 \textcolor{comment}{// -----}
26 \textcolor{comment}{// This example encodes a raw video. And the last argument passed in specifies}
27 \textcolor{comment}{// the frame number to update the reference frame on. For example, run}
28 \textcolor{comment}{// examples/aom\_cx\_set\_ref av1 352 288 in.yuv out.ivf 4 30}
29 \textcolor{comment}{// The parameter is parsed as follows:}
30 \textcolor{comment}{//}
31 \textcolor{comment}{//}
32 \textcolor{comment}{// Extra Variables}
33 \textcolor{comment}{// ---------------}
34 \textcolor{comment}{// This example maintains the frame number passed on the command line}
35 \textcolor{comment}{// in the `update\_frame\_num` variable.}
36 \textcolor{comment}{//}
37 \textcolor{comment}{//}
38 \textcolor{comment}{// Configuration}
39 \textcolor{comment}{// -------------}
40 \textcolor{comment}{//}
41 \textcolor{comment}{// The reference frame is updated on the frame specified on the command}
42 \textcolor{comment}{// line.}
43 \textcolor{comment}{//}
44 \textcolor{comment}{// Observing The Effects}
45 \textcolor{comment}{// ---------------------}
46 \textcolor{comment}{// The encoder and decoder results should be matching when the same reference}
47 \textcolor{comment}{// frame setting operation is done in both encoder and decoder. Otherwise,}
48 \textcolor{comment}{// the encoder/decoder mismatch would be seen.}
49 
50 \textcolor{preprocessor}{#include <stdio.h>}
51 \textcolor{preprocessor}{#include <stdlib.h>}
52 \textcolor{preprocessor}{#include <string.h>}
53 
54 \textcolor{preprocessor}{#include "\hyperlink{aom__decoder_8h}{aom/aom\_decoder.h}"}
55 \textcolor{preprocessor}{#include "\hyperlink{aom__encoder_8h}{aom/aom\_encoder.h}"}
56 \textcolor{preprocessor}{#include "\hyperlink{aomcx_8h}{aom/aomcx.h}"}
57 \textcolor{preprocessor}{#include "aom\_scale/yv12config.h"}
58 \textcolor{preprocessor}{#include "common/tools\_common.h"}
59 \textcolor{preprocessor}{#include "common/video\_writer.h"}
60 \textcolor{preprocessor}{#include "examples/encoder\_util.h"}
61 
62 \textcolor{keyword}{static} \textcolor{keyword}{const} \textcolor{keywordtype}{char} *exec\_name;
63 
64 \textcolor{keywordtype}{void} usage\_exit() \{
65   fprintf(stderr,
66           \textcolor{stringliteral}{"Usage: %s <codec> <width> <height> <infile> <outfile> "}
67           \textcolor{stringliteral}{"<frame> <limit(optional)>\(\backslash\)n"},
68           exec\_name);
69   exit(EXIT\_FAILURE);
70 \}
71 
72 \textcolor{keyword}{static} \textcolor{keywordtype}{void} testing\_decode(\hyperlink{structaom__codec__ctx}{aom\_codec\_ctx\_t} *encoder, 
      \hyperlink{structaom__codec__ctx}{aom\_codec\_ctx\_t} *decoder,
73                            \textcolor{keywordtype}{unsigned} \textcolor{keywordtype}{int} frame\_out, \textcolor{keywordtype}{int} *mismatch\_seen) \{
74   \hyperlink{structaom__image}{aom\_image\_t} enc\_img, dec\_img;
75 
76   \textcolor{keywordflow}{if} (*mismatch\_seen) \textcolor{keywordflow}{return};
77 
78   \textcolor{comment}{/* Get the internal reference frame */}
79   \textcolor{keywordflow}{if} (\hyperlink{group__codec_ga6da974f4eeaba1fa74106b28d0fe6ac5}{aom\_codec\_control}(encoder, \hyperlink{group__aom_gga9421a1fa78c0d9587ae5aa6c1cb3d659a410c706a34f5295996658cc5044a700f}{AV1\_GET\_NEW\_FRAME\_IMAGE}, &enc\_img)
      )
80     die\_codec(encoder, \textcolor{stringliteral}{"Failed to get encoder reference frame"});
81   \textcolor{keywordflow}{if} (\hyperlink{group__codec_ga6da974f4eeaba1fa74106b28d0fe6ac5}{aom\_codec\_control}(decoder, \hyperlink{group__aom_gga9421a1fa78c0d9587ae5aa6c1cb3d659a410c706a34f5295996658cc5044a700f}{AV1\_GET\_NEW\_FRAME\_IMAGE}, &dec\_img)
      )
82     die\_codec(decoder, \textcolor{stringliteral}{"Failed to get decoder reference frame"});
83 
84   \textcolor{keywordflow}{if} ((enc\_img.\hyperlink{structaom__image_a6c64b1ab918d80d52eb8f5d6d957e825}{fmt} & \hyperlink{aom__image_8h_a607b37d91f75442f54223ecd85f1b6cb}{AOM\_IMG\_FMT\_HIGHBITDEPTH}) !=
85       (dec\_img.\hyperlink{structaom__image_a6c64b1ab918d80d52eb8f5d6d957e825}{fmt} & \hyperlink{aom__image_8h_a607b37d91f75442f54223ecd85f1b6cb}{AOM\_IMG\_FMT\_HIGHBITDEPTH})) \{
86     \textcolor{keywordflow}{if} (enc\_img.\hyperlink{structaom__image_a6c64b1ab918d80d52eb8f5d6d957e825}{fmt} & \hyperlink{aom__image_8h_a607b37d91f75442f54223ecd85f1b6cb}{AOM\_IMG\_FMT\_HIGHBITDEPTH}) \{
87       \hyperlink{structaom__image}{aom\_image\_t} enc\_hbd\_img;
88       \hyperlink{aom__image_8h_a570db29fbd122951235a08fe9375f6bb}{aom\_img\_alloc}(&enc\_hbd\_img, enc\_img.\hyperlink{structaom__image_a6c64b1ab918d80d52eb8f5d6d957e825}{fmt} - 
      \hyperlink{aom__image_8h_a607b37d91f75442f54223ecd85f1b6cb}{AOM\_IMG\_FMT\_HIGHBITDEPTH},
89                     enc\_img.\hyperlink{structaom__image_a89f80b1f58d608b9d2080635f4359034}{d\_w}, enc\_img.\hyperlink{structaom__image_ab986419a1f0fff93a2dc505f47194988}{d\_h}, 16);
90       aom\_img\_truncate\_16\_to\_8(&enc\_hbd\_img, &enc\_img);
91       enc\_img = enc\_hbd\_img;
92     \}
93     \textcolor{keywordflow}{if} (dec\_img.\hyperlink{structaom__image_a6c64b1ab918d80d52eb8f5d6d957e825}{fmt} & \hyperlink{aom__image_8h_a607b37d91f75442f54223ecd85f1b6cb}{AOM\_IMG\_FMT\_HIGHBITDEPTH}) \{
94       \hyperlink{structaom__image}{aom\_image\_t} dec\_hbd\_img;
95       \hyperlink{aom__image_8h_a570db29fbd122951235a08fe9375f6bb}{aom\_img\_alloc}(&dec\_hbd\_img, dec\_img.\hyperlink{structaom__image_a6c64b1ab918d80d52eb8f5d6d957e825}{fmt} - 
      \hyperlink{aom__image_8h_a607b37d91f75442f54223ecd85f1b6cb}{AOM\_IMG\_FMT\_HIGHBITDEPTH},
96                     dec\_img.\hyperlink{structaom__image_a89f80b1f58d608b9d2080635f4359034}{d\_w}, dec\_img.\hyperlink{structaom__image_ab986419a1f0fff93a2dc505f47194988}{d\_h}, 16);
97       aom\_img\_truncate\_16\_to\_8(&dec\_hbd\_img, &dec\_img);
98       dec\_img = dec\_hbd\_img;
99     \}
100   \}
101 
102   \textcolor{keywordflow}{if} (!aom\_compare\_img(&enc\_img, &dec\_img)) \{
103     \textcolor{keywordtype}{int} y[4], u[4], v[4];
104     \textcolor{keywordflow}{if} (enc\_img.\hyperlink{structaom__image_a6c64b1ab918d80d52eb8f5d6d957e825}{fmt} & \hyperlink{aom__image_8h_a607b37d91f75442f54223ecd85f1b6cb}{AOM\_IMG\_FMT\_HIGHBITDEPTH}) \{
105       aom\_find\_mismatch\_high(&enc\_img, &dec\_img, y, u, v);
106     \} \textcolor{keywordflow}{else} \{
107       aom\_find\_mismatch(&enc\_img, &dec\_img, y, u, v);
108     \}
109 
110     printf(
111         \textcolor{stringliteral}{"Encode/decode mismatch on frame %d at"}
112         \textcolor{stringliteral}{" Y[%d, %d] \{%d/%d\},"}
113         \textcolor{stringliteral}{" U[%d, %d] \{%d/%d\},"}
114         \textcolor{stringliteral}{" V[%d, %d] \{%d/%d\}"},
115         frame\_out, y[0], y[1], y[2], y[3], u[0], u[1], u[2], u[3], v[0], v[1],
116         v[2], v[3]);
117     *mismatch\_seen = 1;
118   \}
119 
120   \hyperlink{aom__image_8h_afff22f7f3eb9409c5b678d1962f110a8}{aom\_img\_free}(&enc\_img);
121   \hyperlink{aom__image_8h_afff22f7f3eb9409c5b678d1962f110a8}{aom\_img\_free}(&dec\_img);
122 \}
123 
124 \textcolor{keyword}{static} \textcolor{keywordtype}{int} encode\_frame(\hyperlink{structaom__codec__ctx}{aom\_codec\_ctx\_t} *ecodec, \hyperlink{structaom__image}{aom\_image\_t} *img,
125                         \textcolor{keywordtype}{unsigned} \textcolor{keywordtype}{int} frame\_in, AvxVideoWriter *writer,
126                         \textcolor{keywordtype}{int} test\_decode, \hyperlink{structaom__codec__ctx}{aom\_codec\_ctx\_t} *dcodec,
127                         \textcolor{keywordtype}{unsigned} \textcolor{keywordtype}{int} *frame\_out, \textcolor{keywordtype}{int} *mismatch\_seen,
128                         \hyperlink{structaom__image}{aom\_image\_t} *ext\_ref) \{
129   \textcolor{keywordtype}{int} got\_pkts = 0;
130   \hyperlink{group__codec_gadf9e173c9e02788a9999399edab20a02}{aom\_codec\_iter\_t} iter = NULL;
131   \textcolor{keyword}{const} \hyperlink{structaom__codec__cx__pkt}{aom\_codec\_cx\_pkt\_t} *pkt = NULL;
132   \textcolor{keywordtype}{int} got\_data;
133   \textcolor{keyword}{const} \hyperlink{group__codec_gaaae61e0f8663e6137f1e228757248e7c}{aom\_codec\_err\_t} res = \hyperlink{group__encoder_ga6f4a777de5389771e783df7ff1f116d4}{aom\_codec\_encode}(ecodec, img, frame\_in, 1, 0);
134   \textcolor{keywordflow}{if} (res != \hyperlink{group__codec_ggaaae61e0f8663e6137f1e228757248e7caf145dc2f86014a08ebad36ac2b140001}{AOM\_CODEC\_OK}) die\_codec(ecodec, \textcolor{stringliteral}{"Failed to encode frame"});
135 
136   got\_data = 0;
137 
138   \textcolor{keywordflow}{while} ((pkt = \hyperlink{group__encoder_gaedc4c56b60d4217677cb561066360884}{aom\_codec\_get\_cx\_data}(ecodec, &iter)) != NULL) \{
139     got\_pkts = 1;
140 
141     \textcolor{keywordflow}{if} (pkt->\hyperlink{structaom__codec__cx__pkt_a11e586120c689ece9a7690e72ff384be}{kind} == \hyperlink{group__encoder_ggafeb69da4a9649a54e805f59c26d8dfeda793165d0f219812342f69d5fd9b2b9c8}{AOM\_CODEC\_CX\_FRAME\_PKT}) \{
142       \textcolor{keyword}{const} \textcolor{keywordtype}{int} keyframe = (pkt->\hyperlink{structaom__codec__cx__pkt_afb379cd4bfa7692d1d6e85f4e4b2b410}{data}.\hyperlink{structaom__codec__cx__pkt_a4180a6ae59b0d295bc915d4689df4cb0}{frame}.flags & \hyperlink{group__encoder_gaf4a58f123913a5eef0a3796f0619e5f3}{AOM\_FRAME\_IS\_KEY}) != 0;
143 
144       ++*frame\_out;
145 
146       \textcolor{keywordflow}{if} (!aom\_video\_writer\_write\_frame(writer, pkt->\hyperlink{structaom__codec__cx__pkt_afb379cd4bfa7692d1d6e85f4e4b2b410}{data}.\hyperlink{structaom__codec__cx__pkt_a4180a6ae59b0d295bc915d4689df4cb0}{frame}.buf,
147                                         pkt->\hyperlink{structaom__codec__cx__pkt_afb379cd4bfa7692d1d6e85f4e4b2b410}{data}.\hyperlink{structaom__codec__cx__pkt_a4180a6ae59b0d295bc915d4689df4cb0}{frame}.sz,
148                                         pkt->\hyperlink{structaom__codec__cx__pkt_afb379cd4bfa7692d1d6e85f4e4b2b410}{data}.\hyperlink{structaom__codec__cx__pkt_a4180a6ae59b0d295bc915d4689df4cb0}{frame}.pts)) \{
149         die\_codec(ecodec, \textcolor{stringliteral}{"Failed to write compressed frame"});
150       \}
151       printf(keyframe ? \textcolor{stringliteral}{"K"} : \textcolor{stringliteral}{"."});
152       fflush(stdout);
153       got\_data = 1;
154 
155       \textcolor{comment}{// Decode 1 frame.}
156       \textcolor{keywordflow}{if} (test\_decode) \{
157         \textcolor{keywordflow}{if} (\hyperlink{group__decoder_gab03fdb999d1f83a5896869a3ba5f68f7}{aom\_codec\_decode}(dcodec, pkt->\hyperlink{structaom__codec__cx__pkt_afb379cd4bfa7692d1d6e85f4e4b2b410}{data}.\hyperlink{structaom__codec__cx__pkt_a4180a6ae59b0d295bc915d4689df4cb0}{frame}.buf,
158                              (\textcolor{keywordtype}{unsigned} \textcolor{keywordtype}{int})pkt->\hyperlink{structaom__codec__cx__pkt_afb379cd4bfa7692d1d6e85f4e4b2b410}{data}.\hyperlink{structaom__codec__cx__pkt_a4180a6ae59b0d295bc915d4689df4cb0}{frame}.sz, NULL))
159           die\_codec(dcodec, \textcolor{stringliteral}{"Failed to decode frame."});
160 
161         \textcolor{comment}{// Copy out first decoded frame, and use it as reference later.}
162         \textcolor{keywordflow}{if} (*frame\_out == 1 && ext\_ref != NULL)
163           \textcolor{keywordflow}{if} (\hyperlink{group__codec_ga6da974f4eeaba1fa74106b28d0fe6ac5}{aom\_codec\_control}(dcodec, 
      \hyperlink{group__aom_gga9421a1fa78c0d9587ae5aa6c1cb3d659ae41763622ee33cd99e23ca8f78a3f8fa}{AV1\_COPY\_NEW\_FRAME\_IMAGE}, ext\_ref))
164             die\_codec(dcodec, \textcolor{stringliteral}{"Failed to get decoder new frame"});
165       \}
166     \}
167   \}
168 
169   \textcolor{comment}{// Mismatch checking}
170   \textcolor{keywordflow}{if} (got\_data && test\_decode) \{
171     testing\_decode(ecodec, dcodec, *frame\_out, mismatch\_seen);
172   \}
173 
174   \textcolor{keywordflow}{return} got\_pkts;
175 \}
176 
177 \textcolor{keywordtype}{int} main(\textcolor{keywordtype}{int} argc, \textcolor{keywordtype}{char} **argv) \{
178   FILE *infile = NULL;
179   \textcolor{comment}{// Encoder}
180   \hyperlink{structaom__codec__ctx}{aom\_codec\_ctx\_t} ecodec;
181   \hyperlink{structaom__codec__enc__cfg}{aom\_codec\_enc\_cfg\_t} cfg;
182   \textcolor{keywordtype}{unsigned} \textcolor{keywordtype}{int} frame\_in = 0;
183   \hyperlink{structaom__image}{aom\_image\_t} raw;
184   \hyperlink{structaom__image}{aom\_image\_t} raw\_shift;
185   \hyperlink{structaom__image}{aom\_image\_t} ext\_ref;
186   \hyperlink{group__codec_gaaae61e0f8663e6137f1e228757248e7c}{aom\_codec\_err\_t} res;
187   AvxVideoInfo info;
188   AvxVideoWriter *writer = NULL;
189   \textcolor{keyword}{const} AvxInterface *encoder = NULL;
190   \textcolor{keywordtype}{int} flags = 0;
191   \textcolor{keywordtype}{int} allocated\_raw\_shift = 0;
192   \hyperlink{aom__image_8h_ab71efff8c7f49380fad23b93bc2e9bfc}{aom\_img\_fmt\_t} raw\_fmt = \hyperlink{aom__image_8h_a930317c04b4bd0a660bb5e744055523cabd778a3d697463e89d12a1117f417b60}{AOM\_IMG\_FMT\_I420};
193   \hyperlink{aom__image_8h_ab71efff8c7f49380fad23b93bc2e9bfc}{aom\_img\_fmt\_t} ref\_fmt = \hyperlink{aom__image_8h_a930317c04b4bd0a660bb5e744055523cabd778a3d697463e89d12a1117f417b60}{AOM\_IMG\_FMT\_I420};
194 
195   \textcolor{comment}{// Test encoder/decoder mismatch.}
196   \textcolor{keywordtype}{int} test\_decode = 1;
197   \textcolor{comment}{// Decoder}
198   \hyperlink{structaom__codec__ctx}{aom\_codec\_ctx\_t} dcodec;
199   \textcolor{keywordtype}{unsigned} \textcolor{keywordtype}{int} frame\_out = 0;
200 
201   \textcolor{comment}{// The frame number to set reference frame on}
202   \textcolor{keywordtype}{unsigned} \textcolor{keywordtype}{int} update\_frame\_num = 0;
203   \textcolor{keywordtype}{int} mismatch\_seen = 0;
204 
205   \textcolor{keyword}{const} \textcolor{keywordtype}{int} fps = 30;
206   \textcolor{keyword}{const} \textcolor{keywordtype}{int} bitrate = 500;
207 
208   \textcolor{keyword}{const} \textcolor{keywordtype}{char} *codec\_arg = NULL;
209   \textcolor{keyword}{const} \textcolor{keywordtype}{char} *width\_arg = NULL;
210   \textcolor{keyword}{const} \textcolor{keywordtype}{char} *height\_arg = NULL;
211   \textcolor{keyword}{const} \textcolor{keywordtype}{char} *infile\_arg = NULL;
212   \textcolor{keyword}{const} \textcolor{keywordtype}{char} *outfile\_arg = NULL;
213   \textcolor{keyword}{const} \textcolor{keywordtype}{char} *update\_frame\_num\_arg = NULL;
214   \textcolor{keywordtype}{unsigned} \textcolor{keywordtype}{int} limit = 0;
215   exec\_name = argv[0];
216 
217   \textcolor{comment}{// Clear explicitly, as simply assigning "\{ 0 \}" generates}
218   \textcolor{comment}{// "missing-field-initializers" warning in some compilers.}
219   memset(&ecodec, 0, \textcolor{keyword}{sizeof}(ecodec));
220   memset(&cfg, 0, \textcolor{keyword}{sizeof}(cfg));
221   memset(&info, 0, \textcolor{keyword}{sizeof}(info));
222 
223   \textcolor{keywordflow}{if} (argc < 7) die(\textcolor{stringliteral}{"Invalid number of arguments"});
224 
225   codec\_arg = argv[1];
226   width\_arg = argv[2];
227   height\_arg = argv[3];
228   infile\_arg = argv[4];
229   outfile\_arg = argv[5];
230   update\_frame\_num\_arg = argv[6];
231 
232   encoder = get\_aom\_encoder\_by\_name(codec\_arg);
233   \textcolor{keywordflow}{if} (!encoder) die(\textcolor{stringliteral}{"Unsupported codec."});
234 
235   update\_frame\_num = (\textcolor{keywordtype}{unsigned} int)strtoul(update\_frame\_num\_arg, NULL, 0);
236   \textcolor{comment}{// In AV1, the reference buffers (cm->buffer\_pool->frame\_bufs[i].buf) are}
237   \textcolor{comment}{// allocated while calling aom\_codec\_encode(), thus, setting reference for}
238   \textcolor{comment}{// 1st frame isn't supported.}
239   \textcolor{keywordflow}{if} (update\_frame\_num <= 1) \{
240     die(\textcolor{stringliteral}{"Couldn't parse frame number '%s'\(\backslash\)n"}, update\_frame\_num\_arg);
241   \}
242 
243   \textcolor{keywordflow}{if} (argc > 7) \{
244     limit = (\textcolor{keywordtype}{unsigned} int)strtoul(argv[7], NULL, 0);
245     \textcolor{keywordflow}{if} (update\_frame\_num > limit)
246       die(\textcolor{stringliteral}{"Update frame number couldn't larger than limit\(\backslash\)n"});
247   \}
248 
249   info.codec\_fourcc = encoder->fourcc;
250   info.frame\_width = (int)strtol(width\_arg, NULL, 0);
251   info.frame\_height = (int)strtol(height\_arg, NULL, 0);
252   info.time\_base.numerator = 1;
253   info.time\_base.denominator = fps;
254 
255   \textcolor{keywordflow}{if} (info.frame\_width <= 0 || info.frame\_height <= 0) \{
256     die(\textcolor{stringliteral}{"Invalid frame size: %dx%d"}, info.frame\_width, info.frame\_height);
257   \}
258 
259   \textcolor{comment}{// In this test, the bit depth of input video is 8-bit, and the input format}
260   \textcolor{comment}{// is AOM\_IMG\_FMT\_I420.}
261   \textcolor{keywordflow}{if} (!\hyperlink{aom__image_8h_a570db29fbd122951235a08fe9375f6bb}{aom\_img\_alloc}(&raw, raw\_fmt, info.frame\_width, info.frame\_height, 32)) \{
262     die(\textcolor{stringliteral}{"Failed to allocate image."});
263   \}
264 
265   \textcolor{keywordflow}{if} (!CONFIG\_LOWBITDEPTH) ref\_fmt |= \hyperlink{aom__image_8h_a607b37d91f75442f54223ecd85f1b6cb}{AOM\_IMG\_FMT\_HIGHBITDEPTH};
266   \textcolor{comment}{// Allocate memory with the border so that it can be used as a reference.}
267   \textcolor{keywordflow}{if} (!\hyperlink{aom__image_8h_aeb211e5184687f7e10d7c5bed4dcfdcd}{aom\_img\_alloc\_with\_border}(&ext\_ref, ref\_fmt, info.frame\_width,
268                                  info.frame\_height, 32, 8,
269                                  AOM\_BORDER\_IN\_PIXELS)) \{
270     die(\textcolor{stringliteral}{"Failed to allocate image."});
271   \}
272 
273   printf(\textcolor{stringliteral}{"Using %s\(\backslash\)n"}, \hyperlink{group__codec_ga013b1f6d96b2cf9489396311a7e5179b}{aom\_codec\_iface\_name}(encoder->codec\_interface()));
274 
275   res = \hyperlink{group__encoder_gabe456ab6f99bdebc47018779b75d2521}{aom\_codec\_enc\_config\_default}(encoder->codec\_interface(), &cfg, 0);
276   \textcolor{keywordflow}{if} (res) die\_codec(&ecodec, \textcolor{stringliteral}{"Failed to get default codec config."});
277 
278   cfg.\hyperlink{structaom__codec__enc__cfg_a80cb459c5ef3c7e1516f617c4c9d6eab}{g\_w} = info.frame\_width;
279   cfg.\hyperlink{structaom__codec__enc__cfg_a37b0f57b63bec8d133df8901d4407ee6}{g\_h} = info.frame\_height;
280   cfg.\hyperlink{structaom__codec__enc__cfg_a10664f1fc5b6ec29b77ee13efeeecdf7}{g\_timebase}.\hyperlink{structaom__rational_a7b48174411798c780a15f132c4650839}{num} = info.time\_base.numerator;
281   cfg.\hyperlink{structaom__codec__enc__cfg_a10664f1fc5b6ec29b77ee13efeeecdf7}{g\_timebase}.\hyperlink{structaom__rational_adeddf2ea01c12b7be66536e0a0fb92c5}{den} = info.time\_base.denominator;
282   cfg.\hyperlink{structaom__codec__enc__cfg_ab21539da477dba7506d90353c27d218b}{rc\_target\_bitrate} = bitrate;
283   cfg.\hyperlink{structaom__codec__enc__cfg_a614a49318f2011cc8735d7e51b910fa4}{g\_lag\_in\_frames} = 3;
284   cfg.\hyperlink{structaom__codec__enc__cfg_a76a27f44cded1516803a776a0a7e9038}{g\_bit\_depth} = \hyperlink{group__codec_gga6ed0e98eba4651c1ad845e39498e4153a4c7f55539160206a3fbb2a6cfc9ef89c}{AOM\_BITS\_8};
285 
286   flags |= (cfg.\hyperlink{structaom__codec__enc__cfg_a76a27f44cded1516803a776a0a7e9038}{g\_bit\_depth} > \hyperlink{group__codec_gga6ed0e98eba4651c1ad845e39498e4153a4c7f55539160206a3fbb2a6cfc9ef89c}{AOM\_BITS\_8} || !CONFIG\_LOWBITDEPTH)
287                ? \hyperlink{group__encoder_gae30bbbdef18e9da3631b69c170533e92}{AOM\_CODEC\_USE\_HIGHBITDEPTH}
288                : 0;
289 
290   writer = aom\_video\_writer\_open(outfile\_arg, kContainerIVF, &info);
291   \textcolor{keywordflow}{if} (!writer) die(\textcolor{stringliteral}{"Failed to open %s for writing."}, outfile\_arg);
292 
293   \textcolor{keywordflow}{if} (!(infile = fopen(infile\_arg, \textcolor{stringliteral}{"rb"})))
294     die(\textcolor{stringliteral}{"Failed to open %s for reading."}, infile\_arg);
295 
296   \textcolor{keywordflow}{if} (\hyperlink{group__encoder_gaade68a7d33d30f97dc9a596aa5e065d8}{aom\_codec\_enc\_init}(&ecodec, encoder->codec\_interface(), &cfg, flags))
297     die\_codec(&ecodec, \textcolor{stringliteral}{"Failed to initialize encoder"});
298 
299   \textcolor{comment}{// Disable alt\_ref.}
300   \textcolor{keywordflow}{if} (\hyperlink{group__codec_ga6da974f4eeaba1fa74106b28d0fe6ac5}{aom\_codec\_control}(&ecodec, \hyperlink{group__aom__encoder_ggae78dde67a6d78f332e9bdba0dde42db5ac8a24393f214823f5a6bd345afb840b6}{AOME\_SET\_ENABLEAUTOALTREF}, 0))
301     die\_codec(&ecodec, \textcolor{stringliteral}{"Failed to set enable auto alt ref"});
302 
303   \textcolor{keywordflow}{if} (test\_decode) \{
304     \textcolor{keyword}{const} AvxInterface *decoder = get\_aom\_decoder\_by\_name(codec\_arg);
305     \textcolor{keywordflow}{if} (\hyperlink{group__decoder_gafdbfca65b19ab1f6d72b32cd01753b9b}{aom\_codec\_dec\_init}(&dcodec, decoder->codec\_interface(), NULL, 0))
306       die\_codec(&dcodec, \textcolor{stringliteral}{"Failed to initialize decoder."});
307   \}
308 
309   \textcolor{comment}{// Encode frames.}
310   \textcolor{keywordflow}{while} (aom\_img\_read(&raw, infile)) \{
311     \textcolor{keywordflow}{if} (limit && frame\_in >= limit) \textcolor{keywordflow}{break};
312     \hyperlink{structaom__image}{aom\_image\_t} *frame\_to\_encode;
313 
314     \textcolor{keywordflow}{if} (!CONFIG\_LOWBITDEPTH) \{
315       \textcolor{comment}{// Need to allocate larger buffer to use hbd internal.}
316       \textcolor{keywordtype}{int} input\_shift = 0;
317       \textcolor{keywordflow}{if} (!allocated\_raw\_shift) \{
318         \hyperlink{aom__image_8h_a570db29fbd122951235a08fe9375f6bb}{aom\_img\_alloc}(&raw\_shift, raw\_fmt | 
      \hyperlink{aom__image_8h_a607b37d91f75442f54223ecd85f1b6cb}{AOM\_IMG\_FMT\_HIGHBITDEPTH},
319                       info.frame\_width, info.frame\_height, 32);
320         allocated\_raw\_shift = 1;
321       \}
322       aom\_img\_upshift(&raw\_shift, &raw, input\_shift);
323       frame\_to\_encode = &raw\_shift;
324     \} \textcolor{keywordflow}{else} \{
325       frame\_to\_encode = &raw;
326     \}
327 
328     \textcolor{keywordflow}{if} (update\_frame\_num > 1 && frame\_out + 1 == update\_frame\_num) \{
329       \hyperlink{structav1__ref__frame}{av1\_ref\_frame\_t} ref;
330       ref.\hyperlink{structav1__ref__frame_a7c6fcaba58f514985448cb2e2245345c}{idx} = 0;
331       ref.\hyperlink{structav1__ref__frame_a33749c5c20033cc5f7582d0ec1c34ff0}{use\_external\_ref} = 0;
332       ref.\hyperlink{structav1__ref__frame_a55a09db9e1acdd73e656b01fa01283b3}{img} = ext\_ref;
333       \textcolor{comment}{// Set reference frame in encoder.}
334       \textcolor{keywordflow}{if} (\hyperlink{group__codec_ga6da974f4eeaba1fa74106b28d0fe6ac5}{aom\_codec\_control}(&ecodec, \hyperlink{group__aom_gga9421a1fa78c0d9587ae5aa6c1cb3d659a51ad4467b4dc318406cceb257e2daa41}{AV1\_SET\_REFERENCE}, &ref))
335         die\_codec(&ecodec, \textcolor{stringliteral}{"Failed to set encoder reference frame"});
336       printf(\textcolor{stringliteral}{" <SET\_REF>"});
337 
338       \textcolor{comment}{// If set\_reference in decoder is commented out, the enc/dec mismatch}
339       \textcolor{comment}{// would be seen.}
340       \textcolor{keywordflow}{if} (test\_decode) \{
341         ref.\hyperlink{structav1__ref__frame_a33749c5c20033cc5f7582d0ec1c34ff0}{use\_external\_ref} = 1;
342         \textcolor{keywordflow}{if} (\hyperlink{group__codec_ga6da974f4eeaba1fa74106b28d0fe6ac5}{aom\_codec\_control}(&dcodec, \hyperlink{group__aom_gga9421a1fa78c0d9587ae5aa6c1cb3d659a51ad4467b4dc318406cceb257e2daa41}{AV1\_SET\_REFERENCE}, &ref))
343           die\_codec(&dcodec, \textcolor{stringliteral}{"Failed to set decoder reference frame"});
344       \}
345     \}
346 
347     encode\_frame(&ecodec, frame\_to\_encode, frame\_in, writer, test\_decode,
348                  &dcodec, &frame\_out, &mismatch\_seen, &ext\_ref);
349     frame\_in++;
350     \textcolor{keywordflow}{if} (mismatch\_seen) \textcolor{keywordflow}{break};
351   \}
352 
353   \textcolor{comment}{// Flush encoder.}
354   \textcolor{keywordflow}{if} (!mismatch\_seen)
355     \textcolor{keywordflow}{while} (encode\_frame(&ecodec, NULL, frame\_in, writer, test\_decode, &dcodec,
356                         &frame\_out, &mismatch\_seen, NULL)) \{
357     \}
358 
359   printf(\textcolor{stringliteral}{"\(\backslash\)n"});
360   fclose(infile);
361   printf(\textcolor{stringliteral}{"Processed %d frames.\(\backslash\)n"}, frame\_out);
362 
363   \textcolor{keywordflow}{if} (test\_decode) \{
364     \textcolor{keywordflow}{if} (!mismatch\_seen)
365       printf(\textcolor{stringliteral}{"Encoder/decoder results are matching.\(\backslash\)n"});
366     \textcolor{keywordflow}{else}
367       printf(\textcolor{stringliteral}{"Encoder/decoder results are NOT matching.\(\backslash\)n"});
368   \}
369 
370   \textcolor{keywordflow}{if} (test\_decode)
371     \textcolor{keywordflow}{if} (\hyperlink{group__codec_ga9b60e186f61ba2d6ab2b8069b76a15c5}{aom\_codec\_destroy}(&dcodec))
372       die\_codec(&dcodec, \textcolor{stringliteral}{"Failed to destroy decoder"});
373 
374   \textcolor{keywordflow}{if} (allocated\_raw\_shift) \hyperlink{aom__image_8h_afff22f7f3eb9409c5b678d1962f110a8}{aom\_img\_free}(&raw\_shift);
375   \hyperlink{aom__image_8h_afff22f7f3eb9409c5b678d1962f110a8}{aom\_img\_free}(&ext\_ref);
376   \hyperlink{aom__image_8h_afff22f7f3eb9409c5b678d1962f110a8}{aom\_img\_free}(&raw);
377   \textcolor{keywordflow}{if} (\hyperlink{group__codec_ga9b60e186f61ba2d6ab2b8069b76a15c5}{aom\_codec\_destroy}(&ecodec))
378     die\_codec(&ecodec, \textcolor{stringliteral}{"Failed to destroy encoder."});
379 
380   aom\_video\_writer\_close(writer);
381 
382   \textcolor{keywordflow}{return} EXIT\_SUCCESS;
383 \}
\end{DoxyCodeInclude}
 \hypertarget{example_lightfield_encoder}{}\subsection{lightfield\+\_\+encoder}\label{example_lightfield_encoder}

\begin{DoxyCodeInclude}
1 \textcolor{comment}{/*}
2 \textcolor{comment}{ * Copyright (c) 2017, Alliance for Open Media. All rights reserved}
3 \textcolor{comment}{ *}
4 \textcolor{comment}{ * This source code is subject to the terms of the BSD 2 Clause License and}
5 \textcolor{comment}{ * the Alliance for Open Media Patent License 1.0. If the BSD 2 Clause License}
6 \textcolor{comment}{ * was not distributed with this source code in the LICENSE file, you can}
7 \textcolor{comment}{ * obtain it at www.aomedia.org/license/software. If the Alliance for Open}
8 \textcolor{comment}{ * Media Patent License 1.0 was not distributed with this source code in the}
9 \textcolor{comment}{ * PATENTS file, you can obtain it at www.aomedia.org/license/patent.}
10 \textcolor{comment}{ */}
11 
12 \textcolor{comment}{// Lightfield Encoder}
13 \textcolor{comment}{// ==================}
14 \textcolor{comment}{//}
15 \textcolor{comment}{// This is an example of a simple lightfield encoder.  It builds upon the}
16 \textcolor{comment}{// twopass\_encoder.c example. It takes an input file in YV12 format,}
17 \textcolor{comment}{// treating it as a planar lightfield instead of a video. The img\_width}
18 \textcolor{comment}{// and img\_height arguments are the dimensions of the lightfield images,}
19 \textcolor{comment}{// while the lf\_width and lf\_height arguments are the number of}
20 \textcolor{comment}{// lightfield images in each dimension. The lf\_blocksize determines the}
21 \textcolor{comment}{// number of reference images used for MCP. For example, 5 means that there}
22 \textcolor{comment}{// is a reference image for every 5x5 lightfield image block. All images}
23 \textcolor{comment}{// within a block will use the center image in that block as the reference}
24 \textcolor{comment}{// image for MCP.}
25 \textcolor{comment}{// Run "make test" to download lightfield test data: vase10x10.yuv.}
26 \textcolor{comment}{// Run lightfield encoder to encode whole lightfield:}
27 \textcolor{comment}{// examples/lightfield\_encoder 1024 1024 vase10x10.yuv vase10x10.ivf 10 10 5}
28 
29 \textcolor{comment}{// Note: In bitstream.c and encoder.c, define EXT\_TILE\_DEBUG as 1 will print}
30 \textcolor{comment}{// out the uncompressed header and the frame contexts, which can be used to}
31 \textcolor{comment}{// test the bit exactness of the headers and the frame contexts for large scale}
32 \textcolor{comment}{// tile coded frames.}
33 
34 \textcolor{preprocessor}{#include <stdio.h>}
35 \textcolor{preprocessor}{#include <stdlib.h>}
36 \textcolor{preprocessor}{#include <string.h>}
37 
38 \textcolor{preprocessor}{#include "\hyperlink{aom__encoder_8h}{aom/aom\_encoder.h}"}
39 \textcolor{preprocessor}{#include "\hyperlink{aomcx_8h}{aom/aomcx.h}"}
40 \textcolor{preprocessor}{#include "aom\_scale/yv12config.h"}
41 \textcolor{preprocessor}{#include "av1/common/enums.h"}
42 \textcolor{preprocessor}{#include "common/tools\_common.h"}
43 \textcolor{preprocessor}{#include "common/video\_writer.h"}
44 
45 \textcolor{keyword}{static} \textcolor{keyword}{const} \textcolor{keywordtype}{char} *exec\_name;
46 
47 \textcolor{keywordtype}{void} usage\_exit(\textcolor{keywordtype}{void}) \{
48   fprintf(stderr,
49           \textcolor{stringliteral}{"Usage: %s <img\_width> <img\_height> <infile> <outfile> "}
50           \textcolor{stringliteral}{"<lf\_width> <lf\_height> <lf\_blocksize>\(\backslash\)n"},
51           exec\_name);
52   exit(EXIT\_FAILURE);
53 \}
54 
55 \textcolor{keyword}{static} \textcolor{keywordtype}{int} aom\_img\_size\_bytes(\hyperlink{structaom__image}{aom\_image\_t} *img) \{
56   \textcolor{keywordtype}{int} image\_size\_bytes = 0;
57   \textcolor{keywordtype}{int} plane;
58   \textcolor{keywordflow}{for} (plane = 0; plane < 3; ++plane) \{
59     \textcolor{keyword}{const} \textcolor{keywordtype}{int} w = \hyperlink{aom__image_8h_adfb2ea2e110ee42e38370868b64bf232}{aom\_img\_plane\_width}(img, plane) *
60                   ((img->\hyperlink{structaom__image_a6c64b1ab918d80d52eb8f5d6d957e825}{fmt} & \hyperlink{aom__image_8h_a607b37d91f75442f54223ecd85f1b6cb}{AOM\_IMG\_FMT\_HIGHBITDEPTH}) ? 2 : 1);
61     \textcolor{keyword}{const} \textcolor{keywordtype}{int} h = \hyperlink{aom__image_8h_ab87684a93e3da97bd6223d1e46876848}{aom\_img\_plane\_height}(img, plane);
62     image\_size\_bytes += w * h;
63   \}
64   \textcolor{keywordflow}{return} image\_size\_bytes;
65 \}
66 
67 \textcolor{keyword}{static} \textcolor{keywordtype}{int} get\_frame\_stats(\hyperlink{structaom__codec__ctx}{aom\_codec\_ctx\_t} *ctx, \textcolor{keyword}{const} 
      \hyperlink{structaom__image}{aom\_image\_t} *img,
68                            \hyperlink{group__encoder_ga958524226c9a65251c9e4f7bb78fc606}{aom\_codec\_pts\_t} pts, \textcolor{keywordtype}{unsigned} \textcolor{keywordtype}{int} duration,
69                            \hyperlink{group__encoder_gacbef92200b831adb94283f84128f83de}{aom\_enc\_frame\_flags\_t} flags,
70                            \hyperlink{structaom__fixed__buf}{aom\_fixed\_buf\_t} *stats) \{
71   \textcolor{keywordtype}{int} got\_pkts = 0;
72   \hyperlink{group__codec_gadf9e173c9e02788a9999399edab20a02}{aom\_codec\_iter\_t} iter = NULL;
73   \textcolor{keyword}{const} \hyperlink{structaom__codec__cx__pkt}{aom\_codec\_cx\_pkt\_t} *pkt = NULL;
74   \textcolor{keyword}{const} \hyperlink{group__codec_gaaae61e0f8663e6137f1e228757248e7c}{aom\_codec\_err\_t} res = \hyperlink{group__encoder_ga6f4a777de5389771e783df7ff1f116d4}{aom\_codec\_encode}(ctx, img, pts, duration, 
      flags);
75   \textcolor{keywordflow}{if} (res != \hyperlink{group__codec_ggaaae61e0f8663e6137f1e228757248e7caf145dc2f86014a08ebad36ac2b140001}{AOM\_CODEC\_OK}) die\_codec(ctx, \textcolor{stringliteral}{"Failed to get frame stats."});
76 
77   \textcolor{keywordflow}{while} ((pkt = \hyperlink{group__encoder_gaedc4c56b60d4217677cb561066360884}{aom\_codec\_get\_cx\_data}(ctx, &iter)) != NULL) \{
78     got\_pkts = 1;
79 
80     \textcolor{keywordflow}{if} (pkt->\hyperlink{structaom__codec__cx__pkt_a11e586120c689ece9a7690e72ff384be}{kind} == \hyperlink{group__encoder_ggafeb69da4a9649a54e805f59c26d8dfeda7dcdcb6c401cac64ca98b51f52de8d4b}{AOM\_CODEC\_STATS\_PKT}) \{
81       \textcolor{keyword}{const} uint8\_t *\textcolor{keyword}{const} pkt\_buf = pkt->\hyperlink{structaom__codec__cx__pkt_afb379cd4bfa7692d1d6e85f4e4b2b410}{data}.\hyperlink{structaom__codec__cx__pkt_a40d469839bcd8195c3c8e80db6561dbb}{twopass\_stats}.
      \hyperlink{structaom__fixed__buf_ac1b22da152c9839329d3780208dffd38}{buf};
82       \textcolor{keyword}{const} \textcolor{keywordtype}{size\_t} pkt\_size = pkt->\hyperlink{structaom__codec__cx__pkt_afb379cd4bfa7692d1d6e85f4e4b2b410}{data}.\hyperlink{structaom__codec__cx__pkt_a40d469839bcd8195c3c8e80db6561dbb}{twopass\_stats}.\hyperlink{structaom__fixed__buf_a02f47e8b960c332c60a8aa4b7e37426f}{sz};
83       stats->\hyperlink{structaom__fixed__buf_ac1b22da152c9839329d3780208dffd38}{buf} = realloc(stats->\hyperlink{structaom__fixed__buf_ac1b22da152c9839329d3780208dffd38}{buf}, stats->\hyperlink{structaom__fixed__buf_a02f47e8b960c332c60a8aa4b7e37426f}{sz} + pkt\_size);
84       memcpy((uint8\_t *)stats->\hyperlink{structaom__fixed__buf_ac1b22da152c9839329d3780208dffd38}{buf} + stats->\hyperlink{structaom__fixed__buf_a02f47e8b960c332c60a8aa4b7e37426f}{sz}, pkt\_buf, pkt\_size);
85       stats->\hyperlink{structaom__fixed__buf_a02f47e8b960c332c60a8aa4b7e37426f}{sz} += pkt\_size;
86     \}
87   \}
88 
89   \textcolor{keywordflow}{return} got\_pkts;
90 \}
91 
92 \textcolor{keyword}{static} \textcolor{keywordtype}{int} encode\_frame(\hyperlink{structaom__codec__ctx}{aom\_codec\_ctx\_t} *ctx, \textcolor{keyword}{const} \hyperlink{structaom__image}{aom\_image\_t} *img,
93                         \hyperlink{group__encoder_ga958524226c9a65251c9e4f7bb78fc606}{aom\_codec\_pts\_t} pts, \textcolor{keywordtype}{unsigned} \textcolor{keywordtype}{int} duration,
94                         \hyperlink{group__encoder_gacbef92200b831adb94283f84128f83de}{aom\_enc\_frame\_flags\_t} flags, AvxVideoWriter *writer) \{
95   \textcolor{keywordtype}{int} got\_pkts = 0;
96   \hyperlink{group__codec_gadf9e173c9e02788a9999399edab20a02}{aom\_codec\_iter\_t} iter = NULL;
97   \textcolor{keyword}{const} \hyperlink{structaom__codec__cx__pkt}{aom\_codec\_cx\_pkt\_t} *pkt = NULL;
98   \textcolor{keyword}{const} \hyperlink{group__codec_gaaae61e0f8663e6137f1e228757248e7c}{aom\_codec\_err\_t} res = \hyperlink{group__encoder_ga6f4a777de5389771e783df7ff1f116d4}{aom\_codec\_encode}(ctx, img, pts, duration, 
      flags);
99   \textcolor{keywordflow}{if} (res != \hyperlink{group__codec_ggaaae61e0f8663e6137f1e228757248e7caf145dc2f86014a08ebad36ac2b140001}{AOM\_CODEC\_OK}) die\_codec(ctx, \textcolor{stringliteral}{"Failed to encode frame."});
100 
101   \textcolor{keywordflow}{while} ((pkt = \hyperlink{group__encoder_gaedc4c56b60d4217677cb561066360884}{aom\_codec\_get\_cx\_data}(ctx, &iter)) != NULL) \{
102     got\_pkts = 1;
103     \textcolor{keywordflow}{if} (pkt->\hyperlink{structaom__codec__cx__pkt_a11e586120c689ece9a7690e72ff384be}{kind} == \hyperlink{group__encoder_ggafeb69da4a9649a54e805f59c26d8dfeda793165d0f219812342f69d5fd9b2b9c8}{AOM\_CODEC\_CX\_FRAME\_PKT}) \{
104       \textcolor{keyword}{const} \textcolor{keywordtype}{int} keyframe = (pkt->\hyperlink{structaom__codec__cx__pkt_afb379cd4bfa7692d1d6e85f4e4b2b410}{data}.\hyperlink{structaom__codec__cx__pkt_a4180a6ae59b0d295bc915d4689df4cb0}{frame}.flags & \hyperlink{group__encoder_gaf4a58f123913a5eef0a3796f0619e5f3}{AOM\_FRAME\_IS\_KEY}) != 0;
105 
106       \textcolor{keywordflow}{if} (!aom\_video\_writer\_write\_frame(writer, pkt->\hyperlink{structaom__codec__cx__pkt_afb379cd4bfa7692d1d6e85f4e4b2b410}{data}.\hyperlink{structaom__codec__cx__pkt_a4180a6ae59b0d295bc915d4689df4cb0}{frame}.buf,
107                                         pkt->\hyperlink{structaom__codec__cx__pkt_afb379cd4bfa7692d1d6e85f4e4b2b410}{data}.\hyperlink{structaom__codec__cx__pkt_a4180a6ae59b0d295bc915d4689df4cb0}{frame}.sz,
108                                         pkt->\hyperlink{structaom__codec__cx__pkt_afb379cd4bfa7692d1d6e85f4e4b2b410}{data}.\hyperlink{structaom__codec__cx__pkt_a4180a6ae59b0d295bc915d4689df4cb0}{frame}.pts))
109         die\_codec(ctx, \textcolor{stringliteral}{"Failed to write compressed frame."});
110       printf(keyframe ? \textcolor{stringliteral}{"K"} : \textcolor{stringliteral}{"."});
111       fflush(stdout);
112     \}
113   \}
114 
115   \textcolor{keywordflow}{return} got\_pkts;
116 \}
117 
118 \textcolor{keyword}{static} \textcolor{keywordtype}{void} get\_raw\_image(\hyperlink{structaom__image}{aom\_image\_t} **frame\_to\_encode, \hyperlink{structaom__image}{aom\_image\_t} *raw,
119                           \hyperlink{structaom__image}{aom\_image\_t} *raw\_shift) \{
120   \textcolor{keywordflow}{if} (!CONFIG\_LOWBITDEPTH) \{
121     \textcolor{comment}{// Need to allocate larger buffer to use hbd internal.}
122     \textcolor{keywordtype}{int} input\_shift = 0;
123     aom\_img\_upshift(raw\_shift, raw, input\_shift);
124     *frame\_to\_encode = raw\_shift;
125   \} \textcolor{keywordflow}{else} \{
126     *frame\_to\_encode = raw;
127   \}
128 \}
129 
130 \textcolor{keyword}{static} \hyperlink{structaom__fixed__buf}{aom\_fixed\_buf\_t} pass0(\hyperlink{structaom__image}{aom\_image\_t} *raw, FILE *infile,
131                              \textcolor{keyword}{const} AvxInterface *encoder,
132                              \textcolor{keyword}{const} \hyperlink{structaom__codec__enc__cfg}{aom\_codec\_enc\_cfg\_t} *cfg, \textcolor{keywordtype}{int} lf\_width,
133                              \textcolor{keywordtype}{int} lf\_height, \textcolor{keywordtype}{int} lf\_blocksize, \textcolor{keywordtype}{int} flags,
134                              \hyperlink{structaom__image}{aom\_image\_t} *raw\_shift) \{
135   \hyperlink{structaom__codec__ctx}{aom\_codec\_ctx\_t} codec;
136   \textcolor{keywordtype}{int} frame\_count = 0;
137   \textcolor{keywordtype}{int} image\_size\_bytes = aom\_img\_size\_bytes(raw);
138   \textcolor{keywordtype}{int} u\_blocks, v\_blocks;
139   \textcolor{keywordtype}{int} bu, bv;
140   \hyperlink{structaom__fixed__buf}{aom\_fixed\_buf\_t} stats = \{ NULL, 0 \};
141   \hyperlink{structaom__image}{aom\_image\_t} *frame\_to\_encode;
142 
143   \textcolor{keywordflow}{if} (\hyperlink{group__encoder_gaade68a7d33d30f97dc9a596aa5e065d8}{aom\_codec\_enc\_init}(&codec, encoder->codec\_interface(), cfg, flags))
144     die\_codec(&codec, \textcolor{stringliteral}{"Failed to initialize encoder"});
145   \textcolor{keywordflow}{if} (\hyperlink{group__codec_ga6da974f4eeaba1fa74106b28d0fe6ac5}{aom\_codec\_control}(&codec, \hyperlink{group__aom__encoder_ggae78dde67a6d78f332e9bdba0dde42db5ac8a24393f214823f5a6bd345afb840b6}{AOME\_SET\_ENABLEAUTOALTREF}, 0))
146     die\_codec(&codec, \textcolor{stringliteral}{"Failed to turn off auto altref"});
147   \textcolor{keywordflow}{if} (\hyperlink{group__codec_ga6da974f4eeaba1fa74106b28d0fe6ac5}{aom\_codec\_control}(&codec, 
      \hyperlink{group__aom__encoder_ggae78dde67a6d78f332e9bdba0dde42db5a465382b6bbca24467739c3c1b94e6483}{AV1E\_SET\_FRAME\_PARALLEL\_DECODING}, 0))
148     die\_codec(&codec, \textcolor{stringliteral}{"Failed to set frame parallel decoding"});
149 
150   \textcolor{comment}{// How many reference images we need to encode.}
151   u\_blocks = (lf\_width + lf\_blocksize - 1) / lf\_blocksize;
152   v\_blocks = (lf\_height + lf\_blocksize - 1) / lf\_blocksize;
153 
154   printf(\textcolor{stringliteral}{"\(\backslash\)n First pass: "});
155 
156   \textcolor{keywordflow}{for} (bv = 0; bv < v\_blocks; ++bv) \{
157     \textcolor{keywordflow}{for} (bu = 0; bu < u\_blocks; ++bu) \{
158       \textcolor{keyword}{const} \textcolor{keywordtype}{int} block\_u\_min = bu * lf\_blocksize;
159       \textcolor{keyword}{const} \textcolor{keywordtype}{int} block\_v\_min = bv * lf\_blocksize;
160       \textcolor{keywordtype}{int} block\_u\_end = (bu + 1) * lf\_blocksize;
161       \textcolor{keywordtype}{int} block\_v\_end = (bv + 1) * lf\_blocksize;
162       \textcolor{keywordtype}{int} u\_block\_size, v\_block\_size;
163       \textcolor{keywordtype}{int} block\_ref\_u, block\_ref\_v;
164 
165       block\_u\_end = block\_u\_end < lf\_width ? block\_u\_end : lf\_width;
166       block\_v\_end = block\_v\_end < lf\_height ? block\_v\_end : lf\_height;
167       u\_block\_size = block\_u\_end - block\_u\_min;
168       v\_block\_size = block\_v\_end - block\_v\_min;
169       block\_ref\_u = block\_u\_min + u\_block\_size / 2;
170       block\_ref\_v = block\_v\_min + v\_block\_size / 2;
171 
172       printf(\textcolor{stringliteral}{"A%d, "}, (block\_ref\_u + block\_ref\_v * lf\_width));
173       fseek(infile, (block\_ref\_u + block\_ref\_v * lf\_width) * image\_size\_bytes,
174             SEEK\_SET);
175       aom\_img\_read(raw, infile);
176       get\_raw\_image(&frame\_to\_encode, raw, raw\_shift);
177 
178       \textcolor{comment}{// Reference frames can be encoded encoded without tiles.}
179       ++frame\_count;
180       get\_frame\_stats(&codec, frame\_to\_encode, frame\_count, 1,
181                       \hyperlink{group__aom__encoder_ga50c2560ca6670298cfc614ecae96a391}{AOM\_EFLAG\_NO\_REF\_LAST2} | 
      \hyperlink{group__aom__encoder_gaa4bc8ae2b977b73f0ef57ba428ca1d2c}{AOM\_EFLAG\_NO\_REF\_LAST3} |
182                           \hyperlink{group__aom__encoder_gaaef6fe76991abf87edd2f296eee999f8}{AOM\_EFLAG\_NO\_REF\_GF} | 
      \hyperlink{group__aom__encoder_ga9e2f989737d63ddf4e987a525d186a46}{AOM\_EFLAG\_NO\_REF\_ARF} |
183                           \hyperlink{group__aom__encoder_ga758649aa6cd9fefb15ad888489884a38}{AOM\_EFLAG\_NO\_REF\_BWD} | 
      \hyperlink{group__aom__encoder_gad04799a74215e1b9609f7ccd1766f8c9}{AOM\_EFLAG\_NO\_REF\_ARF2} |
184                           \hyperlink{group__aom__encoder_ga7a55a46970c074b761319c5c46d87b6e}{AOM\_EFLAG\_NO\_UPD\_LAST} | 
      \hyperlink{group__aom__encoder_gaa81cc31f95fd463f51a158050d267a36}{AOM\_EFLAG\_NO\_UPD\_GF} |
185                           \hyperlink{group__aom__encoder_ga469b4cf5ff76cb30de951e129c25a786}{AOM\_EFLAG\_NO\_UPD\_ARF},
186                       &stats);
187     \}
188   \}
189 
190   \textcolor{keywordflow}{if} (\hyperlink{group__codec_ga6da974f4eeaba1fa74106b28d0fe6ac5}{aom\_codec\_control}(&codec, 
      \hyperlink{group__aom__encoder_ggae78dde67a6d78f332e9bdba0dde42db5a465382b6bbca24467739c3c1b94e6483}{AV1E\_SET\_FRAME\_PARALLEL\_DECODING}, 1))
191     die\_codec(&codec, \textcolor{stringliteral}{"Failed to set frame parallel decoding"});
192 
193   \textcolor{keywordflow}{for} (bv = 0; bv < v\_blocks; ++bv) \{
194     \textcolor{keywordflow}{for} (bu = 0; bu < u\_blocks; ++bu) \{
195       \textcolor{keyword}{const} \textcolor{keywordtype}{int} block\_u\_min = bu * lf\_blocksize;
196       \textcolor{keyword}{const} \textcolor{keywordtype}{int} block\_v\_min = bv * lf\_blocksize;
197       \textcolor{keywordtype}{int} block\_u\_end = (bu + 1) * lf\_blocksize;
198       \textcolor{keywordtype}{int} block\_v\_end = (bv + 1) * lf\_blocksize;
199       \textcolor{keywordtype}{int} u, v;
200       block\_u\_end = block\_u\_end < lf\_width ? block\_u\_end : lf\_width;
201       block\_v\_end = block\_v\_end < lf\_height ? block\_v\_end : lf\_height;
202       \textcolor{keywordflow}{for} (v = block\_v\_min; v < block\_v\_end; ++v) \{
203         \textcolor{keywordflow}{for} (u = block\_u\_min; u < block\_u\_end; ++u) \{
204           printf(\textcolor{stringliteral}{"C%d, "}, (u + v * lf\_width));
205           fseek(infile, (u + v * lf\_width) * image\_size\_bytes, SEEK\_SET);
206           aom\_img\_read(raw, infile);
207           get\_raw\_image(&frame\_to\_encode, raw, raw\_shift);
208 
209           ++frame\_count;
210           get\_frame\_stats(&codec, frame\_to\_encode, frame\_count, 1,
211                           \hyperlink{group__aom__encoder_ga50c2560ca6670298cfc614ecae96a391}{AOM\_EFLAG\_NO\_REF\_LAST2} | 
      \hyperlink{group__aom__encoder_gaa4bc8ae2b977b73f0ef57ba428ca1d2c}{AOM\_EFLAG\_NO\_REF\_LAST3} |
212                               \hyperlink{group__aom__encoder_gaaef6fe76991abf87edd2f296eee999f8}{AOM\_EFLAG\_NO\_REF\_GF} | 
      \hyperlink{group__aom__encoder_ga9e2f989737d63ddf4e987a525d186a46}{AOM\_EFLAG\_NO\_REF\_ARF} |
213                               \hyperlink{group__aom__encoder_ga758649aa6cd9fefb15ad888489884a38}{AOM\_EFLAG\_NO\_REF\_BWD} | 
      \hyperlink{group__aom__encoder_gad04799a74215e1b9609f7ccd1766f8c9}{AOM\_EFLAG\_NO\_REF\_ARF2} |
214                               \hyperlink{group__aom__encoder_ga7a55a46970c074b761319c5c46d87b6e}{AOM\_EFLAG\_NO\_UPD\_LAST} | 
      \hyperlink{group__aom__encoder_gaa81cc31f95fd463f51a158050d267a36}{AOM\_EFLAG\_NO\_UPD\_GF} |
215                               \hyperlink{group__aom__encoder_ga469b4cf5ff76cb30de951e129c25a786}{AOM\_EFLAG\_NO\_UPD\_ARF} | 
      \hyperlink{group__aom__encoder_gac5a69f04b0bc88f755587a1da815d754}{AOM\_EFLAG\_NO\_UPD\_ENTROPY},
216                           &stats);
217         \}
218       \}
219     \}
220   \}
221   \textcolor{comment}{// Flush encoder.}
222   \textcolor{comment}{// No ARF, this should not be needed.}
223   \textcolor{keywordflow}{while} (get\_frame\_stats(&codec, NULL, frame\_count, 1, 0, &stats)) \{
224   \}
225 
226   \textcolor{keywordflow}{if} (\hyperlink{group__codec_ga9b60e186f61ba2d6ab2b8069b76a15c5}{aom\_codec\_destroy}(&codec)) die\_codec(&codec, \textcolor{stringliteral}{"Failed to destroy codec."});
227 
228   printf(\textcolor{stringliteral}{"\(\backslash\)nFirst pass complete. Processed %d frames.\(\backslash\)n"}, frame\_count);
229 
230   \textcolor{keywordflow}{return} stats;
231 \}
232 
233 \textcolor{keyword}{static} \textcolor{keywordtype}{void} pass1(\hyperlink{structaom__image}{aom\_image\_t} *raw, FILE *infile, \textcolor{keyword}{const} \textcolor{keywordtype}{char} *outfile\_name,
234                   \textcolor{keyword}{const} AvxInterface *encoder, \hyperlink{structaom__codec__enc__cfg}{aom\_codec\_enc\_cfg\_t} *cfg,
235                   \textcolor{keywordtype}{int} lf\_width, \textcolor{keywordtype}{int} lf\_height, \textcolor{keywordtype}{int} lf\_blocksize, \textcolor{keywordtype}{int} flags,
236                   \hyperlink{structaom__image}{aom\_image\_t} *raw\_shift) \{
237   AvxVideoInfo info = \{ encoder->fourcc,
238                         cfg->\hyperlink{structaom__codec__enc__cfg_a80cb459c5ef3c7e1516f617c4c9d6eab}{g\_w},
239                         cfg->\hyperlink{structaom__codec__enc__cfg_a37b0f57b63bec8d133df8901d4407ee6}{g\_h},
240                         \{ cfg->\hyperlink{structaom__codec__enc__cfg_a10664f1fc5b6ec29b77ee13efeeecdf7}{g\_timebase}.\hyperlink{structaom__rational_a7b48174411798c780a15f132c4650839}{num}, cfg->\hyperlink{structaom__codec__enc__cfg_a10664f1fc5b6ec29b77ee13efeeecdf7}{g\_timebase}.
      \hyperlink{structaom__rational_adeddf2ea01c12b7be66536e0a0fb92c5}{den} \},
241                         0 \};
242   AvxVideoWriter *writer = NULL;
243   \hyperlink{structaom__codec__ctx}{aom\_codec\_ctx\_t} codec;
244   \textcolor{keywordtype}{int} frame\_count = 0;
245   \textcolor{keywordtype}{int} image\_size\_bytes = aom\_img\_size\_bytes(raw);
246   \textcolor{keywordtype}{int} bu, bv;
247   \textcolor{keywordtype}{int} u\_blocks, v\_blocks;
248   \hyperlink{structaom__image}{aom\_image\_t} *frame\_to\_encode;
249   \hyperlink{structaom__image}{aom\_image\_t} reference\_images[MAX\_EXTERNAL\_REFERENCES];
250   \textcolor{keywordtype}{int} reference\_image\_num = 0;
251   \textcolor{keywordtype}{int} i;
252 
253   writer = aom\_video\_writer\_open(outfile\_name, kContainerIVF, &info);
254   \textcolor{keywordflow}{if} (!writer) die(\textcolor{stringliteral}{"Failed to open %s for writing"}, outfile\_name);
255 
256   \textcolor{keywordflow}{if} (\hyperlink{group__encoder_gaade68a7d33d30f97dc9a596aa5e065d8}{aom\_codec\_enc\_init}(&codec, encoder->codec\_interface(), cfg, flags))
257     die\_codec(&codec, \textcolor{stringliteral}{"Failed to initialize encoder"});
258   \textcolor{keywordflow}{if} (\hyperlink{group__codec_ga6da974f4eeaba1fa74106b28d0fe6ac5}{aom\_codec\_control}(&codec, \hyperlink{group__aom__encoder_ggae78dde67a6d78f332e9bdba0dde42db5ac8a24393f214823f5a6bd345afb840b6}{AOME\_SET\_ENABLEAUTOALTREF}, 0))
259     die\_codec(&codec, \textcolor{stringliteral}{"Failed to turn off auto altref"});
260   \textcolor{keywordflow}{if} (\hyperlink{group__codec_ga6da974f4eeaba1fa74106b28d0fe6ac5}{aom\_codec\_control}(&codec, 
      \hyperlink{group__aom__encoder_ggae78dde67a6d78f332e9bdba0dde42db5a465382b6bbca24467739c3c1b94e6483}{AV1E\_SET\_FRAME\_PARALLEL\_DECODING}, 0))
261     die\_codec(&codec, \textcolor{stringliteral}{"Failed to set frame parallel decoding"});
262   \textcolor{comment}{// Note: The superblock is a sequence parameter and has to be the same for 1}
263   \textcolor{comment}{// sequence. In lightfield application, must choose the superblock size(either}
264   \textcolor{comment}{// 64x64 or 128x128) before the encoding starts. Otherwise, the default is}
265   \textcolor{comment}{// AOM\_SUPERBLOCK\_SIZE\_DYNAMIC, and the superblock size will be set to 64x64}
266   \textcolor{comment}{// internally.}
267   \textcolor{keywordflow}{if} (\hyperlink{group__codec_ga6da974f4eeaba1fa74106b28d0fe6ac5}{aom\_codec\_control}(&codec, \hyperlink{group__aom__encoder_ggae78dde67a6d78f332e9bdba0dde42db5a8854a06c62269e866d6bac0f3a2e3dc2}{AV1E\_SET\_SUPERBLOCK\_SIZE},
268                         \hyperlink{group__codec_ggac34a24f7c6c0fef7518aed0da4425f61a5abd24080a18d4f7e33217d93a73e968}{AOM\_SUPERBLOCK\_SIZE\_64X64}))
269     die\_codec(&codec, \textcolor{stringliteral}{"Failed to set SB size"});
270 
271   u\_blocks = (lf\_width + lf\_blocksize - 1) / lf\_blocksize;
272   v\_blocks = (lf\_height + lf\_blocksize - 1) / lf\_blocksize;
273 
274   reference\_image\_num = u\_blocks * v\_blocks;
275   \hyperlink{aom__image_8h_ab71efff8c7f49380fad23b93bc2e9bfc}{aom\_img\_fmt\_t} ref\_fmt = \hyperlink{aom__image_8h_a930317c04b4bd0a660bb5e744055523cabd778a3d697463e89d12a1117f417b60}{AOM\_IMG\_FMT\_I420};
276   \textcolor{keywordflow}{if} (!CONFIG\_LOWBITDEPTH) ref\_fmt |= \hyperlink{aom__image_8h_a607b37d91f75442f54223ecd85f1b6cb}{AOM\_IMG\_FMT\_HIGHBITDEPTH};
277   \textcolor{comment}{// Allocate memory with the border so that it can be used as a reference.}
278   \textcolor{keywordtype}{int} border\_in\_pixels =
279       (codec.\hyperlink{structaom__codec__ctx_ac6777025d3b72c9ab49adba78fc70b30}{config}.enc->\hyperlink{structaom__codec__enc__cfg_ab9123d944cd168511d65c823b30d5705}{rc\_resize\_mode} || codec.\hyperlink{structaom__codec__ctx_ac6777025d3b72c9ab49adba78fc70b30}{config}.enc->
      \hyperlink{structaom__codec__enc__cfg_a704ff1b4202b1d5499928b98eef17424}{rc\_superres\_mode})
280           ? AOM\_BORDER\_IN\_PIXELS
281           : AOM\_ENC\_NO\_SCALE\_BORDER;
282   \textcolor{keywordflow}{for} (i = 0; i < reference\_image\_num; i++) \{
283     \textcolor{keywordflow}{if} (!\hyperlink{aom__image_8h_aeb211e5184687f7e10d7c5bed4dcfdcd}{aom\_img\_alloc\_with\_border}(&reference\_images[i], ref\_fmt, cfg->
      \hyperlink{structaom__codec__enc__cfg_a80cb459c5ef3c7e1516f617c4c9d6eab}{g\_w},
284                                    cfg->\hyperlink{structaom__codec__enc__cfg_a37b0f57b63bec8d133df8901d4407ee6}{g\_h}, 32, 8, border\_in\_pixels)) \{
285       die(\textcolor{stringliteral}{"Failed to allocate image."});
286     \}
287   \}
288 
289   printf(\textcolor{stringliteral}{"\(\backslash\)n Second pass: "});
290 
291   \textcolor{comment}{// Encode reference images first.}
292   printf(\textcolor{stringliteral}{"Encoding Reference Images\(\backslash\)n"});
293   \textcolor{keywordflow}{for} (bv = 0; bv < v\_blocks; ++bv) \{
294     \textcolor{keywordflow}{for} (bu = 0; bu < u\_blocks; ++bu) \{
295       \textcolor{keyword}{const} \textcolor{keywordtype}{int} block\_u\_min = bu * lf\_blocksize;
296       \textcolor{keyword}{const} \textcolor{keywordtype}{int} block\_v\_min = bv * lf\_blocksize;
297       \textcolor{keywordtype}{int} block\_u\_end = (bu + 1) * lf\_blocksize;
298       \textcolor{keywordtype}{int} block\_v\_end = (bv + 1) * lf\_blocksize;
299       \textcolor{keywordtype}{int} u\_block\_size, v\_block\_size;
300       \textcolor{keywordtype}{int} block\_ref\_u, block\_ref\_v;
301 
302       block\_u\_end = block\_u\_end < lf\_width ? block\_u\_end : lf\_width;
303       block\_v\_end = block\_v\_end < lf\_height ? block\_v\_end : lf\_height;
304       u\_block\_size = block\_u\_end - block\_u\_min;
305       v\_block\_size = block\_v\_end - block\_v\_min;
306       block\_ref\_u = block\_u\_min + u\_block\_size / 2;
307       block\_ref\_v = block\_v\_min + v\_block\_size / 2;
308 
309       printf(\textcolor{stringliteral}{"A%d, "}, (block\_ref\_u + block\_ref\_v * lf\_width));
310       fseek(infile, (block\_ref\_u + block\_ref\_v * lf\_width) * image\_size\_bytes,
311             SEEK\_SET);
312       aom\_img\_read(raw, infile);
313 
314       get\_raw\_image(&frame\_to\_encode, raw, raw\_shift);
315 
316       \textcolor{comment}{// Reference frames may be encoded without tiles.}
317       ++frame\_count;
318       printf(\textcolor{stringliteral}{"Encoding reference image %d of %d\(\backslash\)n"}, bv * u\_blocks + bu,
319              u\_blocks * v\_blocks);
320       encode\_frame(&codec, frame\_to\_encode, frame\_count, 1,
321                    \hyperlink{group__aom__encoder_ga50c2560ca6670298cfc614ecae96a391}{AOM\_EFLAG\_NO\_REF\_LAST2} | 
      \hyperlink{group__aom__encoder_gaa4bc8ae2b977b73f0ef57ba428ca1d2c}{AOM\_EFLAG\_NO\_REF\_LAST3} |
322                        \hyperlink{group__aom__encoder_gaaef6fe76991abf87edd2f296eee999f8}{AOM\_EFLAG\_NO\_REF\_GF} | 
      \hyperlink{group__aom__encoder_ga9e2f989737d63ddf4e987a525d186a46}{AOM\_EFLAG\_NO\_REF\_ARF} |
323                        \hyperlink{group__aom__encoder_ga758649aa6cd9fefb15ad888489884a38}{AOM\_EFLAG\_NO\_REF\_BWD} | 
      \hyperlink{group__aom__encoder_gad04799a74215e1b9609f7ccd1766f8c9}{AOM\_EFLAG\_NO\_REF\_ARF2} |
324                        \hyperlink{group__aom__encoder_ga7a55a46970c074b761319c5c46d87b6e}{AOM\_EFLAG\_NO\_UPD\_LAST} | 
      \hyperlink{group__aom__encoder_gaa81cc31f95fd463f51a158050d267a36}{AOM\_EFLAG\_NO\_UPD\_GF} |
325                        \hyperlink{group__aom__encoder_ga469b4cf5ff76cb30de951e129c25a786}{AOM\_EFLAG\_NO\_UPD\_ARF} | 
      \hyperlink{group__aom__encoder_gac5a69f04b0bc88f755587a1da815d754}{AOM\_EFLAG\_NO\_UPD\_ENTROPY},
326                    writer);
327 
328       \textcolor{keywordflow}{if} (\hyperlink{group__codec_ga6da974f4eeaba1fa74106b28d0fe6ac5}{aom\_codec\_control}(&codec, \hyperlink{group__aom_gga9421a1fa78c0d9587ae5aa6c1cb3d659ae41763622ee33cd99e23ca8f78a3f8fa}{AV1\_COPY\_NEW\_FRAME\_IMAGE},
329                             &reference\_images[frame\_count - 1]))
330         die\_codec(&codec, \textcolor{stringliteral}{"Failed to copy decoder reference frame"});
331     \}
332   \}
333 
334   cfg->\hyperlink{structaom__codec__enc__cfg_af4583da6c145778f822a4a61db28c40a}{large\_scale\_tile} = 1;
335   \textcolor{comment}{// Fixed q encoding for camera frames.}
336   cfg->\hyperlink{structaom__codec__enc__cfg_a3fd74d888658039d09bc4eacf163a495}{rc\_end\_usage} = \hyperlink{group__encoder_gga7c084d3ecef569aad166ce70b0e8a957aff3bbd4fe870b4b946c2093e59eb14e5}{AOM\_Q};
337   \textcolor{keywordflow}{if} (\hyperlink{group__encoder_gaf4a4c3c3c91dd92c960990f6e534271d}{aom\_codec\_enc\_config\_set}(&codec, cfg))
338     die\_codec(&codec, \textcolor{stringliteral}{"Failed to configure encoder"});
339 
340   \textcolor{comment}{// The fixed q value used in encoding.}
341   \textcolor{keywordflow}{if} (\hyperlink{group__codec_ga6da974f4eeaba1fa74106b28d0fe6ac5}{aom\_codec\_control}(&codec, \hyperlink{group__aom__encoder_ggae78dde67a6d78f332e9bdba0dde42db5af67f265bf63bf8f1268b3a14ae26606c}{AOME\_SET\_CQ\_LEVEL}, 36))
342     die\_codec(&codec, \textcolor{stringliteral}{"Failed to set cq level"});
343   \textcolor{keywordflow}{if} (\hyperlink{group__codec_ga6da974f4eeaba1fa74106b28d0fe6ac5}{aom\_codec\_control}(&codec, 
      \hyperlink{group__aom__encoder_ggae78dde67a6d78f332e9bdba0dde42db5a465382b6bbca24467739c3c1b94e6483}{AV1E\_SET\_FRAME\_PARALLEL\_DECODING}, 1))
344     die\_codec(&codec, \textcolor{stringliteral}{"Failed to set frame parallel decoding"});
345   \textcolor{keywordflow}{if} (\hyperlink{group__codec_ga6da974f4eeaba1fa74106b28d0fe6ac5}{aom\_codec\_control}(&codec, \hyperlink{group__aom__encoder_ggae78dde67a6d78f332e9bdba0dde42db5af341538631ffe2ac2b562c8b5336a10a}{AV1E\_SET\_SINGLE\_TILE\_DECODING}
      , 1))
346     die\_codec(&codec, \textcolor{stringliteral}{"Failed to turn on single tile decoding"});
347   \textcolor{comment}{// Set tile\_columns and tile\_rows to MAX values, which guarantees the tile}
348   \textcolor{comment}{// size of 64 x 64 pixels(i.e. 1 SB) for <= 4k resolution.}
349   \textcolor{keywordflow}{if} (\hyperlink{group__codec_ga6da974f4eeaba1fa74106b28d0fe6ac5}{aom\_codec\_control}(&codec, \hyperlink{group__aom__encoder_ggae78dde67a6d78f332e9bdba0dde42db5acf4ab1ff2fa8d76a78881ad7f1a1294d}{AV1E\_SET\_TILE\_COLUMNS}, 6))
350     die\_codec(&codec, \textcolor{stringliteral}{"Failed to set tile width"});
351   \textcolor{keywordflow}{if} (\hyperlink{group__codec_ga6da974f4eeaba1fa74106b28d0fe6ac5}{aom\_codec\_control}(&codec, \hyperlink{group__aom__encoder_ggae78dde67a6d78f332e9bdba0dde42db5a57f2f2a54f593b398a5e97db7982f817}{AV1E\_SET\_TILE\_ROWS}, 6))
352     die\_codec(&codec, \textcolor{stringliteral}{"Failed to set tile height"});
353 
354   \textcolor{keywordflow}{for} (bv = 0; bv < v\_blocks; ++bv) \{
355     \textcolor{keywordflow}{for} (bu = 0; bu < u\_blocks; ++bu) \{
356       \textcolor{keyword}{const} \textcolor{keywordtype}{int} block\_u\_min = bu * lf\_blocksize;
357       \textcolor{keyword}{const} \textcolor{keywordtype}{int} block\_v\_min = bv * lf\_blocksize;
358       \textcolor{keywordtype}{int} block\_u\_end = (bu + 1) * lf\_blocksize;
359       \textcolor{keywordtype}{int} block\_v\_end = (bv + 1) * lf\_blocksize;
360       \textcolor{keywordtype}{int} u, v;
361       block\_u\_end = block\_u\_end < lf\_width ? block\_u\_end : lf\_width;
362       block\_v\_end = block\_v\_end < lf\_height ? block\_v\_end : lf\_height;
363       \textcolor{keywordflow}{for} (v = block\_v\_min; v < block\_v\_end; ++v) \{
364         \textcolor{keywordflow}{for} (u = block\_u\_min; u < block\_u\_end; ++u) \{
365           \hyperlink{structav1__ref__frame}{av1\_ref\_frame\_t} ref;
366           ref.\hyperlink{structav1__ref__frame_a7c6fcaba58f514985448cb2e2245345c}{idx} = 0;
367           ref.\hyperlink{structav1__ref__frame_a33749c5c20033cc5f7582d0ec1c34ff0}{use\_external\_ref} = 1;
368           ref.\hyperlink{structav1__ref__frame_a55a09db9e1acdd73e656b01fa01283b3}{img} = reference\_images[bv * u\_blocks + bu];
369           \textcolor{keywordflow}{if} (\hyperlink{group__codec_ga6da974f4eeaba1fa74106b28d0fe6ac5}{aom\_codec\_control}(&codec, \hyperlink{group__aom_gga9421a1fa78c0d9587ae5aa6c1cb3d659a51ad4467b4dc318406cceb257e2daa41}{AV1\_SET\_REFERENCE}, &ref))
370             die\_codec(&codec, \textcolor{stringliteral}{"Failed to set reference frame"});
371 
372           printf(\textcolor{stringliteral}{"C%d, "}, (u + v * lf\_width));
373           fseek(infile, (u + v * lf\_width) * image\_size\_bytes, SEEK\_SET);
374           aom\_img\_read(raw, infile);
375           get\_raw\_image(&frame\_to\_encode, raw, raw\_shift);
376 
377           ++frame\_count;
378           printf(\textcolor{stringliteral}{"Encoding image %d of %d\(\backslash\)n"},
379                  frame\_count - (u\_blocks * v\_blocks), lf\_width * lf\_height);
380           encode\_frame(&codec, frame\_to\_encode, frame\_count, 1,
381                        \hyperlink{group__aom__encoder_ga50c2560ca6670298cfc614ecae96a391}{AOM\_EFLAG\_NO\_REF\_LAST2} | 
      \hyperlink{group__aom__encoder_gaa4bc8ae2b977b73f0ef57ba428ca1d2c}{AOM\_EFLAG\_NO\_REF\_LAST3} |
382                            \hyperlink{group__aom__encoder_gaaef6fe76991abf87edd2f296eee999f8}{AOM\_EFLAG\_NO\_REF\_GF} | 
      \hyperlink{group__aom__encoder_ga9e2f989737d63ddf4e987a525d186a46}{AOM\_EFLAG\_NO\_REF\_ARF} |
383                            \hyperlink{group__aom__encoder_ga758649aa6cd9fefb15ad888489884a38}{AOM\_EFLAG\_NO\_REF\_BWD} | 
      \hyperlink{group__aom__encoder_gad04799a74215e1b9609f7ccd1766f8c9}{AOM\_EFLAG\_NO\_REF\_ARF2} |
384                            \hyperlink{group__aom__encoder_ga7a55a46970c074b761319c5c46d87b6e}{AOM\_EFLAG\_NO\_UPD\_LAST} | 
      \hyperlink{group__aom__encoder_gaa81cc31f95fd463f51a158050d267a36}{AOM\_EFLAG\_NO\_UPD\_GF} |
385                            \hyperlink{group__aom__encoder_ga469b4cf5ff76cb30de951e129c25a786}{AOM\_EFLAG\_NO\_UPD\_ARF} | 
      \hyperlink{group__aom__encoder_gac5a69f04b0bc88f755587a1da815d754}{AOM\_EFLAG\_NO\_UPD\_ENTROPY},
386                        writer);
387         \}
388       \}
389     \}
390   \}
391 
392   \textcolor{comment}{// Flush encoder.}
393   \textcolor{comment}{// No ARF, this should not be needed.}
394   \textcolor{keywordflow}{while} (encode\_frame(&codec, NULL, -1, 1, 0, writer)) \{
395   \}
396 
397   \textcolor{keywordflow}{for} (i = 0; i < reference\_image\_num; i++) \hyperlink{aom__image_8h_afff22f7f3eb9409c5b678d1962f110a8}{aom\_img\_free}(&reference\_images[i]);
398 
399   \textcolor{keywordflow}{if} (\hyperlink{group__codec_ga9b60e186f61ba2d6ab2b8069b76a15c5}{aom\_codec\_destroy}(&codec)) die\_codec(&codec, \textcolor{stringliteral}{"Failed to destroy codec."});
400   aom\_video\_writer\_close(writer);
401 
402   printf(\textcolor{stringliteral}{"\(\backslash\)nSecond pass complete. Processed %d frames.\(\backslash\)n"}, frame\_count);
403 \}
404 
405 \textcolor{keywordtype}{int} main(\textcolor{keywordtype}{int} argc, \textcolor{keywordtype}{char} **argv) \{
406   FILE *infile = NULL;
407   \textcolor{keywordtype}{int} w, h;
408   \textcolor{comment}{// The number of lightfield images in the u and v dimensions.}
409   \textcolor{keywordtype}{int} lf\_width, lf\_height;
410   \textcolor{comment}{// Defines how many images refer to the same reference image for MCP.}
411   \textcolor{comment}{// lf\_blocksize X lf\_blocksize images will all use the reference image}
412   \textcolor{comment}{// in the middle of the block of images.}
413   \textcolor{keywordtype}{int} lf\_blocksize;
414   \hyperlink{structaom__codec__ctx}{aom\_codec\_ctx\_t} codec;
415   \hyperlink{structaom__codec__enc__cfg}{aom\_codec\_enc\_cfg\_t} cfg;
416   \hyperlink{structaom__image}{aom\_image\_t} raw;
417   \hyperlink{structaom__image}{aom\_image\_t} raw\_shift;
418   \hyperlink{group__codec_gaaae61e0f8663e6137f1e228757248e7c}{aom\_codec\_err\_t} res;
419   \hyperlink{structaom__fixed__buf}{aom\_fixed\_buf\_t} stats;
420   \textcolor{keywordtype}{int} flags = 0;
421 
422   \textcolor{keyword}{const} AvxInterface *encoder = NULL;
423   \textcolor{keyword}{const} \textcolor{keywordtype}{int} fps = 30;
424   \textcolor{keyword}{const} \textcolor{keywordtype}{int} bitrate = 200;  \textcolor{comment}{// kbit/s}
425   \textcolor{keyword}{const} \textcolor{keywordtype}{char} *\textcolor{keyword}{const} width\_arg = argv[1];
426   \textcolor{keyword}{const} \textcolor{keywordtype}{char} *\textcolor{keyword}{const} height\_arg = argv[2];
427   \textcolor{keyword}{const} \textcolor{keywordtype}{char} *\textcolor{keyword}{const} infile\_arg = argv[3];
428   \textcolor{keyword}{const} \textcolor{keywordtype}{char} *\textcolor{keyword}{const} outfile\_arg = argv[4];
429   \textcolor{keyword}{const} \textcolor{keywordtype}{char} *\textcolor{keyword}{const} lf\_width\_arg = argv[5];
430   \textcolor{keyword}{const} \textcolor{keywordtype}{char} *\textcolor{keyword}{const} lf\_height\_arg = argv[6];
431   \textcolor{keyword}{const} \textcolor{keywordtype}{char} *lf\_blocksize\_arg = argv[7];
432   exec\_name = argv[0];
433 
434   \textcolor{keywordflow}{if} (argc < 8) die(\textcolor{stringliteral}{"Invalid number of arguments"});
435 
436   encoder = get\_aom\_encoder\_by\_name(\textcolor{stringliteral}{"av1"});
437   \textcolor{keywordflow}{if} (!encoder) die(\textcolor{stringliteral}{"Unsupported codec."});
438 
439   w = (int)strtol(width\_arg, NULL, 0);
440   h = (int)strtol(height\_arg, NULL, 0);
441   lf\_width = (int)strtol(lf\_width\_arg, NULL, 0);
442   lf\_height = (int)strtol(lf\_height\_arg, NULL, 0);
443   lf\_blocksize = (int)strtol(lf\_blocksize\_arg, NULL, 0);
444   lf\_blocksize = lf\_blocksize < lf\_width ? lf\_blocksize : lf\_width;
445   lf\_blocksize = lf\_blocksize < lf\_height ? lf\_blocksize : lf\_height;
446 
447   \textcolor{keywordflow}{if} (w <= 0 || h <= 0 || (w % 2) != 0 || (h % 2) != 0)
448     die(\textcolor{stringliteral}{"Invalid frame size: %dx%d"}, w, h);
449   \textcolor{keywordflow}{if} (lf\_width <= 0 || lf\_height <= 0)
450     die(\textcolor{stringliteral}{"Invalid lf\_width and/or lf\_height: %dx%d"}, lf\_width, lf\_height);
451   \textcolor{keywordflow}{if} (lf\_blocksize <= 0) die(\textcolor{stringliteral}{"Invalid lf\_blocksize: %d"}, lf\_blocksize);
452 
453   \textcolor{keywordflow}{if} (!\hyperlink{aom__image_8h_a570db29fbd122951235a08fe9375f6bb}{aom\_img\_alloc}(&raw, \hyperlink{aom__image_8h_a930317c04b4bd0a660bb5e744055523cabd778a3d697463e89d12a1117f417b60}{AOM\_IMG\_FMT\_I420}, w, h, 32)) \{
454     die(\textcolor{stringliteral}{"Failed to allocate image."});
455   \}
456   \textcolor{keywordflow}{if} (!CONFIG\_LOWBITDEPTH) \{
457     \textcolor{comment}{// Need to allocate larger buffer to use hbd internal.}
458     \hyperlink{aom__image_8h_a570db29fbd122951235a08fe9375f6bb}{aom\_img\_alloc}(&raw\_shift, \hyperlink{aom__image_8h_a930317c04b4bd0a660bb5e744055523cabd778a3d697463e89d12a1117f417b60}{AOM\_IMG\_FMT\_I420} | 
      \hyperlink{aom__image_8h_a607b37d91f75442f54223ecd85f1b6cb}{AOM\_IMG\_FMT\_HIGHBITDEPTH}, w, h,
459                   32);
460   \}
461 
462   printf(\textcolor{stringliteral}{"Using %s\(\backslash\)n"}, \hyperlink{group__codec_ga013b1f6d96b2cf9489396311a7e5179b}{aom\_codec\_iface\_name}(encoder->codec\_interface()));
463 
464   \textcolor{comment}{// Configuration}
465   res = \hyperlink{group__encoder_gabe456ab6f99bdebc47018779b75d2521}{aom\_codec\_enc\_config\_default}(encoder->codec\_interface(), &cfg, 0);
466   \textcolor{keywordflow}{if} (res) die\_codec(&codec, \textcolor{stringliteral}{"Failed to get default codec config."});
467 
468   cfg.\hyperlink{structaom__codec__enc__cfg_a80cb459c5ef3c7e1516f617c4c9d6eab}{g\_w} = w;
469   cfg.\hyperlink{structaom__codec__enc__cfg_a37b0f57b63bec8d133df8901d4407ee6}{g\_h} = h;
470   cfg.\hyperlink{structaom__codec__enc__cfg_a10664f1fc5b6ec29b77ee13efeeecdf7}{g\_timebase}.\hyperlink{structaom__rational_a7b48174411798c780a15f132c4650839}{num} = 1;
471   cfg.\hyperlink{structaom__codec__enc__cfg_a10664f1fc5b6ec29b77ee13efeeecdf7}{g\_timebase}.\hyperlink{structaom__rational_adeddf2ea01c12b7be66536e0a0fb92c5}{den} = fps;
472   cfg.\hyperlink{structaom__codec__enc__cfg_ab21539da477dba7506d90353c27d218b}{rc\_target\_bitrate} = bitrate;
473   cfg.\hyperlink{structaom__codec__enc__cfg_a8f3763485bb1f6eea6466b2fe0da2304}{g\_error\_resilient} = 0;  \textcolor{comment}{// This is required.}
474   cfg.\hyperlink{structaom__codec__enc__cfg_a614a49318f2011cc8735d7e51b910fa4}{g\_lag\_in\_frames} = 0;    \textcolor{comment}{// need to set this since default is 19.}
475   cfg.\hyperlink{structaom__codec__enc__cfg_a3c1ea7f3ea90b9b8eab4c3f266ffacdc}{kf\_mode} = \hyperlink{group__encoder_ggac0498fc02cd368e6d9675cdb0bab5a84af81473ffe0169271763f9c9d05393405}{AOM\_KF\_DISABLED};
476   cfg.\hyperlink{structaom__codec__enc__cfg_af4583da6c145778f822a4a61db28c40a}{large\_scale\_tile} = 0;  \textcolor{comment}{// Only set it to 1 for camera frame encoding.}
477   cfg.\hyperlink{structaom__codec__enc__cfg_a76a27f44cded1516803a776a0a7e9038}{g\_bit\_depth} = \hyperlink{group__codec_gga6ed0e98eba4651c1ad845e39498e4153a4c7f55539160206a3fbb2a6cfc9ef89c}{AOM\_BITS\_8};
478   flags |= (cfg.\hyperlink{structaom__codec__enc__cfg_a76a27f44cded1516803a776a0a7e9038}{g\_bit\_depth} > \hyperlink{group__codec_gga6ed0e98eba4651c1ad845e39498e4153a4c7f55539160206a3fbb2a6cfc9ef89c}{AOM\_BITS\_8} || !CONFIG\_LOWBITDEPTH)
479                ? \hyperlink{group__encoder_gae30bbbdef18e9da3631b69c170533e92}{AOM\_CODEC\_USE\_HIGHBITDEPTH}
480                : 0;
481 
482   \textcolor{keywordflow}{if} (!(infile = fopen(infile\_arg, \textcolor{stringliteral}{"rb"})))
483     die(\textcolor{stringliteral}{"Failed to open %s for reading"}, infile\_arg);
484 
485   \textcolor{comment}{// Pass 0}
486   cfg.\hyperlink{structaom__codec__enc__cfg_aad58e4d10c7904d50ce959aef202dc64}{g\_pass} = \hyperlink{group__encoder_gga92b6709b58dc3435e3ba652da562eda1ad342b33a290482c20238bfde5d9bea1e}{AOM\_RC\_FIRST\_PASS};
487   stats = pass0(&raw, infile, encoder, &cfg, lf\_width, lf\_height, lf\_blocksize,
488                 flags, &raw\_shift);
489 
490   \textcolor{comment}{// Pass 1}
491   rewind(infile);
492   cfg.\hyperlink{structaom__codec__enc__cfg_aad58e4d10c7904d50ce959aef202dc64}{g\_pass} = \hyperlink{group__encoder_gga92b6709b58dc3435e3ba652da562eda1a621c3f07937527618dc06e962425f6cc}{AOM\_RC\_LAST\_PASS};
493   cfg.\hyperlink{structaom__codec__enc__cfg_ad5c6f5c96ec54cabc71edb01045a1f04}{rc\_twopass\_stats\_in} = stats;
494   pass1(&raw, infile, outfile\_arg, encoder, &cfg, lf\_width, lf\_height,
495         lf\_blocksize, flags, &raw\_shift);
496   free(stats.\hyperlink{structaom__fixed__buf_ac1b22da152c9839329d3780208dffd38}{buf});
497 
498   \textcolor{keywordflow}{if} (!CONFIG\_LOWBITDEPTH) \hyperlink{aom__image_8h_afff22f7f3eb9409c5b678d1962f110a8}{aom\_img\_free}(&raw\_shift);
499   \hyperlink{aom__image_8h_afff22f7f3eb9409c5b678d1962f110a8}{aom\_img\_free}(&raw);
500   fclose(infile);
501 
502   \textcolor{keywordflow}{return} EXIT\_SUCCESS;
503 \}
\end{DoxyCodeInclude}
 \hypertarget{example_lightfield_tile_list_decoder}{}\subsection{lightfield\+\_\+tile\+\_\+list\+\_\+decoder}\label{example_lightfield_tile_list_decoder}

\begin{DoxyCodeInclude}
1 \textcolor{comment}{/*}
2 \textcolor{comment}{ * Copyright (c) 2018, Alliance for Open Media. All rights reserved}
3 \textcolor{comment}{ *}
4 \textcolor{comment}{ * This source code is subject to the terms of the BSD 2 Clause License and}
5 \textcolor{comment}{ * the Alliance for Open Media Patent License 1.0. If the BSD 2 Clause License}
6 \textcolor{comment}{ * was not distributed with this source code in the LICENSE file, you can}
7 \textcolor{comment}{ * obtain it at www.aomedia.org/license/software. If the Alliance for Open}
8 \textcolor{comment}{ * Media Patent License 1.0 was not distributed with this source code in the}
9 \textcolor{comment}{ * PATENTS file, you can obtain it at www.aomedia.org/license/patent.}
10 \textcolor{comment}{ */}
11 
12 \textcolor{comment}{// Lightfield Tile List Decoder}
13 \textcolor{comment}{// ============================}
14 \textcolor{comment}{//}
15 \textcolor{comment}{// This is a lightfield tile list decoder example. It takes an input file that}
16 \textcolor{comment}{// contains the anchor frames that are references of the coded tiles, the camera}
17 \textcolor{comment}{// frame header, and tile list OBUs that include the tile information and the}
18 \textcolor{comment}{// compressed tile data. This input file is reconstructed from the encoded}
19 \textcolor{comment}{// lightfield ivf file, and is decodable by AV1 decoder. num\_references is}
20 \textcolor{comment}{// the number of anchor frames coded at the beginning of the light field file.}
21 \textcolor{comment}{// num\_tile\_lists is the number of tile lists need to be decoded. There is an}
22 \textcolor{comment}{// optional parameter allowing to choose the output format, and the supported}
23 \textcolor{comment}{// formats are YUV1D(default), YUV, and NV12.}
24 \textcolor{comment}{// Run lightfield tile list decoder to decode an AV1 tile list file:}
25 \textcolor{comment}{// examples/lightfield\_tile\_list\_decoder vase\_tile\_list.ivf vase\_tile\_list.yuv}
26 \textcolor{comment}{// 4 2 0(optional)}
27 
28 \textcolor{preprocessor}{#include <stdio.h>}
29 \textcolor{preprocessor}{#include <stdlib.h>}
30 \textcolor{preprocessor}{#include <string.h>}
31 \textcolor{preprocessor}{#include <assert.h>}
32 
33 \textcolor{preprocessor}{#include "\hyperlink{aom__decoder_8h}{aom/aom\_decoder.h}"}
34 \textcolor{preprocessor}{#include "\hyperlink{aomdx_8h}{aom/aomdx.h}"}
35 \textcolor{preprocessor}{#include "aom\_scale/yv12config.h"}
36 \textcolor{preprocessor}{#include "av1/common/enums.h"}
37 \textcolor{preprocessor}{#include "common/tools\_common.h"}
38 \textcolor{preprocessor}{#include "common/video\_reader.h"}
39 
40 \textcolor{keyword}{static} \textcolor{keyword}{const} \textcolor{keywordtype}{char} *exec\_name;
41 
42 \textcolor{keywordtype}{void} usage\_exit(\textcolor{keywordtype}{void}) \{
43   fprintf(stderr,
44           \textcolor{stringliteral}{"Usage: %s <infile> <outfile> <num\_references> <num\_tile\_lists> "}
45           \textcolor{stringliteral}{"<output format(optional)>\(\backslash\)n"},
46           exec\_name);
47   exit(EXIT\_FAILURE);
48 \}
49 
50 \textcolor{keyword}{static} \textcolor{keywordtype}{void} write\_tile\_yuv1d(\hyperlink{structaom__codec__ctx}{aom\_codec\_ctx\_t} *codec, \textcolor{keyword}{const} 
      \hyperlink{structaom__image}{aom\_image\_t} *img,
51                              FILE *file) \{
52   \textcolor{comment}{// read out the tile size.}
53   \textcolor{keywordtype}{unsigned} \textcolor{keywordtype}{int} tile\_size = 0;
54   \textcolor{keywordflow}{if} (\hyperlink{group__codec_ga6da974f4eeaba1fa74106b28d0fe6ac5}{aom\_codec\_control}(codec, \hyperlink{group__aom__decoder_gga3865fd4b3192489baa9a5c3632ebe97ba4d9799d9e520785870b8d1f73a19c3c4}{AV1D\_GET\_TILE\_SIZE}, &tile\_size))
55     die\_codec(codec, \textcolor{stringliteral}{"Failed to get the tile size"});
56   \textcolor{keyword}{const} \textcolor{keywordtype}{unsigned} \textcolor{keywordtype}{int} tile\_width = tile\_size >> 16;
57   \textcolor{keyword}{const} \textcolor{keywordtype}{unsigned} \textcolor{keywordtype}{int} tile\_height = tile\_size & 65535;
58   \textcolor{keyword}{const} uint8\_t output\_frame\_width\_in\_tiles = img->\hyperlink{structaom__image_a89f80b1f58d608b9d2080635f4359034}{d\_w} / tile\_width;
59 
60   \textcolor{keywordtype}{unsigned} \textcolor{keywordtype}{int} tile\_count = 0;
61   \textcolor{keywordflow}{if} (\hyperlink{group__codec_ga6da974f4eeaba1fa74106b28d0fe6ac5}{aom\_codec\_control}(codec, \hyperlink{group__aom__decoder_gga3865fd4b3192489baa9a5c3632ebe97ba242d7dba47ef646f51f9795e2fa92f91}{AV1D\_GET\_TILE\_COUNT}, &tile\_count))
62     die\_codec(codec, \textcolor{stringliteral}{"Failed to get the tile size"});
63 
64   \textcolor{comment}{// Write tile to file.}
65   \textcolor{keyword}{const} \textcolor{keywordtype}{int} shift = (img->\hyperlink{structaom__image_a6c64b1ab918d80d52eb8f5d6d957e825}{fmt} & \hyperlink{aom__image_8h_a607b37d91f75442f54223ecd85f1b6cb}{AOM\_IMG\_FMT\_HIGHBITDEPTH}) ? 1 : 0;
66   \textcolor{keywordtype}{unsigned} \textcolor{keywordtype}{int} tile\_idx;
67 
68   \textcolor{keywordflow}{for} (tile\_idx = 0; tile\_idx < tile\_count; ++tile\_idx) \{
69     \textcolor{keyword}{const} \textcolor{keywordtype}{int} row\_offset =
70         (tile\_idx / output\_frame\_width\_in\_tiles) * tile\_height;
71     \textcolor{keyword}{const} \textcolor{keywordtype}{int} col\_offset =
72         (tile\_idx % output\_frame\_width\_in\_tiles) * tile\_width;
73     \textcolor{keywordtype}{int} plane;
74 
75     \textcolor{keywordflow}{for} (plane = 0; plane < 3; ++plane) \{
76       \textcolor{keyword}{const} \textcolor{keywordtype}{unsigned} \textcolor{keywordtype}{char} *buf = img->\hyperlink{structaom__image_ac54dbc5237ca2914f9ec30105dfbe302}{planes}[plane];
77       \textcolor{keyword}{const} \textcolor{keywordtype}{int} stride = img->\hyperlink{structaom__image_a6dc693d7dbc9eb06c0cdde307ca58372}{stride}[plane];
78       \textcolor{keyword}{const} \textcolor{keywordtype}{int} roffset =
79           (plane > 0) ? row\_offset >> img->\hyperlink{structaom__image_a5acfc850c272e1377f3b7d58a95f3749}{y\_chroma\_shift} : row\_offset;
80       \textcolor{keyword}{const} \textcolor{keywordtype}{int} coffset =
81           (plane > 0) ? col\_offset >> img->\hyperlink{structaom__image_a83fdb3677275dc0e1e38701000447214}{x\_chroma\_shift} : col\_offset;
82       \textcolor{keyword}{const} \textcolor{keywordtype}{int} w = (plane > 0) ? ((tile\_width >> img->\hyperlink{structaom__image_a83fdb3677275dc0e1e38701000447214}{x\_chroma\_shift}) << shift)
83                                 : (tile\_width << shift);
84       \textcolor{keyword}{const} \textcolor{keywordtype}{int} h =
85           (plane > 0) ? (tile\_height >> img->\hyperlink{structaom__image_a5acfc850c272e1377f3b7d58a95f3749}{y\_chroma\_shift}) : tile\_height;
86       \textcolor{keywordtype}{int} y;
87 
88       \textcolor{comment}{// col offset needs to be adjusted for HBD.}
89       buf += roffset * stride + (coffset << shift);
90 
91       \textcolor{keywordflow}{for} (y = 0; y < h; ++y) \{
92         fwrite(buf, 1, w, file);
93         buf += stride;
94       \}
95     \}
96   \}
97 \}
98 
99 \textcolor{keywordtype}{int} main(\textcolor{keywordtype}{int} argc, \textcolor{keywordtype}{char} **argv) \{
100   FILE *outfile = NULL;
101   \hyperlink{structaom__codec__ctx}{aom\_codec\_ctx\_t} codec;
102   AvxVideoReader *reader = NULL;
103   \textcolor{keyword}{const} AvxInterface *decoder = NULL;
104   \textcolor{keyword}{const} AvxVideoInfo *info = NULL;
105   \textcolor{keywordtype}{int} num\_references;
106   \textcolor{keywordtype}{int} num\_tile\_lists;
107   \hyperlink{structaom__image}{aom\_image\_t} reference\_images[MAX\_EXTERNAL\_REFERENCES];
108   \textcolor{keywordtype}{size\_t} frame\_size = 0;
109   \textcolor{keyword}{const} \textcolor{keywordtype}{unsigned} \textcolor{keywordtype}{char} *frame = NULL;
110   \textcolor{keywordtype}{int} output\_format = YUV1D;
111   \textcolor{keywordtype}{int} i, j, n;
112 
113   exec\_name = argv[0];
114 
115   \textcolor{keywordflow}{if} (argc < 5) die(\textcolor{stringliteral}{"Invalid number of arguments."});
116 
117   reader = aom\_video\_reader\_open(argv[1]);
118   \textcolor{keywordflow}{if} (!reader) die(\textcolor{stringliteral}{"Failed to open %s for reading."}, argv[1]);
119 
120   \textcolor{keywordflow}{if} (!(outfile = fopen(argv[2], \textcolor{stringliteral}{"wb"})))
121     die(\textcolor{stringliteral}{"Failed to open %s for writing."}, argv[2]);
122 
123   num\_references = (int)strtol(argv[3], NULL, 0);
124   num\_tile\_lists = (int)strtol(argv[4], NULL, 0);
125 
126   \textcolor{keywordflow}{if} (argc > 5) output\_format = (int)strtol(argv[5], NULL, 0);
127   \textcolor{keywordflow}{if} (output\_format < YUV1D || output\_format > NV12)
128     die(\textcolor{stringliteral}{"Output format out of range [0, 2]"});
129 
130   info = aom\_video\_reader\_get\_info(reader);
131 
132   decoder = get\_aom\_decoder\_by\_fourcc(info->codec\_fourcc);
133   \textcolor{keywordflow}{if} (!decoder) die(\textcolor{stringliteral}{"Unknown input codec."});
134   printf(\textcolor{stringliteral}{"Using %s\(\backslash\)n"}, \hyperlink{group__codec_ga013b1f6d96b2cf9489396311a7e5179b}{aom\_codec\_iface\_name}(decoder->codec\_interface()));
135 
136   \textcolor{keywordflow}{if} (\hyperlink{group__decoder_gafdbfca65b19ab1f6d72b32cd01753b9b}{aom\_codec\_dec\_init}(&codec, decoder->codec\_interface(), NULL, 0))
137     die\_codec(&codec, \textcolor{stringliteral}{"Failed to initialize decoder."});
138 
139   \textcolor{keywordflow}{if} (\hyperlink{group__codec_ga6da974f4eeaba1fa74106b28d0fe6ac5}{aom\_codec\_control}(&codec, \hyperlink{group__aom__decoder_gga3865fd4b3192489baa9a5c3632ebe97ba1fb269c5c5913d9995b6c35d28e2a788}{AV1D\_SET\_IS\_ANNEXB}, info->is\_annexb)) \{
140     die(\textcolor{stringliteral}{"Failed to set annex b status"});
141   \}
142 
143   \textcolor{comment}{// Decode anchor frames.}
144   \hyperlink{group__codec_ga51eb332a40dcacc39000ab8e0be36b79}{aom\_codec\_control\_}(&codec, \hyperlink{group__aom__decoder_gga3865fd4b3192489baa9a5c3632ebe97ba0795d8084ae8c78528c01587198df9e2}{AV1\_SET\_TILE\_MODE}, 0);
145   \textcolor{keywordflow}{for} (i = 0; i < num\_references; ++i) \{
146     aom\_video\_reader\_read\_frame(reader);
147     frame = aom\_video\_reader\_get\_frame(reader, &frame\_size);
148     \textcolor{keywordflow}{if} (\hyperlink{group__decoder_gab03fdb999d1f83a5896869a3ba5f68f7}{aom\_codec\_decode}(&codec, frame, frame\_size, NULL))
149       die\_codec(&codec, \textcolor{stringliteral}{"Failed to decode frame."});
150 
151     \textcolor{keywordflow}{if} (i == 0) \{
152       \hyperlink{aom__image_8h_ab71efff8c7f49380fad23b93bc2e9bfc}{aom\_img\_fmt\_t} ref\_fmt = 0;
153       \textcolor{keywordflow}{if} (\hyperlink{group__codec_ga6da974f4eeaba1fa74106b28d0fe6ac5}{aom\_codec\_control}(&codec, \hyperlink{group__aom__decoder_gga3865fd4b3192489baa9a5c3632ebe97bacd7229e5fb766670fe995739931c2ee3}{AV1D\_GET\_IMG\_FORMAT}, &ref\_fmt))
154         die\_codec(&codec, \textcolor{stringliteral}{"Failed to get the image format"});
155 
156       \textcolor{keywordtype}{int} frame\_res[2];
157       \textcolor{keywordflow}{if} (\hyperlink{group__codec_ga6da974f4eeaba1fa74106b28d0fe6ac5}{aom\_codec\_control}(&codec, \hyperlink{group__aom__decoder_gga3865fd4b3192489baa9a5c3632ebe97ba175c454a7adf2d3927a0e979b4a2b07b}{AV1D\_GET\_FRAME\_SIZE}, frame\_res))
158         die\_codec(&codec, \textcolor{stringliteral}{"Failed to get the image frame size"});
159 
160       \textcolor{comment}{// Allocate memory to store decoded references. Allocate memory with the}
161       \textcolor{comment}{// border so that it can be used as a reference.}
162       \textcolor{keywordflow}{for} (j = 0; j < num\_references; j++) \{
163         \textcolor{keywordtype}{unsigned} \textcolor{keywordtype}{int} border = AOM\_BORDER\_IN\_PIXELS;
164         \textcolor{keywordflow}{if} (!\hyperlink{aom__image_8h_aeb211e5184687f7e10d7c5bed4dcfdcd}{aom\_img\_alloc\_with\_border}(&reference\_images[j], ref\_fmt,
165                                        frame\_res[0], frame\_res[1], 32, 8,
166                                        border)) \{
167           die(\textcolor{stringliteral}{"Failed to allocate references."});
168         \}
169       \}
170     \}
171 
172     \textcolor{keywordflow}{if} (\hyperlink{group__codec_ga6da974f4eeaba1fa74106b28d0fe6ac5}{aom\_codec\_control}(&codec, \hyperlink{group__aom_gga9421a1fa78c0d9587ae5aa6c1cb3d659ae41763622ee33cd99e23ca8f78a3f8fa}{AV1\_COPY\_NEW\_FRAME\_IMAGE},
173                           &reference\_images[i]))
174       die\_codec(&codec, \textcolor{stringliteral}{"Failed to copy decoded reference frame"});
175 
176     \hyperlink{group__codec_gadf9e173c9e02788a9999399edab20a02}{aom\_codec\_iter\_t} iter = NULL;
177     \hyperlink{structaom__image}{aom\_image\_t} *img = NULL;
178     \textcolor{keywordflow}{while} ((img = \hyperlink{group__decoder_ga780aad27a2728abefab725faa3bc4f79}{aom\_codec\_get\_frame}(&codec, &iter)) != NULL) \{
179       \textcolor{keywordtype}{char} name[1024];
180       snprintf(name, \textcolor{keyword}{sizeof}(name), \textcolor{stringliteral}{"ref\_%d.yuv"}, i);
181       printf(\textcolor{stringliteral}{"writing ref image to %s, %d, %d\(\backslash\)n"}, name, img->\hyperlink{structaom__image_a89f80b1f58d608b9d2080635f4359034}{d\_w}, img->\hyperlink{structaom__image_ab986419a1f0fff93a2dc505f47194988}{d\_h});
182       FILE *ref\_file = fopen(name, \textcolor{stringliteral}{"wb"});
183       aom\_img\_write(img, ref\_file);
184       fclose(ref\_file);
185     \}
186   \}
187 
188   \textcolor{comment}{// Decode the lightfield.}
189   \hyperlink{group__codec_ga51eb332a40dcacc39000ab8e0be36b79}{aom\_codec\_control\_}(&codec, \hyperlink{group__aom__decoder_gga3865fd4b3192489baa9a5c3632ebe97ba0795d8084ae8c78528c01587198df9e2}{AV1\_SET\_TILE\_MODE}, 1);
190 
191   \textcolor{comment}{// Set external references.}
192   \hyperlink{structav1__ext__ref__frame}{av1\_ext\_ref\_frame\_t} set\_ext\_ref = \{ &reference\_images[0], num\_references \};
193   \hyperlink{group__codec_ga51eb332a40dcacc39000ab8e0be36b79}{aom\_codec\_control\_}(&codec, \hyperlink{group__aom__decoder_gga3865fd4b3192489baa9a5c3632ebe97badfbe6c1ebe4039bfef4d2cfd98755add}{AV1D\_SET\_EXT\_REF\_PTR}, &set\_ext\_ref);
194   \textcolor{comment}{// Must decode the camera frame header first.}
195   aom\_video\_reader\_read\_frame(reader);
196   frame = aom\_video\_reader\_get\_frame(reader, &frame\_size);
197   \textcolor{keywordflow}{if} (\hyperlink{group__decoder_gab03fdb999d1f83a5896869a3ba5f68f7}{aom\_codec\_decode}(&codec, frame, frame\_size, NULL))
198     die\_codec(&codec, \textcolor{stringliteral}{"Failed to decode the frame."});
199   \textcolor{comment}{// Decode tile lists one by one.}
200   \textcolor{keywordflow}{for} (n = 0; n < num\_tile\_lists; n++) \{
201     aom\_video\_reader\_read\_frame(reader);
202     frame = aom\_video\_reader\_get\_frame(reader, &frame\_size);
203 
204     \textcolor{keywordflow}{if} (\hyperlink{group__decoder_gab03fdb999d1f83a5896869a3ba5f68f7}{aom\_codec\_decode}(&codec, frame, frame\_size, NULL))
205       die\_codec(&codec, \textcolor{stringliteral}{"Failed to decode the tile list."});
206     \hyperlink{group__codec_gadf9e173c9e02788a9999399edab20a02}{aom\_codec\_iter\_t} iter = NULL;
207     \hyperlink{structaom__image}{aom\_image\_t} *img = \hyperlink{group__decoder_ga780aad27a2728abefab725faa3bc4f79}{aom\_codec\_get\_frame}(&codec, &iter);
208     \textcolor{keywordflow}{if} (!img) die\_codec(&codec, \textcolor{stringliteral}{"Failed to get frame."});
209 
210     \textcolor{keywordflow}{if} (output\_format == YUV1D)
211       \textcolor{comment}{// write the tile to the output file in 1D format.}
212       write\_tile\_yuv1d(&codec, img, outfile);
213     \textcolor{keywordflow}{else} \textcolor{keywordflow}{if} (output\_format == YUV)
214       aom\_img\_write(img, outfile);
215     \textcolor{keywordflow}{else}
216       \textcolor{comment}{// NV12 output format}
217       aom\_img\_write\_nv12(img, outfile);
218   \}
219 
220   \textcolor{keywordflow}{for} (i = 0; i < num\_references; i++) \hyperlink{aom__image_8h_afff22f7f3eb9409c5b678d1962f110a8}{aom\_img\_free}(&reference\_images[i]);
221   \textcolor{keywordflow}{if} (\hyperlink{group__codec_ga9b60e186f61ba2d6ab2b8069b76a15c5}{aom\_codec\_destroy}(&codec)) die\_codec(&codec, \textcolor{stringliteral}{"Failed to destroy codec"});
222   aom\_video\_reader\_close(reader);
223   fclose(outfile);
224 
225   \textcolor{keywordflow}{return} EXIT\_SUCCESS;
226 \}
\end{DoxyCodeInclude}
 \hypertarget{example_lightfield_decoder}{}\subsection{lightfield\+\_\+decoder}\label{example_lightfield_decoder}

\begin{DoxyCodeInclude}
1 \textcolor{comment}{/*}
2 \textcolor{comment}{ * Copyright (c) 2017, Alliance for Open Media. All rights reserved}
3 \textcolor{comment}{ *}
4 \textcolor{comment}{ * This source code is subject to the terms of the BSD 2 Clause License and}
5 \textcolor{comment}{ * the Alliance for Open Media Patent License 1.0. If the BSD 2 Clause License}
6 \textcolor{comment}{ * was not distributed with this source code in the LICENSE file, you can}
7 \textcolor{comment}{ * obtain it at www.aomedia.org/license/software. If the Alliance for Open}
8 \textcolor{comment}{ * Media Patent License 1.0 was not distributed with this source code in the}
9 \textcolor{comment}{ * PATENTS file, you can obtain it at www.aomedia.org/license/patent.}
10 \textcolor{comment}{ */}
11 
12 \textcolor{comment}{// Lightfield Decoder}
13 \textcolor{comment}{// ==================}
14 \textcolor{comment}{//}
15 \textcolor{comment}{// This is an example of a simple lightfield decoder. It builds upon the}
16 \textcolor{comment}{// simple\_decoder.c example.  It takes an input file containing the compressed}
17 \textcolor{comment}{// data (in ivf format), treating it as a lightfield instead of a video; and a}
18 \textcolor{comment}{// text file with a list of tiles to decode. There is an optional parameter}
19 \textcolor{comment}{// allowing to choose the output format, and the supported formats are}
20 \textcolor{comment}{// YUV1D(default), YUV, and NV12.}
21 \textcolor{comment}{// After running the lightfield encoder, run lightfield decoder to decode a}
22 \textcolor{comment}{// batch of tiles:}
23 \textcolor{comment}{// examples/lightfield\_decoder vase10x10.ivf vase\_reference.yuv 4 tile\_list.txt}
24 \textcolor{comment}{// 0(optional)}
25 \textcolor{comment}{// The tile\_list.txt is expected to be of the form:}
26 \textcolor{comment}{// Frame <frame\_index0>}
27 \textcolor{comment}{// <image\_index0> <anchor\_index0> <tile\_col0> <tile\_row0>}
28 \textcolor{comment}{// <image\_index1> <anchor\_index1> <tile\_col1> <tile\_row1>}
29 \textcolor{comment}{// ...}
30 \textcolor{comment}{// Frame <frame\_index1)}
31 \textcolor{comment}{// ...}
32 \textcolor{comment}{//}
33 \textcolor{comment}{// The "Frame" markers indicate a new render frame and thus a new tile list}
34 \textcolor{comment}{// will be started and the old one flushed.  The image\_indexN, anchor\_indexN,}
35 \textcolor{comment}{// tile\_colN, and tile\_rowN identify an individual tile to be decoded and}
36 \textcolor{comment}{// to use anchor\_indexN anchor image for MCP.}
37 
38 \textcolor{preprocessor}{#include <stdio.h>}
39 \textcolor{preprocessor}{#include <stdlib.h>}
40 \textcolor{preprocessor}{#include <string.h>}
41 
42 \textcolor{preprocessor}{#include "\hyperlink{aom__decoder_8h}{aom/aom\_decoder.h}"}
43 \textcolor{preprocessor}{#include "\hyperlink{aomdx_8h}{aom/aomdx.h}"}
44 \textcolor{preprocessor}{#include "aom\_scale/yv12config.h"}
45 \textcolor{preprocessor}{#include "av1/common/enums.h"}
46 \textcolor{preprocessor}{#include "common/tools\_common.h"}
47 \textcolor{preprocessor}{#include "common/video\_reader.h"}
48 
49 \textcolor{keyword}{static} \textcolor{keyword}{const} \textcolor{keywordtype}{char} *exec\_name;
50 
51 \textcolor{keywordtype}{void} usage\_exit(\textcolor{keywordtype}{void}) \{
52   fprintf(stderr,
53           \textcolor{stringliteral}{"Usage: %s <infile> <outfile> <num\_references> <tile\_list> <output "}
54           \textcolor{stringliteral}{"format(optional)>\(\backslash\)n"},
55           exec\_name);
56   exit(EXIT\_FAILURE);
57 \}
58 
59 \textcolor{comment}{// Output frame size}
60 \textcolor{keyword}{const} \textcolor{keywordtype}{int} output\_frame\_width = 512;
61 \textcolor{keyword}{const} \textcolor{keywordtype}{int} output\_frame\_height = 512;
62 
63 \textcolor{keyword}{static} \textcolor{keywordtype}{void} aom\_img\_copy\_tile(\textcolor{keyword}{const} \hyperlink{structaom__image}{aom\_image\_t} *src, \textcolor{keyword}{const} 
      \hyperlink{structaom__image}{aom\_image\_t} *dst,
64                               \textcolor{keywordtype}{int} dst\_row\_offset, \textcolor{keywordtype}{int} dst\_col\_offset) \{
65   \textcolor{keyword}{const} \textcolor{keywordtype}{int} shift = (src->\hyperlink{structaom__image_a6c64b1ab918d80d52eb8f5d6d957e825}{fmt} & \hyperlink{aom__image_8h_a607b37d91f75442f54223ecd85f1b6cb}{AOM\_IMG\_FMT\_HIGHBITDEPTH}) ? 1 : 0;
66   \textcolor{keywordtype}{int} plane;
67 
68   \textcolor{keywordflow}{for} (plane = 0; plane < 3; ++plane) \{
69     \textcolor{keyword}{const} \textcolor{keywordtype}{unsigned} \textcolor{keywordtype}{char} *src\_buf = src->\hyperlink{structaom__image_ac54dbc5237ca2914f9ec30105dfbe302}{planes}[plane];
70     \textcolor{keyword}{const} \textcolor{keywordtype}{int} src\_stride = src->\hyperlink{structaom__image_a6dc693d7dbc9eb06c0cdde307ca58372}{stride}[plane];
71     \textcolor{keywordtype}{unsigned} \textcolor{keywordtype}{char} *dst\_buf = dst->\hyperlink{structaom__image_ac54dbc5237ca2914f9ec30105dfbe302}{planes}[plane];
72     \textcolor{keyword}{const} \textcolor{keywordtype}{int} dst\_stride = dst->\hyperlink{structaom__image_a6dc693d7dbc9eb06c0cdde307ca58372}{stride}[plane];
73     \textcolor{keyword}{const} \textcolor{keywordtype}{int} roffset =
74         (plane > 0) ? dst\_row\_offset >> dst->\hyperlink{structaom__image_a5acfc850c272e1377f3b7d58a95f3749}{y\_chroma\_shift} : dst\_row\_offset;
75     \textcolor{keyword}{const} \textcolor{keywordtype}{int} coffset =
76         (plane > 0) ? dst\_col\_offset >> dst->\hyperlink{structaom__image_a83fdb3677275dc0e1e38701000447214}{x\_chroma\_shift} : dst\_col\_offset;
77 
78     \textcolor{comment}{// col offset needs to be adjusted for HBD.}
79     dst\_buf += roffset * dst\_stride + (coffset << shift);
80 
81     \textcolor{keyword}{const} \textcolor{keywordtype}{int} w = (\hyperlink{aom__image_8h_adfb2ea2e110ee42e38370868b64bf232}{aom\_img\_plane\_width}(src, plane) << shift);
82     \textcolor{keyword}{const} \textcolor{keywordtype}{int} h = \hyperlink{aom__image_8h_ab87684a93e3da97bd6223d1e46876848}{aom\_img\_plane\_height}(src, plane);
83     \textcolor{keywordtype}{int} y;
84 
85     \textcolor{keywordflow}{for} (y = 0; y < h; ++y) \{
86       memcpy(dst\_buf, src\_buf, w);
87       src\_buf += src\_stride;
88       dst\_buf += dst\_stride;
89     \}
90   \}
91 \}
92 
93 \textcolor{keywordtype}{void} decode\_tile(\hyperlink{structaom__codec__ctx}{aom\_codec\_ctx\_t} *codec, \textcolor{keyword}{const} \textcolor{keywordtype}{unsigned} \textcolor{keywordtype}{char} *frame,
94                  \textcolor{keywordtype}{size\_t} frame\_size, \textcolor{keywordtype}{int} tr, \textcolor{keywordtype}{int} tc, \textcolor{keywordtype}{int} ref\_idx,
95                  \hyperlink{structaom__image}{aom\_image\_t} *reference\_images, \hyperlink{structaom__image}{aom\_image\_t} *output,
96                  \textcolor{keywordtype}{int} *tile\_idx, \textcolor{keywordtype}{unsigned} \textcolor{keywordtype}{int} *output\_bit\_depth,
97                  \hyperlink{structaom__image}{aom\_image\_t} **img\_ptr, \textcolor{keywordtype}{int} output\_format) \{
98   \hyperlink{group__codec_ga51eb332a40dcacc39000ab8e0be36b79}{aom\_codec\_control\_}(codec, \hyperlink{group__aom__decoder_gga3865fd4b3192489baa9a5c3632ebe97ba0795d8084ae8c78528c01587198df9e2}{AV1\_SET\_TILE\_MODE}, 1);
99   \hyperlink{group__codec_ga51eb332a40dcacc39000ab8e0be36b79}{aom\_codec\_control\_}(codec, \hyperlink{group__aom__decoder_gga3865fd4b3192489baa9a5c3632ebe97baffdaca91296725bd16142a33f3cc6522}{AV1D\_EXT\_TILE\_DEBUG}, 1);
100   \hyperlink{group__codec_ga51eb332a40dcacc39000ab8e0be36b79}{aom\_codec\_control\_}(codec, \hyperlink{group__aom__decoder_gga3865fd4b3192489baa9a5c3632ebe97bac056b4cf80427fd05e3c4c9fc46edb78}{AV1\_SET\_DECODE\_TILE\_ROW}, tr);
101   \hyperlink{group__codec_ga51eb332a40dcacc39000ab8e0be36b79}{aom\_codec\_control\_}(codec, AV1\_SET\_DECODE\_TILE\_COL, tc);
102 
103   \hyperlink{structav1__ref__frame}{av1\_ref\_frame\_t} ref;
104   ref.\hyperlink{structav1__ref__frame_a7c6fcaba58f514985448cb2e2245345c}{idx} = 0;
105   ref.\hyperlink{structav1__ref__frame_a33749c5c20033cc5f7582d0ec1c34ff0}{use\_external\_ref} = 1;
106   ref.\hyperlink{structav1__ref__frame_a55a09db9e1acdd73e656b01fa01283b3}{img} = reference\_images[ref\_idx];
107   \textcolor{keywordflow}{if} (\hyperlink{group__codec_ga6da974f4eeaba1fa74106b28d0fe6ac5}{aom\_codec\_control}(codec, \hyperlink{group__aom_gga9421a1fa78c0d9587ae5aa6c1cb3d659a51ad4467b4dc318406cceb257e2daa41}{AV1\_SET\_REFERENCE}, &ref)) \{
108     die\_codec(codec, \textcolor{stringliteral}{"Failed to set reference frame."});
109   \}
110 
111   \hyperlink{group__codec_gaaae61e0f8663e6137f1e228757248e7c}{aom\_codec\_err\_t} aom\_status = \hyperlink{group__decoder_gab03fdb999d1f83a5896869a3ba5f68f7}{aom\_codec\_decode}(codec, frame, frame\_size, 
      NULL);
112   \textcolor{keywordflow}{if} (aom\_status) die\_codec(codec, \textcolor{stringliteral}{"Failed to decode tile."});
113 
114   \hyperlink{group__codec_gadf9e173c9e02788a9999399edab20a02}{aom\_codec\_iter\_t} iter = NULL;
115   \hyperlink{structaom__image}{aom\_image\_t} *img = \hyperlink{group__decoder_ga780aad27a2728abefab725faa3bc4f79}{aom\_codec\_get\_frame}(codec, &iter);
116   \textcolor{keywordflow}{if} (!img) die\_codec(codec, \textcolor{stringliteral}{"Failed to get frame."});
117   *img\_ptr = img;
118 
119   \textcolor{comment}{// aom\_img\_alloc() sets bit\_depth as follows:}
120   \textcolor{comment}{// output->bit\_depth = (fmt & AOM\_IMG\_FMT\_HIGHBITDEPTH) ? 16 : 8;}
121   \textcolor{comment}{// Use img->bit\_depth(read from bitstream), so that aom\_shift\_img()}
122   \textcolor{comment}{// works as expected.}
123   output->\hyperlink{structaom__image_a46ed9ffd741938d306a0db5a24bdcf8e}{bit\_depth} = img->\hyperlink{structaom__image_a46ed9ffd741938d306a0db5a24bdcf8e}{bit\_depth};
124   *output\_bit\_depth = img->\hyperlink{structaom__image_a46ed9ffd741938d306a0db5a24bdcf8e}{bit\_depth};
125 
126   \textcolor{keywordflow}{if} (output\_format != YUV1D) \{
127     \textcolor{comment}{// read out the tile size.}
128     \textcolor{keywordtype}{unsigned} \textcolor{keywordtype}{int} tile\_size = 0;
129     \textcolor{keywordflow}{if} (\hyperlink{group__codec_ga6da974f4eeaba1fa74106b28d0fe6ac5}{aom\_codec\_control}(codec, \hyperlink{group__aom__decoder_gga3865fd4b3192489baa9a5c3632ebe97ba4d9799d9e520785870b8d1f73a19c3c4}{AV1D\_GET\_TILE\_SIZE}, &tile\_size))
130       die\_codec(codec, \textcolor{stringliteral}{"Failed to get the tile size"});
131     \textcolor{keyword}{const} \textcolor{keywordtype}{unsigned} \textcolor{keywordtype}{int} tile\_width = tile\_size >> 16;
132     \textcolor{keyword}{const} \textcolor{keywordtype}{unsigned} \textcolor{keywordtype}{int} tile\_height = tile\_size & 65535;
133     \textcolor{keyword}{const} uint8\_t output\_frame\_width\_in\_tiles = output\_frame\_width / tile\_width;
134 
135     \textcolor{comment}{// Copy the tile to the output frame.}
136     \textcolor{keyword}{const} \textcolor{keywordtype}{int} row\_offset =
137         (*tile\_idx / output\_frame\_width\_in\_tiles) * tile\_height;
138     \textcolor{keyword}{const} \textcolor{keywordtype}{int} col\_offset =
139         (*tile\_idx % output\_frame\_width\_in\_tiles) * tile\_width;
140 
141     aom\_img\_copy\_tile(img, output, row\_offset, col\_offset);
142     (*tile\_idx)++;
143   \}
144 \}
145 
146 \textcolor{keyword}{static} \textcolor{keywordtype}{void} img\_write\_to\_file(\textcolor{keyword}{const} \hyperlink{structaom__image}{aom\_image\_t} *img, FILE *file,
147                               \textcolor{keywordtype}{int} output\_format) \{
148   \textcolor{keywordflow}{if} (output\_format == YUV)
149     aom\_img\_write(img, file);
150   \textcolor{keywordflow}{else} \textcolor{keywordflow}{if} (output\_format == NV12)
151     aom\_img\_write\_nv12(img, file);
152   \textcolor{keywordflow}{else}
153     die(\textcolor{stringliteral}{"Invalid output format"});
154 \}
155 
156 \textcolor{keywordtype}{int} main(\textcolor{keywordtype}{int} argc, \textcolor{keywordtype}{char} **argv) \{
157   FILE *outfile = NULL;
158   \hyperlink{structaom__codec__ctx}{aom\_codec\_ctx\_t} codec;
159   AvxVideoReader *reader = NULL;
160   \textcolor{keyword}{const} AvxInterface *decoder = NULL;
161   \textcolor{keyword}{const} AvxVideoInfo *info = NULL;
162   \textcolor{keywordtype}{int} num\_references;
163   \hyperlink{aom__image_8h_ab71efff8c7f49380fad23b93bc2e9bfc}{aom\_img\_fmt\_t} ref\_fmt = 0;
164   \hyperlink{structaom__image}{aom\_image\_t} reference\_images[MAX\_EXTERNAL\_REFERENCES];
165   \hyperlink{structaom__image}{aom\_image\_t} output;
166   \hyperlink{structaom__image}{aom\_image\_t} *output\_shifted = NULL;
167   \textcolor{keywordtype}{size\_t} frame\_size = 0;
168   \textcolor{keyword}{const} \textcolor{keywordtype}{unsigned} \textcolor{keywordtype}{char} *frame = NULL;
169   \textcolor{keywordtype}{int} i, j;
170   \textcolor{keyword}{const} \textcolor{keywordtype}{char} *tile\_list\_file = NULL;
171   \textcolor{keywordtype}{int} output\_format = YUV1D;
172   exec\_name = argv[0];
173 
174   \textcolor{keywordflow}{if} (argc < 5) die(\textcolor{stringliteral}{"Invalid number of arguments."});
175 
176   reader = aom\_video\_reader\_open(argv[1]);
177   \textcolor{keywordflow}{if} (!reader) die(\textcolor{stringliteral}{"Failed to open %s for reading."}, argv[1]);
178 
179   \textcolor{keywordflow}{if} (!(outfile = fopen(argv[2], \textcolor{stringliteral}{"wb"})))
180     die(\textcolor{stringliteral}{"Failed to open %s for writing."}, argv[2]);
181 
182   num\_references = (int)strtol(argv[3], NULL, 0);
183   tile\_list\_file = argv[4];
184 
185   \textcolor{keywordflow}{if} (argc > 5) output\_format = (int)strtol(argv[5], NULL, 0);
186   \textcolor{keywordflow}{if} (output\_format < YUV1D || output\_format > NV12)
187     die(\textcolor{stringliteral}{"Output format out of range [0, 2]"});
188 
189   info = aom\_video\_reader\_get\_info(reader);
190 
191   decoder = get\_aom\_decoder\_by\_fourcc(info->codec\_fourcc);
192   \textcolor{keywordflow}{if} (!decoder) die(\textcolor{stringliteral}{"Unknown input codec."});
193   printf(\textcolor{stringliteral}{"Using %s\(\backslash\)n"}, \hyperlink{group__codec_ga013b1f6d96b2cf9489396311a7e5179b}{aom\_codec\_iface\_name}(decoder->codec\_interface()));
194 
195   \textcolor{keywordflow}{if} (\hyperlink{group__decoder_gafdbfca65b19ab1f6d72b32cd01753b9b}{aom\_codec\_dec\_init}(&codec, decoder->codec\_interface(), NULL, 0))
196     die\_codec(&codec, \textcolor{stringliteral}{"Failed to initialize decoder."});
197 
198   \textcolor{keywordflow}{if} (\hyperlink{group__codec_ga6da974f4eeaba1fa74106b28d0fe6ac5}{aom\_codec\_control}(&codec, \hyperlink{group__aom__decoder_gga3865fd4b3192489baa9a5c3632ebe97ba1fb269c5c5913d9995b6c35d28e2a788}{AV1D\_SET\_IS\_ANNEXB}, info->is\_annexb)) \{
199     die(\textcolor{stringliteral}{"Failed to set annex b status"});
200   \}
201 
202   \textcolor{comment}{// Decode anchor frames.}
203   \hyperlink{group__codec_ga51eb332a40dcacc39000ab8e0be36b79}{aom\_codec\_control\_}(&codec, \hyperlink{group__aom__decoder_gga3865fd4b3192489baa9a5c3632ebe97ba0795d8084ae8c78528c01587198df9e2}{AV1\_SET\_TILE\_MODE}, 0);
204   \textcolor{keywordflow}{for} (i = 0; i < num\_references; ++i) \{
205     aom\_video\_reader\_read\_frame(reader);
206     frame = aom\_video\_reader\_get\_frame(reader, &frame\_size);
207     \textcolor{keywordflow}{if} (\hyperlink{group__decoder_gab03fdb999d1f83a5896869a3ba5f68f7}{aom\_codec\_decode}(&codec, frame, frame\_size, NULL))
208       die\_codec(&codec, \textcolor{stringliteral}{"Failed to decode frame."});
209 
210     \textcolor{keywordflow}{if} (i == 0) \{
211       \textcolor{keywordflow}{if} (\hyperlink{group__codec_ga6da974f4eeaba1fa74106b28d0fe6ac5}{aom\_codec\_control}(&codec, \hyperlink{group__aom__decoder_gga3865fd4b3192489baa9a5c3632ebe97bacd7229e5fb766670fe995739931c2ee3}{AV1D\_GET\_IMG\_FORMAT}, &ref\_fmt))
212         die\_codec(&codec, \textcolor{stringliteral}{"Failed to get the image format"});
213 
214       \textcolor{keywordtype}{int} frame\_res[2];
215       \textcolor{keywordflow}{if} (\hyperlink{group__codec_ga6da974f4eeaba1fa74106b28d0fe6ac5}{aom\_codec\_control}(&codec, \hyperlink{group__aom__decoder_gga3865fd4b3192489baa9a5c3632ebe97ba175c454a7adf2d3927a0e979b4a2b07b}{AV1D\_GET\_FRAME\_SIZE}, frame\_res))
216         die\_codec(&codec, \textcolor{stringliteral}{"Failed to get the image frame size"});
217 
218       \textcolor{comment}{// Allocate memory to store decoded references. Allocate memory with the}
219       \textcolor{comment}{// border so that it can be used as a reference.}
220       \textcolor{keywordflow}{for} (j = 0; j < num\_references; j++) \{
221         \textcolor{keywordtype}{unsigned} \textcolor{keywordtype}{int} border = AOM\_BORDER\_IN\_PIXELS;
222         \textcolor{keywordflow}{if} (!\hyperlink{aom__image_8h_aeb211e5184687f7e10d7c5bed4dcfdcd}{aom\_img\_alloc\_with\_border}(&reference\_images[j], ref\_fmt,
223                                        frame\_res[0], frame\_res[1], 32, 8,
224                                        border)) \{
225           die(\textcolor{stringliteral}{"Failed to allocate references."});
226         \}
227       \}
228     \}
229 
230     \textcolor{keywordflow}{if} (\hyperlink{group__codec_ga6da974f4eeaba1fa74106b28d0fe6ac5}{aom\_codec\_control}(&codec, \hyperlink{group__aom_gga9421a1fa78c0d9587ae5aa6c1cb3d659ae41763622ee33cd99e23ca8f78a3f8fa}{AV1\_COPY\_NEW\_FRAME\_IMAGE},
231                           &reference\_images[i]))
232       die\_codec(&codec, \textcolor{stringliteral}{"Failed to copy decoded reference frame"});
233 
234     \hyperlink{group__codec_gadf9e173c9e02788a9999399edab20a02}{aom\_codec\_iter\_t} iter = NULL;
235     \hyperlink{structaom__image}{aom\_image\_t} *img = NULL;
236     \textcolor{keywordflow}{while} ((img = \hyperlink{group__decoder_ga780aad27a2728abefab725faa3bc4f79}{aom\_codec\_get\_frame}(&codec, &iter)) != NULL) \{
237       \textcolor{keywordtype}{char} name[1024];
238       snprintf(name, \textcolor{keyword}{sizeof}(name), \textcolor{stringliteral}{"ref\_%d.yuv"}, i);
239       printf(\textcolor{stringliteral}{"writing ref image to %s, %d, %d\(\backslash\)n"}, name, img->\hyperlink{structaom__image_a89f80b1f58d608b9d2080635f4359034}{d\_w}, img->\hyperlink{structaom__image_ab986419a1f0fff93a2dc505f47194988}{d\_h});
240       FILE *ref\_file = fopen(name, \textcolor{stringliteral}{"wb"});
241       aom\_img\_write(img, ref\_file);
242       fclose(ref\_file);
243     \}
244   \}
245 
246   FILE *infile = aom\_video\_reader\_get\_file(reader);
247   \textcolor{comment}{// Record the offset of the first camera image.}
248   \textcolor{keyword}{const} FileOffset camera\_frame\_pos = ftello(infile);
249 
250   printf(\textcolor{stringliteral}{"Loading compressed frames into memory.\(\backslash\)n"});
251 
252   \textcolor{comment}{// Count the frames in the lightfield.}
253   \textcolor{keywordtype}{int} num\_frames = 0;
254   \textcolor{keywordflow}{while} (aom\_video\_reader\_read\_frame(reader)) \{
255     ++num\_frames;
256   \}
257   \textcolor{keywordflow}{if} (num\_frames < 1) die(\textcolor{stringliteral}{"Input light field has no frames."});
258 
259   \textcolor{comment}{// Read all of the lightfield frames into memory.}
260   \textcolor{keywordtype}{unsigned} \textcolor{keywordtype}{char} **frames =
261       (\textcolor{keywordtype}{unsigned} \textcolor{keywordtype}{char} **)malloc(num\_frames * \textcolor{keyword}{sizeof}(\textcolor{keywordtype}{unsigned} \textcolor{keywordtype}{char} *));
262   \textcolor{keywordtype}{size\_t} *frame\_sizes = (\textcolor{keywordtype}{size\_t} *)malloc(num\_frames * \textcolor{keyword}{sizeof}(\textcolor{keywordtype}{size\_t}));
263   \textcolor{comment}{// Seek to the first camera image.}
264   fseeko(infile, camera\_frame\_pos, SEEK\_SET);
265   \textcolor{keywordflow}{for} (\textcolor{keywordtype}{int} f = 0; f < num\_frames; ++f) \{
266     aom\_video\_reader\_read\_frame(reader);
267     frame = aom\_video\_reader\_get\_frame(reader, &frame\_size);
268     frames[f] = (\textcolor{keywordtype}{unsigned} \textcolor{keywordtype}{char} *)malloc(frame\_size * \textcolor{keyword}{sizeof}(\textcolor{keywordtype}{unsigned} \textcolor{keywordtype}{char}));
269     memcpy(frames[f], frame, frame\_size);
270     frame\_sizes[f] = frame\_size;
271   \}
272   printf(\textcolor{stringliteral}{"Read %d frames.\(\backslash\)n"}, num\_frames);
273 
274   \textcolor{keywordflow}{if} (output\_format != YUV1D) \{
275     \textcolor{comment}{// Allocate the output frame.}
276     \hyperlink{aom__image_8h_ab71efff8c7f49380fad23b93bc2e9bfc}{aom\_img\_fmt\_t} out\_fmt = ref\_fmt;
277     \textcolor{keywordflow}{if} (!CONFIG\_LOWBITDEPTH) out\_fmt |= \hyperlink{aom__image_8h_a607b37d91f75442f54223ecd85f1b6cb}{AOM\_IMG\_FMT\_HIGHBITDEPTH};
278     \textcolor{keywordflow}{if} (!\hyperlink{aom__image_8h_a570db29fbd122951235a08fe9375f6bb}{aom\_img\_alloc}(&output, out\_fmt, output\_frame\_width,
279                        output\_frame\_height, 32))
280       die(\textcolor{stringliteral}{"Failed to allocate output image."});
281   \}
282 
283   printf(\textcolor{stringliteral}{"Decoding tile list from file.\(\backslash\)n"});
284   \textcolor{keywordtype}{char} line[1024];
285   FILE *tile\_list\_fptr = fopen(tile\_list\_file, \textcolor{stringliteral}{"r"});
286   \textcolor{keywordtype}{int} tile\_list\_cnt = 0;
287   \textcolor{keywordtype}{int} tile\_list\_writes = 0;
288   \textcolor{keywordtype}{int} tile\_idx = 0;
289   \hyperlink{structaom__image}{aom\_image\_t} *out = NULL;
290   \textcolor{keywordtype}{unsigned} \textcolor{keywordtype}{int} output\_bit\_depth = 0;
291 
292   \textcolor{keywordflow}{while} ((fgets(line, 1024, tile\_list\_fptr)) != NULL) \{
293     \textcolor{keywordflow}{if} (line[0] == \textcolor{charliteral}{'F'}) \{
294       \textcolor{keywordflow}{if} (output\_format != YUV1D) \{
295         \textcolor{comment}{// Write out the tile list.}
296         \textcolor{keywordflow}{if} (tile\_list\_cnt) \{
297           out = &output;
298           \textcolor{keywordflow}{if} (output\_bit\_depth != 0)
299             aom\_shift\_img(output\_bit\_depth, &out, &output\_shifted);
300           img\_write\_to\_file(out, outfile, output\_format);
301           tile\_list\_writes++;
302         \}
303 
304         tile\_list\_cnt++;
305         tile\_idx = 0;
306         \textcolor{comment}{// Then memset the frame.}
307         memset(output.\hyperlink{structaom__image_a7c367f3227d5876ce9e5c198a01c2028}{img\_data}, 0, output.\hyperlink{structaom__image_af0f6c220bf000d1c488075c19d889290}{sz});
308       \}
309       \textcolor{keywordflow}{continue};
310     \}
311 
312     \textcolor{keywordtype}{int} image\_idx, ref\_idx, tc, tr;
313     sscanf(line, \textcolor{stringliteral}{"%d %d %d %d"}, &image\_idx, &ref\_idx, &tc, &tr);
314     \textcolor{keywordflow}{if} (image\_idx >= num\_frames) \{
315       die(\textcolor{stringliteral}{"Tile list image\_idx out of bounds: %d >= %d."}, image\_idx,
316           num\_frames);
317     \}
318     \textcolor{keywordflow}{if} (ref\_idx >= num\_references) \{
319       die(\textcolor{stringliteral}{"Tile list ref\_idx out of bounds: %d >= %d."}, ref\_idx,
320           num\_references);
321     \}
322     frame = frames[image\_idx];
323     frame\_size = frame\_sizes[image\_idx];
324 
325     \hyperlink{structaom__image}{aom\_image\_t} *img = NULL;
326     decode\_tile(&codec, frame, frame\_size, tr, tc, ref\_idx, reference\_images,
327                 &output, &tile\_idx, &output\_bit\_depth, &img, output\_format);
328     \textcolor{keywordflow}{if} (output\_format == YUV1D) \{
329       out = img;
330       \textcolor{keywordflow}{if} (output\_bit\_depth != 0)
331         aom\_shift\_img(output\_bit\_depth, &out, &output\_shifted);
332       aom\_img\_write(out, outfile);
333     \}
334   \}
335 
336   \textcolor{keywordflow}{if} (output\_format != YUV1D) \{
337     \textcolor{comment}{// Write out the last tile list.}
338     \textcolor{keywordflow}{if} (tile\_list\_writes < tile\_list\_cnt) \{
339       out = &output;
340       \textcolor{keywordflow}{if} (output\_bit\_depth != 0)
341         aom\_shift\_img(output\_bit\_depth, &out, &output\_shifted);
342       img\_write\_to\_file(out, outfile, output\_format);
343     \}
344   \}
345 
346   \textcolor{keywordflow}{if} (output\_shifted) \hyperlink{aom__image_8h_afff22f7f3eb9409c5b678d1962f110a8}{aom\_img\_free}(output\_shifted);
347   \textcolor{keywordflow}{if} (output\_format != YUV1D) \hyperlink{aom__image_8h_afff22f7f3eb9409c5b678d1962f110a8}{aom\_img\_free}(&output);
348   \textcolor{keywordflow}{for} (i = 0; i < num\_references; i++) \hyperlink{aom__image_8h_afff22f7f3eb9409c5b678d1962f110a8}{aom\_img\_free}(&reference\_images[i]);
349   \textcolor{keywordflow}{for} (\textcolor{keywordtype}{int} f = 0; f < num\_frames; ++f) \{
350     free(frames[f]);
351   \}
352   free(frame\_sizes);
353   free(frames);
354   \textcolor{keywordflow}{if} (\hyperlink{group__codec_ga9b60e186f61ba2d6ab2b8069b76a15c5}{aom\_codec\_destroy}(&codec)) die\_codec(&codec, \textcolor{stringliteral}{"Failed to destroy codec"});
355   aom\_video\_reader\_close(reader);
356   fclose(outfile);
357 
358   \textcolor{keywordflow}{return} EXIT\_SUCCESS;
359 \}
\end{DoxyCodeInclude}
 \hypertarget{example_lightfield_bitstream_parsing}{}\subsection{lightfield\+\_\+bitstream\+\_\+parsing}\label{example_lightfield_bitstream_parsing}

\begin{DoxyCodeInclude}
1 \textcolor{comment}{/*}
2 \textcolor{comment}{ * Copyright (c) 2018, Alliance for Open Media. All rights reserved}
3 \textcolor{comment}{ *}
4 \textcolor{comment}{ * This source code is subject to the terms of the BSD 2 Clause License and}
5 \textcolor{comment}{ * the Alliance for Open Media Patent License 1.0. If the BSD 2 Clause License}
6 \textcolor{comment}{ * was not distributed with this source code in the LICENSE file, you can}
7 \textcolor{comment}{ * obtain it at www.aomedia.org/license/software. If the Alliance for Open}
8 \textcolor{comment}{ * Media Patent License 1.0 was not distributed with this source code in the}
9 \textcolor{comment}{ * PATENTS file, you can obtain it at www.aomedia.org/license/patent.}
10 \textcolor{comment}{ */}
11 
12 \textcolor{comment}{// Lightfield Bitstream Parsing}
13 \textcolor{comment}{// ============================}
14 \textcolor{comment}{//}
15 \textcolor{comment}{// This is a lightfield bitstream parsing example. It takes an input file}
16 \textcolor{comment}{// containing the whole compressed lightfield bitstream(ivf file) and a text}
17 \textcolor{comment}{// file containing a stream of tiles to decode and then constructs and outputs}
18 \textcolor{comment}{// a new bitstream that can be decoded by an AV1 decoder. The output bitstream}
19 \textcolor{comment}{// contains reference frames(i.e. anchor frames), camera frame header, and}
20 \textcolor{comment}{// tile list OBUs. num\_references is the number of anchor frames coded at the}
21 \textcolor{comment}{// beginning of the light field file.  After running the lightfield encoder,}
22 \textcolor{comment}{// run lightfield bitstream parsing:}
23 \textcolor{comment}{// examples/lightfield\_bitstream\_parsing vase10x10.ivf vase\_tile\_list.ivf 4}
24 \textcolor{comment}{//   tile\_list.txt}
25 \textcolor{comment}{//}
26 \textcolor{comment}{// The tile\_list.txt is expected to be of the form:}
27 \textcolor{comment}{// Frame <frame\_index0>}
28 \textcolor{comment}{// <image\_index0> <anchor\_index0> <tile\_col0> <tile\_row0>}
29 \textcolor{comment}{// <image\_index1> <anchor\_index1> <tile\_col1> <tile\_row1>}
30 \textcolor{comment}{// ...}
31 \textcolor{comment}{// Frame <frame\_index1)}
32 \textcolor{comment}{// ...}
33 \textcolor{comment}{//}
34 \textcolor{comment}{// The "Frame" markers indicate a new render frame and thus a new tile list}
35 \textcolor{comment}{// will be started and the old one flushed.  The image\_indexN, anchor\_indexN,}
36 \textcolor{comment}{// tile\_colN, and tile\_rowN identify an individual tile to be decoded and}
37 \textcolor{comment}{// to use anchor\_indexN anchor image for MCP.}
38 
39 \textcolor{preprocessor}{#include <stdio.h>}
40 \textcolor{preprocessor}{#include <stdlib.h>}
41 \textcolor{preprocessor}{#include <string.h>}
42 
43 \textcolor{preprocessor}{#include "\hyperlink{aom__decoder_8h}{aom/aom\_decoder.h}"}
44 \textcolor{preprocessor}{#include "\hyperlink{aom__encoder_8h}{aom/aom\_encoder.h}"}
45 \textcolor{preprocessor}{#include "aom/aom\_integer.h"}
46 \textcolor{preprocessor}{#include "\hyperlink{aomdx_8h}{aom/aomdx.h}"}
47 \textcolor{preprocessor}{#include "aom\_dsp/bitwriter\_buffer.h"}
48 \textcolor{preprocessor}{#include "common/tools\_common.h"}
49 \textcolor{preprocessor}{#include "common/video\_reader.h"}
50 \textcolor{preprocessor}{#include "common/video\_writer.h"}
51 
52 \textcolor{preprocessor}{#define MAX\_TILES 512}
53 
54 \textcolor{keyword}{static} \textcolor{keyword}{const} \textcolor{keywordtype}{char} *exec\_name;
55 
56 \textcolor{keywordtype}{void} usage\_exit(\textcolor{keywordtype}{void}) \{
57   fprintf(stderr, \textcolor{stringliteral}{"Usage: %s <infile> <outfile> <num\_references> <tile\_list>\(\backslash\)n"},
58           exec\_name);
59   exit(EXIT\_FAILURE);
60 \}
61 
62 \textcolor{preprocessor}{#define ALIGN\_POWER\_OF\_TWO(value, n) \(\backslash\)}
63 \textcolor{preprocessor}{  (((value) + ((1 << (n)) - 1)) & ~((1 << (n)) - 1))}
64 
65 \textcolor{keyword}{const} \textcolor{keywordtype}{int} output\_frame\_width = 512;
66 \textcolor{keyword}{const} \textcolor{keywordtype}{int} output\_frame\_height = 512;
67 
68 \textcolor{comment}{// Spec:}
69 \textcolor{comment}{// typedef struct \{}
70 \textcolor{comment}{//   uint8\_t anchor\_frame\_idx;}
71 \textcolor{comment}{//   uint8\_t tile\_row;}
72 \textcolor{comment}{//   uint8\_t tile\_col;}
73 \textcolor{comment}{//   uint16\_t coded\_tile\_data\_size\_minus\_1;}
74 \textcolor{comment}{//   uint8\_t *coded\_tile\_data;}
75 \textcolor{comment}{// \} TILE\_LIST\_ENTRY;}
76 
77 \textcolor{comment}{// Tile list entry provided by the application}
78 \textcolor{keyword}{typedef} \textcolor{keyword}{struct }\{
79   \textcolor{keywordtype}{int} image\_idx;
80   \textcolor{keywordtype}{int} reference\_idx;
81   \textcolor{keywordtype}{int} tile\_col;
82   \textcolor{keywordtype}{int} tile\_row;
83 \} TILE\_LIST\_INFO;
84 
85 \textcolor{keyword}{static} \textcolor{keywordtype}{int} get\_image\_bps(\hyperlink{aom__image_8h_ab71efff8c7f49380fad23b93bc2e9bfc}{aom\_img\_fmt\_t} fmt) \{
86   \textcolor{keywordflow}{switch} (fmt) \{
87     \textcolor{keywordflow}{case} \hyperlink{aom__image_8h_a930317c04b4bd0a660bb5e744055523cabd778a3d697463e89d12a1117f417b60}{AOM\_IMG\_FMT\_I420}: \textcolor{keywordflow}{return} 12;
88     \textcolor{keywordflow}{case} \hyperlink{aom__image_8h_a930317c04b4bd0a660bb5e744055523cab2f75281e94ebc0f0bc728ef287cd3e8}{AOM\_IMG\_FMT\_I422}: \textcolor{keywordflow}{return} 16;
89     \textcolor{keywordflow}{case} \hyperlink{aom__image_8h_a930317c04b4bd0a660bb5e744055523ca89d423506e948ab7d3b98b5750b92655}{AOM\_IMG\_FMT\_I444}: \textcolor{keywordflow}{return} 24;
90     \textcolor{keywordflow}{case} \hyperlink{aom__image_8h_a930317c04b4bd0a660bb5e744055523ca20a9cf30277260685642b4cfb4e9273b}{AOM\_IMG\_FMT\_I42016}: \textcolor{keywordflow}{return} 24;
91     \textcolor{keywordflow}{case} \hyperlink{aom__image_8h_a930317c04b4bd0a660bb5e744055523ca064683ed4260fc6244af6cfc9d261c22}{AOM\_IMG\_FMT\_I42216}: \textcolor{keywordflow}{return} 32;
92     \textcolor{keywordflow}{case} \hyperlink{aom__image_8h_a930317c04b4bd0a660bb5e744055523cab9b93d397dedbdd6bfafec84d1f8f0f5}{AOM\_IMG\_FMT\_I44416}: \textcolor{keywordflow}{return} 48;
93     \textcolor{keywordflow}{default}: die(\textcolor{stringliteral}{"Invalid image format"});
94   \}
95   \textcolor{keywordflow}{return} 0;
96 \}
97 
98 \textcolor{keywordtype}{void} process\_tile\_list(\textcolor{keyword}{const} TILE\_LIST\_INFO *tiles, \textcolor{keywordtype}{int} num\_tiles,
99                        \hyperlink{group__encoder_ga958524226c9a65251c9e4f7bb78fc606}{aom\_codec\_pts\_t} tl\_pts, \textcolor{keywordtype}{unsigned} \textcolor{keywordtype}{char} **frames,
100                        \textcolor{keyword}{const} \textcolor{keywordtype}{size\_t} *frame\_sizes, \hyperlink{structaom__codec__ctx}{aom\_codec\_ctx\_t} *codec,
101                        \textcolor{keywordtype}{unsigned} \textcolor{keywordtype}{char} *tl\_buf, AvxVideoWriter *writer,
102                        uint8\_t output\_frame\_width\_in\_tiles\_minus\_1,
103                        uint8\_t output\_frame\_height\_in\_tiles\_minus\_1) \{
104   \textcolor{keywordtype}{unsigned} \textcolor{keywordtype}{char} *tl = tl\_buf;
105   \textcolor{keyword}{struct }aom\_write\_bit\_buffer wb = \{ tl, 0 \};
106   \textcolor{keywordtype}{unsigned} \textcolor{keywordtype}{char} *saved\_obu\_size\_loc = NULL;
107   uint32\_t tile\_list\_obu\_header\_size = 0;
108   uint32\_t tile\_list\_obu\_size = 0;
109   \textcolor{keywordtype}{int} num\_tiles\_minus\_1 = num\_tiles - 1;
110   \textcolor{keywordtype}{int} i;
111 
112   \textcolor{comment}{// Write the tile list OBU header that is 1 byte long.}
113   aom\_wb\_write\_literal(&wb, 0, 1);  \textcolor{comment}{// forbidden bit.}
114   aom\_wb\_write\_literal(&wb, 8, 4);  \textcolor{comment}{// tile list OBU: "1000"}
115   aom\_wb\_write\_literal(&wb, 0, 1);  \textcolor{comment}{// obu\_extension = 0}
116   aom\_wb\_write\_literal(&wb, 1, 1);  \textcolor{comment}{// obu\_has\_size\_field}
117   aom\_wb\_write\_literal(&wb, 0, 1);  \textcolor{comment}{// reserved}
118   tl++;
119   tile\_list\_obu\_header\_size++;
120 
121   \textcolor{comment}{// Write the OBU size using a fixed length\_field\_size of 4 bytes.}
122   saved\_obu\_size\_loc = tl;
123   \textcolor{comment}{// aom\_wb\_write\_unsigned\_literal(&wb, data, bits) requires that bits <= 32.}
124   aom\_wb\_write\_unsigned\_literal(&wb, 0, 32);
125   tl += 4;
126   tile\_list\_obu\_header\_size += 4;
127 
128   \textcolor{comment}{// write\_tile\_list\_obu()}
129   aom\_wb\_write\_literal(&wb, output\_frame\_width\_in\_tiles\_minus\_1, 8);
130   aom\_wb\_write\_literal(&wb, output\_frame\_height\_in\_tiles\_minus\_1, 8);
131   aom\_wb\_write\_literal(&wb, num\_tiles\_minus\_1, 16);
132   tl += 4;
133   tile\_list\_obu\_size += 4;
134 
135   \textcolor{comment}{// Write each tile's data}
136   \textcolor{keywordflow}{for} (i = 0; i <= num\_tiles\_minus\_1; i++) \{
137     \hyperlink{structaom__tile__data}{aom\_tile\_data} tile\_data = \{ 0, NULL, 0 \};
138 
139     \textcolor{keywordtype}{int} image\_idx = tiles[i].image\_idx;
140     \textcolor{keywordtype}{int} ref\_idx = tiles[i].reference\_idx;
141     \textcolor{keywordtype}{int} tc = tiles[i].tile\_col;
142     \textcolor{keywordtype}{int} tr = tiles[i].tile\_row;
143 
144     \textcolor{comment}{// Reset bit writer to the right location.}
145     wb.bit\_buffer = tl;
146     wb.bit\_offset = 0;
147 
148     \textcolor{keywordtype}{size\_t} frame\_size = frame\_sizes[image\_idx];
149     \textcolor{keyword}{const} \textcolor{keywordtype}{unsigned} \textcolor{keywordtype}{char} *frame = frames[image\_idx];
150 
151     \hyperlink{group__codec_ga51eb332a40dcacc39000ab8e0be36b79}{aom\_codec\_control\_}(codec, \hyperlink{group__aom__decoder_gga3865fd4b3192489baa9a5c3632ebe97bac056b4cf80427fd05e3c4c9fc46edb78}{AV1\_SET\_DECODE\_TILE\_ROW}, tr);
152     \hyperlink{group__codec_ga51eb332a40dcacc39000ab8e0be36b79}{aom\_codec\_control\_}(codec, AV1\_SET\_DECODE\_TILE\_COL, tc);
153 
154     \hyperlink{group__codec_gaaae61e0f8663e6137f1e228757248e7c}{aom\_codec\_err\_t} aom\_status =
155         \hyperlink{group__decoder_gab03fdb999d1f83a5896869a3ba5f68f7}{aom\_codec\_decode}(codec, frame, frame\_size, NULL);
156     \textcolor{keywordflow}{if} (aom\_status) die\_codec(codec, \textcolor{stringliteral}{"Failed to decode tile."});
157 
158     \hyperlink{group__codec_ga51eb332a40dcacc39000ab8e0be36b79}{aom\_codec\_control\_}(codec, \hyperlink{group__aom__decoder_gga3865fd4b3192489baa9a5c3632ebe97badf1e96275f692bc97ddb4ce2fbdb456e}{AV1D\_GET\_TILE\_DATA}, &tile\_data);
159 
160     \textcolor{comment}{// Copy over tile info.}
161     \textcolor{comment}{//  uint8\_t anchor\_frame\_idx;}
162     \textcolor{comment}{//  uint8\_t tile\_row;}
163     \textcolor{comment}{//  uint8\_t tile\_col;}
164     \textcolor{comment}{//  uint16\_t coded\_tile\_data\_size\_minus\_1;}
165     \textcolor{comment}{//  uint8\_t *coded\_tile\_data;}
166     uint32\_t tile\_info\_bytes = 5;
167     aom\_wb\_write\_literal(&wb, ref\_idx, 8);
168     aom\_wb\_write\_literal(&wb, tr, 8);
169     aom\_wb\_write\_literal(&wb, tc, 8);
170     aom\_wb\_write\_literal(&wb, (\textcolor{keywordtype}{int})tile\_data.\hyperlink{structaom__tile__data_a4451b0bcd81b4959484745df35a9fbba}{coded\_tile\_data\_size} - 1, 16);
171     tl += tile\_info\_bytes;
172 
173     memcpy(tl, (uint8\_t *)tile\_data.\hyperlink{structaom__tile__data_a05898249ddaf5ba799dd471113b0e51e}{coded\_tile\_data},
174            tile\_data.\hyperlink{structaom__tile__data_a4451b0bcd81b4959484745df35a9fbba}{coded\_tile\_data\_size});
175     tl += tile\_data.\hyperlink{structaom__tile__data_a4451b0bcd81b4959484745df35a9fbba}{coded\_tile\_data\_size};
176 
177     tile\_list\_obu\_size +=
178         tile\_info\_bytes + (uint32\_t)tile\_data.\hyperlink{structaom__tile__data_a4451b0bcd81b4959484745df35a9fbba}{coded\_tile\_data\_size};
179   \}
180 
181   \textcolor{comment}{// Write tile list OBU size.}
182   \textcolor{keywordtype}{size\_t} bytes\_written = 0;
183   \textcolor{keywordflow}{if} (aom\_uleb\_encode\_fixed\_size(tile\_list\_obu\_size, 4, 4, saved\_obu\_size\_loc,
184                                  &bytes\_written))
185     die\_codec(codec, \textcolor{stringliteral}{"Failed to encode the tile list obu size."});
186 
187   \textcolor{comment}{// Copy the tile list.}
188   \textcolor{keywordflow}{if} (!aom\_video\_writer\_write\_frame(
189           writer, tl\_buf, tile\_list\_obu\_header\_size + tile\_list\_obu\_size,
190           tl\_pts))
191     die\_codec(codec, \textcolor{stringliteral}{"Failed to copy compressed tile list."});
192 \}
193 
194 \textcolor{keywordtype}{int} main(\textcolor{keywordtype}{int} argc, \textcolor{keywordtype}{char} **argv) \{
195   \hyperlink{structaom__codec__ctx}{aom\_codec\_ctx\_t} codec;
196   AvxVideoReader *reader = NULL;
197   AvxVideoWriter *writer = NULL;
198   \textcolor{keyword}{const} AvxInterface *decoder = NULL;
199   \textcolor{keyword}{const} AvxVideoInfo *info = NULL;
200   \textcolor{keywordtype}{int} num\_references;
201   \textcolor{keywordtype}{int} i;
202   \hyperlink{group__encoder_ga958524226c9a65251c9e4f7bb78fc606}{aom\_codec\_pts\_t} pts;
203   \textcolor{keyword}{const} \textcolor{keywordtype}{char} *tile\_list\_file = NULL;
204 
205   exec\_name = argv[0];
206   \textcolor{keywordflow}{if} (argc != 5) die(\textcolor{stringliteral}{"Invalid number of arguments."});
207 
208   reader = aom\_video\_reader\_open(argv[1]);
209   \textcolor{keywordflow}{if} (!reader) die(\textcolor{stringliteral}{"Failed to open %s for reading."}, argv[1]);
210 
211   num\_references = (int)strtol(argv[3], NULL, 0);
212   info = aom\_video\_reader\_get\_info(reader);
213 
214   \textcolor{comment}{// The writer to write out ivf file in tile list OBU, which can be decoded by}
215   \textcolor{comment}{// AV1 decoder.}
216   writer = aom\_video\_writer\_open(argv[2], kContainerIVF, info);
217   \textcolor{keywordflow}{if} (!writer) die(\textcolor{stringliteral}{"Failed to open %s for writing"}, argv[2]);
218 
219   tile\_list\_file = argv[4];
220 
221   decoder = get\_aom\_decoder\_by\_fourcc(info->codec\_fourcc);
222   \textcolor{keywordflow}{if} (!decoder) die(\textcolor{stringliteral}{"Unknown input codec."});
223   printf(\textcolor{stringliteral}{"Using %s\(\backslash\)n"}, \hyperlink{group__codec_ga013b1f6d96b2cf9489396311a7e5179b}{aom\_codec\_iface\_name}(decoder->codec\_interface()));
224 
225   \textcolor{keywordflow}{if} (\hyperlink{group__decoder_gafdbfca65b19ab1f6d72b32cd01753b9b}{aom\_codec\_dec\_init}(&codec, decoder->codec\_interface(), NULL, 0))
226     die\_codec(&codec, \textcolor{stringliteral}{"Failed to initialize decoder."});
227 
228   \textcolor{comment}{// Decode anchor frames.}
229   \hyperlink{group__codec_ga51eb332a40dcacc39000ab8e0be36b79}{aom\_codec\_control\_}(&codec, \hyperlink{group__aom__decoder_gga3865fd4b3192489baa9a5c3632ebe97ba0795d8084ae8c78528c01587198df9e2}{AV1\_SET\_TILE\_MODE}, 0);
230 
231   printf(\textcolor{stringliteral}{"Reading %d reference images.\(\backslash\)n"}, num\_references);
232   \textcolor{keywordflow}{for} (i = 0; i < num\_references; ++i) \{
233     aom\_video\_reader\_read\_frame(reader);
234 
235     \textcolor{keywordtype}{size\_t} frame\_size = 0;
236     \textcolor{keyword}{const} \textcolor{keywordtype}{unsigned} \textcolor{keywordtype}{char} *frame =
237         aom\_video\_reader\_get\_frame(reader, &frame\_size);
238     pts = (\hyperlink{group__encoder_ga958524226c9a65251c9e4f7bb78fc606}{aom\_codec\_pts\_t})aom\_video\_reader\_get\_frame\_pts(reader);
239 
240     \textcolor{comment}{// Copy references bitstream directly.}
241     \textcolor{keywordflow}{if} (!aom\_video\_writer\_write\_frame(writer, frame, frame\_size, pts))
242       die\_codec(&codec, \textcolor{stringliteral}{"Failed to copy compressed anchor frame."});
243 
244     \textcolor{keywordflow}{if} (\hyperlink{group__decoder_gab03fdb999d1f83a5896869a3ba5f68f7}{aom\_codec\_decode}(&codec, frame, frame\_size, NULL))
245       die\_codec(&codec, \textcolor{stringliteral}{"Failed to decode frame."});
246   \}
247 
248   \textcolor{comment}{// Decode camera frames.}
249   \hyperlink{group__codec_ga51eb332a40dcacc39000ab8e0be36b79}{aom\_codec\_control\_}(&codec, \hyperlink{group__aom__decoder_gga3865fd4b3192489baa9a5c3632ebe97ba0795d8084ae8c78528c01587198df9e2}{AV1\_SET\_TILE\_MODE}, 1);
250   \hyperlink{group__codec_ga51eb332a40dcacc39000ab8e0be36b79}{aom\_codec\_control\_}(&codec, \hyperlink{group__aom__decoder_gga3865fd4b3192489baa9a5c3632ebe97baffdaca91296725bd16142a33f3cc6522}{AV1D\_EXT\_TILE\_DEBUG}, 1);
251 
252   FILE *infile = aom\_video\_reader\_get\_file(reader);
253   \textcolor{comment}{// Record the offset of the first camera image.}
254   \textcolor{keyword}{const} FileOffset camera\_frame\_pos = ftello(infile);
255 
256   printf(\textcolor{stringliteral}{"Loading compressed frames into memory.\(\backslash\)n"});
257 
258   \textcolor{comment}{// Count the frames in the lightfield.}
259   \textcolor{keywordtype}{int} num\_frames = 0;
260   \textcolor{keywordflow}{while} (aom\_video\_reader\_read\_frame(reader)) \{
261     ++num\_frames;
262   \}
263   \textcolor{keywordflow}{if} (num\_frames < 1) die(\textcolor{stringliteral}{"Input light field has no frames."});
264 
265   \textcolor{comment}{// Read all of the lightfield frames into memory.}
266   \textcolor{keywordtype}{unsigned} \textcolor{keywordtype}{char} **frames =
267       (\textcolor{keywordtype}{unsigned} \textcolor{keywordtype}{char} **)malloc(num\_frames * \textcolor{keyword}{sizeof}(\textcolor{keywordtype}{unsigned} \textcolor{keywordtype}{char} *));
268   \textcolor{keywordtype}{size\_t} *frame\_sizes = (\textcolor{keywordtype}{size\_t} *)malloc(num\_frames * \textcolor{keyword}{sizeof}(\textcolor{keywordtype}{size\_t}));
269   \textcolor{comment}{// Seek to the first camera image.}
270   fseeko(infile, camera\_frame\_pos, SEEK\_SET);
271   \textcolor{keywordflow}{for} (\textcolor{keywordtype}{int} f = 0; f < num\_frames; ++f) \{
272     aom\_video\_reader\_read\_frame(reader);
273     \textcolor{keywordtype}{size\_t} frame\_size = 0;
274     \textcolor{keyword}{const} \textcolor{keywordtype}{unsigned} \textcolor{keywordtype}{char} *frame =
275         aom\_video\_reader\_get\_frame(reader, &frame\_size);
276     frames[f] = (\textcolor{keywordtype}{unsigned} \textcolor{keywordtype}{char} *)malloc(frame\_size * \textcolor{keyword}{sizeof}(\textcolor{keywordtype}{unsigned} \textcolor{keywordtype}{char}));
277     memcpy(frames[f], frame, frame\_size);
278     frame\_sizes[f] = frame\_size;
279   \}
280   printf(\textcolor{stringliteral}{"Read %d frames.\(\backslash\)n"}, num\_frames);
281 
282   \textcolor{comment}{// Copy first camera frame for getting camera frame header. This is done}
283   \textcolor{comment}{// only once.}
284   \{
285     \textcolor{keywordtype}{size\_t} frame\_size = frame\_sizes[0];
286     \textcolor{keyword}{const} \textcolor{keywordtype}{unsigned} \textcolor{keywordtype}{char} *frame = frames[0];
287     pts = num\_references;
288     \hyperlink{structaom__tile__data}{aom\_tile\_data} frame\_header\_info = \{ 0, NULL, 0 \};
289 
290     \textcolor{comment}{// Need to decode frame header to get camera frame header info. So, here}
291     \textcolor{comment}{// decoding 1 tile is enough.}
292     \hyperlink{group__codec_ga51eb332a40dcacc39000ab8e0be36b79}{aom\_codec\_control\_}(&codec, \hyperlink{group__aom__decoder_gga3865fd4b3192489baa9a5c3632ebe97bac056b4cf80427fd05e3c4c9fc46edb78}{AV1\_SET\_DECODE\_TILE\_ROW}, 0);
293     \hyperlink{group__codec_ga51eb332a40dcacc39000ab8e0be36b79}{aom\_codec\_control\_}(&codec, AV1\_SET\_DECODE\_TILE\_COL, 0);
294 
295     \hyperlink{group__codec_gaaae61e0f8663e6137f1e228757248e7c}{aom\_codec\_err\_t} aom\_status =
296         \hyperlink{group__decoder_gab03fdb999d1f83a5896869a3ba5f68f7}{aom\_codec\_decode}(&codec, frame, frame\_size, NULL);
297     \textcolor{keywordflow}{if} (aom\_status) die\_codec(&codec, \textcolor{stringliteral}{"Failed to decode tile."});
298 
299     \hyperlink{group__codec_ga51eb332a40dcacc39000ab8e0be36b79}{aom\_codec\_control\_}(&codec, \hyperlink{group__aom__decoder_gga3865fd4b3192489baa9a5c3632ebe97baed16ed4514ea1bd2847e607ca880b246}{AV1D\_GET\_FRAME\_HEADER\_INFO}, &
      frame\_header\_info);
300 
301     \textcolor{keywordtype}{size\_t} obu\_size\_offset =
302         (uint8\_t *)frame\_header\_info.\hyperlink{structaom__tile__data_a05898249ddaf5ba799dd471113b0e51e}{coded\_tile\_data} - frame;
303     \textcolor{keywordtype}{size\_t} length\_field\_size = frame\_header\_info.\hyperlink{structaom__tile__data_a4451b0bcd81b4959484745df35a9fbba}{coded\_tile\_data\_size};
304     \textcolor{comment}{// Remove ext-tile tile info.}
305     uint32\_t frame\_header\_size = (uint32\_t)frame\_header\_info.\hyperlink{structaom__tile__data_a936851e515bcea0af38d2d091f5adf65}{extra\_size} - 1;
306     \textcolor{keywordtype}{size\_t} bytes\_to\_copy =
307         obu\_size\_offset + length\_field\_size + frame\_header\_size;
308 
309     \textcolor{keywordtype}{unsigned} \textcolor{keywordtype}{char} *frame\_hdr\_buf = (\textcolor{keywordtype}{unsigned} \textcolor{keywordtype}{char} *)malloc(bytes\_to\_copy);
310     \textcolor{keywordflow}{if} (frame\_hdr\_buf == NULL)
311       die\_codec(&codec, \textcolor{stringliteral}{"Failed to allocate frame header buffer."});
312 
313     memcpy(frame\_hdr\_buf, frame, bytes\_to\_copy);
314 
315     \textcolor{comment}{// Update frame header OBU size.}
316     \textcolor{keywordtype}{size\_t} bytes\_written = 0;
317     \textcolor{keywordflow}{if} (aom\_uleb\_encode\_fixed\_size(
318             frame\_header\_size, length\_field\_size, length\_field\_size,
319             frame\_hdr\_buf + obu\_size\_offset, &bytes\_written))
320       die\_codec(&codec, \textcolor{stringliteral}{"Failed to encode the tile list obu size."});
321 
322     \textcolor{comment}{// Copy camera frame header bitstream.}
323     \textcolor{keywordflow}{if} (!aom\_video\_writer\_write\_frame(writer, frame\_hdr\_buf, bytes\_to\_copy,
324                                       pts))
325       die\_codec(&codec, \textcolor{stringliteral}{"Failed to copy compressed camera frame header."});
326     free(frame\_hdr\_buf);
327   \}
328 
329   \textcolor{comment}{// Read out the image format.}
330   \hyperlink{aom__image_8h_ab71efff8c7f49380fad23b93bc2e9bfc}{aom\_img\_fmt\_t} ref\_fmt = 0;
331   \textcolor{keywordflow}{if} (\hyperlink{group__codec_ga6da974f4eeaba1fa74106b28d0fe6ac5}{aom\_codec\_control}(&codec, \hyperlink{group__aom__decoder_gga3865fd4b3192489baa9a5c3632ebe97bacd7229e5fb766670fe995739931c2ee3}{AV1D\_GET\_IMG\_FORMAT}, &ref\_fmt))
332     die\_codec(&codec, \textcolor{stringliteral}{"Failed to get the image format"});
333   \textcolor{keyword}{const} \textcolor{keywordtype}{int} bps = get\_image\_bps(ref\_fmt);
334   \textcolor{keywordflow}{if} (!bps) die\_codec(&codec, \textcolor{stringliteral}{"Invalid image format."});
335   \textcolor{comment}{// read out the tile size.}
336   \textcolor{keywordtype}{unsigned} \textcolor{keywordtype}{int} tile\_size = 0;
337   \textcolor{keywordflow}{if} (\hyperlink{group__codec_ga6da974f4eeaba1fa74106b28d0fe6ac5}{aom\_codec\_control}(&codec, \hyperlink{group__aom__decoder_gga3865fd4b3192489baa9a5c3632ebe97ba4d9799d9e520785870b8d1f73a19c3c4}{AV1D\_GET\_TILE\_SIZE}, &tile\_size))
338     die\_codec(&codec, \textcolor{stringliteral}{"Failed to get the tile size"});
339   \textcolor{keyword}{const} \textcolor{keywordtype}{unsigned} \textcolor{keywordtype}{int} tile\_width = tile\_size >> 16;
340   \textcolor{keyword}{const} \textcolor{keywordtype}{unsigned} \textcolor{keywordtype}{int} tile\_height = tile\_size & 65535;
341   \textcolor{comment}{// Allocate a buffer to store tile list bitstream.}
342   \textcolor{keyword}{const} \textcolor{keywordtype}{size\_t} data\_sz = MAX\_TILES * ALIGN\_POWER\_OF\_TWO(tile\_width, 5) *
343                          ALIGN\_POWER\_OF\_TWO(tile\_height, 5) * bps / 8;
344 
345   \textcolor{keywordtype}{unsigned} \textcolor{keywordtype}{char} *tl\_buf = (\textcolor{keywordtype}{unsigned} \textcolor{keywordtype}{char} *)malloc(data\_sz);
346   \textcolor{keywordflow}{if} (tl\_buf == NULL) die\_codec(&codec, \textcolor{stringliteral}{"Failed to allocate tile list buffer."});
347 
348   \hyperlink{group__encoder_ga958524226c9a65251c9e4f7bb78fc606}{aom\_codec\_pts\_t} tl\_pts = num\_references;
349   \textcolor{keyword}{const} uint8\_t output\_frame\_width\_in\_tiles\_minus\_1 =
350       output\_frame\_width / tile\_width - 1;
351   \textcolor{keyword}{const} uint8\_t output\_frame\_height\_in\_tiles\_minus\_1 =
352       output\_frame\_height / tile\_height - 1;
353 
354   printf(\textcolor{stringliteral}{"Reading tile list from file.\(\backslash\)n"});
355   \textcolor{keywordtype}{char} line[1024];
356   FILE *tile\_list\_fptr = fopen(tile\_list\_file, \textcolor{stringliteral}{"r"});
357   \textcolor{keywordflow}{if} (!tile\_list\_fptr) die\_codec(&codec, \textcolor{stringliteral}{"Failed to open tile list file."});
358   \textcolor{keywordtype}{int} num\_tiles = 0;
359   TILE\_LIST\_INFO tiles[MAX\_TILES];
360   \textcolor{keywordflow}{while} ((fgets(line, 1024, tile\_list\_fptr)) != NULL) \{
361     \textcolor{keywordflow}{if} (line[0] == \textcolor{charliteral}{'F'} || num\_tiles >= MAX\_TILES) \{
362       \textcolor{comment}{// Flush existing tile list and start another, either because we hit a}
363       \textcolor{comment}{// new render frame or because we've hit our max number of tiles per list.}
364       \textcolor{keywordflow}{if} (num\_tiles > 0) \{
365         process\_tile\_list(tiles, num\_tiles, tl\_pts, frames, frame\_sizes, &codec,
366                           tl\_buf, writer, output\_frame\_width\_in\_tiles\_minus\_1,
367                           output\_frame\_height\_in\_tiles\_minus\_1);
368         ++tl\_pts;
369       \}
370       num\_tiles = 0;
371     \}
372     \textcolor{keywordflow}{if} (line[0] == \textcolor{charliteral}{'F'}) \{
373       \textcolor{keywordflow}{continue};
374     \}
375     \textcolor{keywordflow}{if} (sscanf(line, \textcolor{stringliteral}{"%d %d %d %d"}, &tiles[num\_tiles].image\_idx,
376                &tiles[num\_tiles].reference\_idx, &tiles[num\_tiles].tile\_col,
377                &tiles[num\_tiles].tile\_row) == 4) \{
378       \textcolor{keywordflow}{if} (tiles[num\_tiles].image\_idx >= num\_frames) \{
379         die(\textcolor{stringliteral}{"Tile list image\_idx out of bounds: %d >= %d."},
380             tiles[num\_tiles].image\_idx, num\_frames);
381       \}
382       \textcolor{keywordflow}{if} (tiles[num\_tiles].reference\_idx >= num\_references) \{
383         die(\textcolor{stringliteral}{"Tile list reference\_idx out of bounds: %d >= %d."},
384             tiles[num\_tiles].reference\_idx, num\_references);
385       \}
386       ++num\_tiles;
387     \}
388   \}
389   \textcolor{keywordflow}{if} (num\_tiles > 0) \{
390     \textcolor{comment}{// Flush out the last tile list.}
391     process\_tile\_list(tiles, num\_tiles, tl\_pts, frames, frame\_sizes, &codec,
392                       tl\_buf, writer, output\_frame\_width\_in\_tiles\_minus\_1,
393                       output\_frame\_height\_in\_tiles\_minus\_1);
394     ++tl\_pts;
395   \}
396 
397   \textcolor{keyword}{const} \textcolor{keywordtype}{int} num\_tile\_lists = (int)(tl\_pts - pts);
398   printf(\textcolor{stringliteral}{"Finished processing tile lists.  Num tile lists: %d.\(\backslash\)n"},
399          num\_tile\_lists);
400   free(tl\_buf);
401   \textcolor{keywordflow}{for} (\textcolor{keywordtype}{int} f = 0; f < num\_frames; ++f) \{
402     free(frames[f]);
403   \}
404   free(frame\_sizes);
405   free(frames);
406   \textcolor{keywordflow}{if} (\hyperlink{group__codec_ga9b60e186f61ba2d6ab2b8069b76a15c5}{aom\_codec\_destroy}(&codec)) die\_codec(&codec, \textcolor{stringliteral}{"Failed to destroy codec"});
407   aom\_video\_writer\_close(writer);
408   aom\_video\_reader\_close(reader);
409 
410   \textcolor{keywordflow}{return} EXIT\_SUCCESS;
411 \}
\end{DoxyCodeInclude}
 \hypertarget{example_aomdec}{}\subsection{aomdec}\label{example_aomdec}

\begin{DoxyCodeInclude}
1 \textcolor{comment}{/*}
2 \textcolor{comment}{ * Copyright (c) 2016, Alliance for Open Media. All rights reserved}
3 \textcolor{comment}{ *}
4 \textcolor{comment}{ * This source code is subject to the terms of the BSD 2 Clause License and}
5 \textcolor{comment}{ * the Alliance for Open Media Patent License 1.0. If the BSD 2 Clause License}
6 \textcolor{comment}{ * was not distributed with this source code in the LICENSE file, you can}
7 \textcolor{comment}{ * obtain it at www.aomedia.org/license/software. If the Alliance for Open}
8 \textcolor{comment}{ * Media Patent License 1.0 was not distributed with this source code in the}
9 \textcolor{comment}{ * PATENTS file, you can obtain it at www.aomedia.org/license/patent.}
10 \textcolor{comment}{ */}
11 
12 \textcolor{preprocessor}{#include <assert.h>}
13 \textcolor{preprocessor}{#include <stdio.h>}
14 \textcolor{preprocessor}{#include <stdlib.h>}
15 \textcolor{preprocessor}{#include <stdarg.h>}
16 \textcolor{preprocessor}{#include <string.h>}
17 \textcolor{preprocessor}{#include <limits.h>}
18 
19 \textcolor{preprocessor}{#include "config/aom\_config.h"}
20 
21 \textcolor{preprocessor}{#if CONFIG\_OS\_SUPPORT}
22 \textcolor{preprocessor}{#if HAVE\_UNISTD\_H}
23 \textcolor{preprocessor}{#include <unistd.h>}  \textcolor{comment}{// NOLINT}
24 \textcolor{preprocessor}{#elif !defined(STDOUT\_FILENO)}
25 \textcolor{preprocessor}{#define STDOUT\_FILENO 1}
26 \textcolor{preprocessor}{#endif}
27 \textcolor{preprocessor}{#endif}
28 
29 \textcolor{preprocessor}{#include "\hyperlink{aom__decoder_8h}{aom/aom\_decoder.h}"}
30 \textcolor{preprocessor}{#include "\hyperlink{aomdx_8h}{aom/aomdx.h}"}
31 \textcolor{preprocessor}{#include "aom\_ports/aom\_timer.h"}
32 \textcolor{preprocessor}{#include "aom\_ports/mem\_ops.h"}
33 \textcolor{preprocessor}{#include "common/args.h"}
34 \textcolor{preprocessor}{#include "common/ivfdec.h"}
35 \textcolor{preprocessor}{#include "common/md5\_utils.h"}
36 \textcolor{preprocessor}{#include "common/obudec.h"}
37 \textcolor{preprocessor}{#include "common/tools\_common.h"}
38 
39 \textcolor{preprocessor}{#if CONFIG\_WEBM\_IO}
40 \textcolor{preprocessor}{#include "common/webmdec.h"}
41 \textcolor{preprocessor}{#endif}
42 
43 \textcolor{preprocessor}{#include "common/rawenc.h"}
44 \textcolor{preprocessor}{#include "common/y4menc.h"}
45 
46 \textcolor{preprocessor}{#if CONFIG\_LIBYUV}
47 \textcolor{preprocessor}{#include "third\_party/libyuv/include/libyuv/scale.h"}
48 \textcolor{preprocessor}{#endif}
49 
50 \textcolor{keyword}{static} \textcolor{keyword}{const} \textcolor{keywordtype}{char} *exec\_name;
51 
52 \textcolor{keyword}{struct }AvxDecInputContext \{
53   \textcolor{keyword}{struct }AvxInputContext *aom\_input\_ctx;
54   \textcolor{keyword}{struct }ObuDecInputContext *obu\_ctx;
55   \textcolor{keyword}{struct }WebmInputContext *webm\_ctx;
56 \};
57 
58 \textcolor{keyword}{static} \textcolor{keyword}{const} arg\_def\_t help =
59     ARG\_DEF(NULL, \textcolor{stringliteral}{"help"}, 0, \textcolor{stringliteral}{"Show usage options and exit"});
60 \textcolor{keyword}{static} \textcolor{keyword}{const} arg\_def\_t looparg =
61     ARG\_DEF(NULL, \textcolor{stringliteral}{"loops"}, 1, \textcolor{stringliteral}{"Number of times to decode the file"});
62 \textcolor{keyword}{static} \textcolor{keyword}{const} arg\_def\_t codecarg = ARG\_DEF(NULL, \textcolor{stringliteral}{"codec"}, 1, \textcolor{stringliteral}{"Codec to use"});
63 \textcolor{keyword}{static} \textcolor{keyword}{const} arg\_def\_t use\_yv12 =
64     ARG\_DEF(NULL, \textcolor{stringliteral}{"yv12"}, 0, \textcolor{stringliteral}{"Output raw YV12 frames"});
65 \textcolor{keyword}{static} \textcolor{keyword}{const} arg\_def\_t use\_i420 =
66     ARG\_DEF(NULL, \textcolor{stringliteral}{"i420"}, 0, \textcolor{stringliteral}{"Output raw I420 frames"});
67 \textcolor{keyword}{static} \textcolor{keyword}{const} arg\_def\_t flipuvarg =
68     ARG\_DEF(NULL, \textcolor{stringliteral}{"flipuv"}, 0, \textcolor{stringliteral}{"Flip the chroma planes in the output"});
69 \textcolor{keyword}{static} \textcolor{keyword}{const} arg\_def\_t rawvideo =
70     ARG\_DEF(NULL, \textcolor{stringliteral}{"rawvideo"}, 0, \textcolor{stringliteral}{"Output raw YUV frames"});
71 \textcolor{keyword}{static} \textcolor{keyword}{const} arg\_def\_t noblitarg =
72     ARG\_DEF(NULL, \textcolor{stringliteral}{"noblit"}, 0, \textcolor{stringliteral}{"Don't process the decoded frames"});
73 \textcolor{keyword}{static} \textcolor{keyword}{const} arg\_def\_t progressarg =
74     ARG\_DEF(NULL, \textcolor{stringliteral}{"progress"}, 0, \textcolor{stringliteral}{"Show progress after each frame decodes"});
75 \textcolor{keyword}{static} \textcolor{keyword}{const} arg\_def\_t limitarg =
76     ARG\_DEF(NULL, \textcolor{stringliteral}{"limit"}, 1, \textcolor{stringliteral}{"Stop decoding after n frames"});
77 \textcolor{keyword}{static} \textcolor{keyword}{const} arg\_def\_t skiparg =
78     ARG\_DEF(NULL, \textcolor{stringliteral}{"skip"}, 1, \textcolor{stringliteral}{"Skip the first n input frames"});
79 \textcolor{keyword}{static} \textcolor{keyword}{const} arg\_def\_t postprocarg =
80     ARG\_DEF(NULL, \textcolor{stringliteral}{"postproc"}, 0, \textcolor{stringliteral}{"Postprocess decoded frames"});
81 \textcolor{keyword}{static} \textcolor{keyword}{const} arg\_def\_t summaryarg =
82     ARG\_DEF(NULL, \textcolor{stringliteral}{"summary"}, 0, \textcolor{stringliteral}{"Show timing summary"});
83 \textcolor{keyword}{static} \textcolor{keyword}{const} arg\_def\_t outputfile =
84     ARG\_DEF(\textcolor{stringliteral}{"o"}, \textcolor{stringliteral}{"output"}, 1, \textcolor{stringliteral}{"Output file name pattern (see below)"});
85 \textcolor{keyword}{static} \textcolor{keyword}{const} arg\_def\_t threadsarg =
86     ARG\_DEF(\textcolor{stringliteral}{"t"}, \textcolor{stringliteral}{"threads"}, 1, \textcolor{stringliteral}{"Max threads to use"});
87 \textcolor{keyword}{static} \textcolor{keyword}{const} arg\_def\_t verbosearg =
88     ARG\_DEF(\textcolor{stringliteral}{"v"}, \textcolor{stringliteral}{"verbose"}, 0, \textcolor{stringliteral}{"Show version string"});
89 \textcolor{keyword}{static} \textcolor{keyword}{const} arg\_def\_t scalearg =
90     ARG\_DEF(\textcolor{stringliteral}{"S"}, \textcolor{stringliteral}{"scale"}, 0, \textcolor{stringliteral}{"Scale output frames uniformly"});
91 \textcolor{keyword}{static} \textcolor{keyword}{const} arg\_def\_t continuearg =
92     ARG\_DEF(\textcolor{stringliteral}{"k"}, \textcolor{stringliteral}{"keep-going"}, 0, \textcolor{stringliteral}{"(debug) Continue decoding after error"});
93 \textcolor{keyword}{static} \textcolor{keyword}{const} arg\_def\_t fb\_arg =
94     ARG\_DEF(NULL, \textcolor{stringliteral}{"frame-buffers"}, 1, \textcolor{stringliteral}{"Number of frame buffers to use"});
95 \textcolor{keyword}{static} \textcolor{keyword}{const} arg\_def\_t md5arg =
96     ARG\_DEF(NULL, \textcolor{stringliteral}{"md5"}, 0, \textcolor{stringliteral}{"Compute the MD5 sum of the decoded frame"});
97 \textcolor{keyword}{static} \textcolor{keyword}{const} arg\_def\_t framestatsarg =
98     ARG\_DEF(NULL, \textcolor{stringliteral}{"framestats"}, 1, \textcolor{stringliteral}{"Output per-frame stats (.csv format)"});
99 \textcolor{keyword}{static} \textcolor{keyword}{const} arg\_def\_t outbitdeptharg =
100     ARG\_DEF(NULL, \textcolor{stringliteral}{"output-bit-depth"}, 1, \textcolor{stringliteral}{"Output bit-depth for decoded frames"});
101 \textcolor{keyword}{static} \textcolor{keyword}{const} arg\_def\_t isannexb =
102     ARG\_DEF(NULL, \textcolor{stringliteral}{"annexb"}, 0, \textcolor{stringliteral}{"Bitstream is in Annex-B format"});
103 \textcolor{keyword}{static} \textcolor{keyword}{const} arg\_def\_t oppointarg = ARG\_DEF(
104     NULL, \textcolor{stringliteral}{"oppoint"}, 1, \textcolor{stringliteral}{"Select an operating point of a scalable bitstream"});
105 \textcolor{keyword}{static} \textcolor{keyword}{const} arg\_def\_t outallarg = ARG\_DEF(
106     NULL, \textcolor{stringliteral}{"all-layers"}, 0, \textcolor{stringliteral}{"Output all decoded frames of a scalable bitstream"});
107 \textcolor{keyword}{static} \textcolor{keyword}{const} arg\_def\_t skipfilmgrain =
108     ARG\_DEF(NULL, \textcolor{stringliteral}{"skip-film-grain"}, 0, \textcolor{stringliteral}{"Skip film grain application"});
109 
110 \textcolor{keyword}{static} \textcolor{keyword}{const} arg\_def\_t *all\_args[] = \{
111   &help,           &codecarg,   &use\_yv12,      &use\_i420,
112   &flipuvarg,      &rawvideo,   &noblitarg,     &progressarg,
113   &limitarg,       &skiparg,    &postprocarg,   &summaryarg,
114   &outputfile,     &threadsarg, &verbosearg,    &scalearg,
115   &fb\_arg,         &md5arg,     &framestatsarg, &continuearg,
116   &outbitdeptharg, &isannexb,   &oppointarg,    &outallarg,
117   &skipfilmgrain,  NULL
118 \};
119 
120 \textcolor{preprocessor}{#if CONFIG\_LIBYUV}
121 \textcolor{keyword}{static} INLINE \textcolor{keywordtype}{int} libyuv\_scale(\hyperlink{structaom__image}{aom\_image\_t} *src, \hyperlink{structaom__image}{aom\_image\_t} *dst,
122                                FilterModeEnum mode) \{
123   \textcolor{keywordflow}{if} (src->\hyperlink{structaom__image_a6c64b1ab918d80d52eb8f5d6d957e825}{fmt} == \hyperlink{aom__image_8h_a930317c04b4bd0a660bb5e744055523ca20a9cf30277260685642b4cfb4e9273b}{AOM\_IMG\_FMT\_I42016}) \{
124     assert(dst->\hyperlink{structaom__image_a6c64b1ab918d80d52eb8f5d6d957e825}{fmt} == \hyperlink{aom__image_8h_a930317c04b4bd0a660bb5e744055523ca20a9cf30277260685642b4cfb4e9273b}{AOM\_IMG\_FMT\_I42016});
125     \textcolor{keywordflow}{return} I420Scale\_16(
126         (uint16\_t *)src->\hyperlink{structaom__image_ac54dbc5237ca2914f9ec30105dfbe302}{planes}[\hyperlink{aom__image_8h_a2ad22076006b15cf809edcaa33f6d339}{AOM\_PLANE\_Y}], src->\hyperlink{structaom__image_a6dc693d7dbc9eb06c0cdde307ca58372}{stride}[
      \hyperlink{aom__image_8h_a2ad22076006b15cf809edcaa33f6d339}{AOM\_PLANE\_Y}] / 2,
127         (uint16\_t *)src->\hyperlink{structaom__image_ac54dbc5237ca2914f9ec30105dfbe302}{planes}[AOM\_PLANE\_U], src->\hyperlink{structaom__image_a6dc693d7dbc9eb06c0cdde307ca58372}{stride}[AOM\_PLANE\_U] / 2,
128         (uint16\_t *)src->\hyperlink{structaom__image_ac54dbc5237ca2914f9ec30105dfbe302}{planes}[AOM\_PLANE\_V], src->\hyperlink{structaom__image_a6dc693d7dbc9eb06c0cdde307ca58372}{stride}[AOM\_PLANE\_V] / 2,
129         src->\hyperlink{structaom__image_a89f80b1f58d608b9d2080635f4359034}{d\_w}, src->\hyperlink{structaom__image_ab986419a1f0fff93a2dc505f47194988}{d\_h}, (uint16\_t *)dst->\hyperlink{structaom__image_ac54dbc5237ca2914f9ec30105dfbe302}{planes}[\hyperlink{aom__image_8h_a2ad22076006b15cf809edcaa33f6d339}{AOM\_PLANE\_Y}],
130         dst->\hyperlink{structaom__image_a6dc693d7dbc9eb06c0cdde307ca58372}{stride}[\hyperlink{aom__image_8h_a2ad22076006b15cf809edcaa33f6d339}{AOM\_PLANE\_Y}] / 2, (uint16\_t *)dst->\hyperlink{structaom__image_ac54dbc5237ca2914f9ec30105dfbe302}{planes}[AOM\_PLANE\_U],
131         dst->\hyperlink{structaom__image_a6dc693d7dbc9eb06c0cdde307ca58372}{stride}[AOM\_PLANE\_U] / 2, (uint16\_t *)dst->\hyperlink{structaom__image_ac54dbc5237ca2914f9ec30105dfbe302}{planes}[AOM\_PLANE\_V],
132         dst->\hyperlink{structaom__image_a6dc693d7dbc9eb06c0cdde307ca58372}{stride}[AOM\_PLANE\_V] / 2, dst->\hyperlink{structaom__image_a89f80b1f58d608b9d2080635f4359034}{d\_w}, dst->\hyperlink{structaom__image_ab986419a1f0fff93a2dc505f47194988}{d\_h}, mode);
133   \}
134   assert(src->\hyperlink{structaom__image_a6c64b1ab918d80d52eb8f5d6d957e825}{fmt} == \hyperlink{aom__image_8h_a930317c04b4bd0a660bb5e744055523cabd778a3d697463e89d12a1117f417b60}{AOM\_IMG\_FMT\_I420});
135   assert(dst->\hyperlink{structaom__image_a6c64b1ab918d80d52eb8f5d6d957e825}{fmt} == \hyperlink{aom__image_8h_a930317c04b4bd0a660bb5e744055523cabd778a3d697463e89d12a1117f417b60}{AOM\_IMG\_FMT\_I420});
136   \textcolor{keywordflow}{return} I420Scale(src->\hyperlink{structaom__image_ac54dbc5237ca2914f9ec30105dfbe302}{planes}[\hyperlink{aom__image_8h_a2ad22076006b15cf809edcaa33f6d339}{AOM\_PLANE\_Y}], src->\hyperlink{structaom__image_a6dc693d7dbc9eb06c0cdde307ca58372}{stride}[
      \hyperlink{aom__image_8h_a2ad22076006b15cf809edcaa33f6d339}{AOM\_PLANE\_Y}],
137                    src->\hyperlink{structaom__image_ac54dbc5237ca2914f9ec30105dfbe302}{planes}[AOM\_PLANE\_U], src->\hyperlink{structaom__image_a6dc693d7dbc9eb06c0cdde307ca58372}{stride}[AOM\_PLANE\_U],
138                    src->\hyperlink{structaom__image_ac54dbc5237ca2914f9ec30105dfbe302}{planes}[AOM\_PLANE\_V], src->\hyperlink{structaom__image_a6dc693d7dbc9eb06c0cdde307ca58372}{stride}[AOM\_PLANE\_V], src->
      \hyperlink{structaom__image_a89f80b1f58d608b9d2080635f4359034}{d\_w},
139                    src->\hyperlink{structaom__image_ab986419a1f0fff93a2dc505f47194988}{d\_h}, dst->\hyperlink{structaom__image_ac54dbc5237ca2914f9ec30105dfbe302}{planes}[\hyperlink{aom__image_8h_a2ad22076006b15cf809edcaa33f6d339}{AOM\_PLANE\_Y}], dst->
      \hyperlink{structaom__image_a6dc693d7dbc9eb06c0cdde307ca58372}{stride}[\hyperlink{aom__image_8h_a2ad22076006b15cf809edcaa33f6d339}{AOM\_PLANE\_Y}],
140                    dst->\hyperlink{structaom__image_ac54dbc5237ca2914f9ec30105dfbe302}{planes}[AOM\_PLANE\_U], dst->\hyperlink{structaom__image_a6dc693d7dbc9eb06c0cdde307ca58372}{stride}[AOM\_PLANE\_U],
141                    dst->\hyperlink{structaom__image_ac54dbc5237ca2914f9ec30105dfbe302}{planes}[AOM\_PLANE\_V], dst->\hyperlink{structaom__image_a6dc693d7dbc9eb06c0cdde307ca58372}{stride}[AOM\_PLANE\_V], dst->
      \hyperlink{structaom__image_a89f80b1f58d608b9d2080635f4359034}{d\_w},
142                    dst->\hyperlink{structaom__image_ab986419a1f0fff93a2dc505f47194988}{d\_h}, mode);
143 \}
144 \textcolor{preprocessor}{#endif}
145 
146 \textcolor{keyword}{static} \textcolor{keywordtype}{void} show\_help(FILE *fout, \textcolor{keywordtype}{int} shorthelp) \{
147   fprintf(fout, \textcolor{stringliteral}{"Usage: %s <options> filename\(\backslash\)n\(\backslash\)n"}, exec\_name);
148 
149   \textcolor{keywordflow}{if} (shorthelp) \{
150     fprintf(fout, \textcolor{stringliteral}{"Use --help to see the full list of options.\(\backslash\)n"});
151     \textcolor{keywordflow}{return};
152   \}
153 
154   fprintf(fout, \textcolor{stringliteral}{"Options:\(\backslash\)n"});
155   arg\_show\_usage(fout, all\_args);
156   fprintf(fout,
157           \textcolor{stringliteral}{"\(\backslash\)nOutput File Patterns:\(\backslash\)n\(\backslash\)n"}
158           \textcolor{stringliteral}{"  The -o argument specifies the name of the file(s) to "}
159           \textcolor{stringliteral}{"write to. If the\(\backslash\)n  argument does not include any escape "}
160           \textcolor{stringliteral}{"characters, the output will be\(\backslash\)n  written to a single file. "}
161           \textcolor{stringliteral}{"Otherwise, the filename will be calculated by\(\backslash\)n  expanding "}
162           \textcolor{stringliteral}{"the following escape characters:\(\backslash\)n"});
163   fprintf(fout,
164           \textcolor{stringliteral}{"\(\backslash\)n\(\backslash\)t%%w   - Frame width"}
165           \textcolor{stringliteral}{"\(\backslash\)n\(\backslash\)t%%h   - Frame height"}
166           \textcolor{stringliteral}{"\(\backslash\)n\(\backslash\)t%%<n> - Frame number, zero padded to <n> places (1..9)"}
167           \textcolor{stringliteral}{"\(\backslash\)n\(\backslash\)n  Pattern arguments are only supported in conjunction "}
168           \textcolor{stringliteral}{"with the --yv12 and\(\backslash\)n  --i420 options. If the -o option is "}
169           \textcolor{stringliteral}{"not specified, the output will be\(\backslash\)n  directed to stdout.\(\backslash\)n"});
170   fprintf(fout, \textcolor{stringliteral}{"\(\backslash\)nIncluded decoders:\(\backslash\)n\(\backslash\)n"});
171 
172   \textcolor{keywordflow}{for} (\textcolor{keywordtype}{int} i = 0; i < get\_aom\_decoder\_count(); ++i) \{
173     \textcolor{keyword}{const} AvxInterface *\textcolor{keyword}{const} decoder = get\_aom\_decoder\_by\_index(i);
174     fprintf(fout, \textcolor{stringliteral}{"    %-6s - %s\(\backslash\)n"}, decoder->name,
175             \hyperlink{group__codec_ga013b1f6d96b2cf9489396311a7e5179b}{aom\_codec\_iface\_name}(decoder->codec\_interface()));
176   \}
177 \}
178 
179 \textcolor{keywordtype}{void} usage\_exit(\textcolor{keywordtype}{void}) \{
180   show\_help(stderr, 1);
181   exit(EXIT\_FAILURE);
182 \}
183 
184 \textcolor{keyword}{static} \textcolor{keywordtype}{int} raw\_read\_frame(FILE *infile, uint8\_t **buffer, \textcolor{keywordtype}{size\_t} *bytes\_read,
185                           \textcolor{keywordtype}{size\_t} *buffer\_size) \{
186   \textcolor{keywordtype}{char} raw\_hdr[RAW\_FRAME\_HDR\_SZ];
187   \textcolor{keywordtype}{size\_t} frame\_size = 0;
188 
189   \textcolor{keywordflow}{if} (fread(raw\_hdr, RAW\_FRAME\_HDR\_SZ, 1, infile) != 1) \{
190     \textcolor{keywordflow}{if} (!feof(infile)) warn(\textcolor{stringliteral}{"Failed to read RAW frame size\(\backslash\)n"});
191   \} \textcolor{keywordflow}{else} \{
192     \textcolor{keyword}{const} \textcolor{keywordtype}{size\_t} kCorruptFrameThreshold = 256 * 1024 * 1024;
193     \textcolor{keyword}{const} \textcolor{keywordtype}{size\_t} kFrameTooSmallThreshold = 256 * 1024;
194     frame\_size = mem\_get\_le32(raw\_hdr);
195 
196     \textcolor{keywordflow}{if} (frame\_size > kCorruptFrameThreshold) \{
197       warn(\textcolor{stringliteral}{"Read invalid frame size (%u)\(\backslash\)n"}, (\textcolor{keywordtype}{unsigned} \textcolor{keywordtype}{int})frame\_size);
198       frame\_size = 0;
199     \}
200 
201     \textcolor{keywordflow}{if} (frame\_size < kFrameTooSmallThreshold) \{
202       warn(\textcolor{stringliteral}{"Warning: Read invalid frame size (%u) - not a raw file?\(\backslash\)n"},
203            (\textcolor{keywordtype}{unsigned} \textcolor{keywordtype}{int})frame\_size);
204     \}
205 
206     \textcolor{keywordflow}{if} (frame\_size > *buffer\_size) \{
207       uint8\_t *new\_buf = realloc(*buffer, 2 * frame\_size);
208       \textcolor{keywordflow}{if} (new\_buf) \{
209         *buffer = new\_buf;
210         *buffer\_size = 2 * frame\_size;
211       \} \textcolor{keywordflow}{else} \{
212         warn(\textcolor{stringliteral}{"Failed to allocate compressed data buffer\(\backslash\)n"});
213         frame\_size = 0;
214       \}
215     \}
216   \}
217 
218   \textcolor{keywordflow}{if} (!feof(infile)) \{
219     \textcolor{keywordflow}{if} (fread(*buffer, 1, frame\_size, infile) != frame\_size) \{
220       warn(\textcolor{stringliteral}{"Failed to read full frame\(\backslash\)n"});
221       \textcolor{keywordflow}{return} 1;
222     \}
223     *bytes\_read = frame\_size;
224   \}
225 
226   \textcolor{keywordflow}{return} 0;
227 \}
228 
229 \textcolor{keyword}{static} \textcolor{keywordtype}{int} read\_frame(\textcolor{keyword}{struct} AvxDecInputContext *input, uint8\_t **buf,
230                       \textcolor{keywordtype}{size\_t} *bytes\_in\_buffer, \textcolor{keywordtype}{size\_t} *buffer\_size) \{
231   \textcolor{keywordflow}{switch} (input->aom\_input\_ctx->file\_type) \{
232 \textcolor{preprocessor}{#if CONFIG\_WEBM\_IO}
233     \textcolor{keywordflow}{case} FILE\_TYPE\_WEBM:
234       \textcolor{keywordflow}{return} webm\_read\_frame(input->webm\_ctx, buf, bytes\_in\_buffer,
235                              buffer\_size);
236 \textcolor{preprocessor}{#endif}
237     \textcolor{keywordflow}{case} FILE\_TYPE\_RAW:
238       \textcolor{keywordflow}{return} raw\_read\_frame(input->aom\_input\_ctx->file, buf, bytes\_in\_buffer,
239                             buffer\_size);
240     \textcolor{keywordflow}{case} FILE\_TYPE\_IVF:
241       \textcolor{keywordflow}{return} ivf\_read\_frame(input->aom\_input\_ctx->file, buf, bytes\_in\_buffer,
242                             buffer\_size, NULL);
243     \textcolor{keywordflow}{case} FILE\_TYPE\_OBU:
244       \textcolor{keywordflow}{return} obudec\_read\_temporal\_unit(input->obu\_ctx, buf, bytes\_in\_buffer,
245                                        buffer\_size);
246     \textcolor{keywordflow}{default}: \textcolor{keywordflow}{return} 1;
247   \}
248 \}
249 
250 \textcolor{keyword}{static} \textcolor{keywordtype}{int} file\_is\_raw(\textcolor{keyword}{struct} AvxInputContext *input) \{
251   uint8\_t buf[32];
252   \textcolor{keywordtype}{int} is\_raw = 0;
253   \hyperlink{structaom__codec__stream__info}{aom\_codec\_stream\_info\_t} si;
254   memset(&si, 0, \textcolor{keyword}{sizeof}(si));
255 
256   \textcolor{keywordflow}{if} (fread(buf, 1, 32, input->file) == 32) \{
257     \textcolor{keywordtype}{int} i;
258 
259     \textcolor{keywordflow}{if} (mem\_get\_le32(buf) < 256 * 1024 * 1024) \{
260       \textcolor{keywordflow}{for} (i = 0; i < get\_aom\_decoder\_count(); ++i) \{
261         \textcolor{keyword}{const} AvxInterface *\textcolor{keyword}{const} decoder = get\_aom\_decoder\_by\_index(i);
262         \textcolor{keywordflow}{if} (!\hyperlink{group__decoder_ga2544bac9fdc439f0effd6b1b14df54be}{aom\_codec\_peek\_stream\_info}(decoder->codec\_interface(), buf + 4,
263                                         32 - 4, &si)) \{
264           is\_raw = 1;
265           input->fourcc = decoder->fourcc;
266           input->width = si.\hyperlink{structaom__codec__stream__info_add84a2752fefd706f893fbc41ba6b9f2}{w};
267           input->height = si.\hyperlink{structaom__codec__stream__info_a2f1c33e3b980b274176545340b474e34}{h};
268           input->framerate.numerator = 30;
269           input->framerate.denominator = 1;
270           \textcolor{keywordflow}{break};
271         \}
272       \}
273     \}
274   \}
275 
276   rewind(input->file);
277   \textcolor{keywordflow}{return} is\_raw;
278 \}
279 
280 \textcolor{keyword}{static} \textcolor{keywordtype}{void} show\_progress(\textcolor{keywordtype}{int} frame\_in, \textcolor{keywordtype}{int} frame\_out, uint64\_t dx\_time) \{
281   fprintf(stderr,
282           \textcolor{stringliteral}{"%d decoded frames/%d showed frames in %"} PRId64 \textcolor{stringliteral}{" us (%.2f fps)\(\backslash\)r"},
283           frame\_in, frame\_out, dx\_time,
284           (\textcolor{keywordtype}{double})frame\_out * 1000000.0 / (\textcolor{keywordtype}{double})dx\_time);
285 \}
286 
287 \textcolor{keyword}{struct }ExternalFrameBuffer \{
288   uint8\_t *data;
289   \textcolor{keywordtype}{size\_t} size;
290   \textcolor{keywordtype}{int} in\_use;
291 \};
292 
293 \textcolor{keyword}{struct }ExternalFrameBufferList \{
294   \textcolor{keywordtype}{int} num\_external\_frame\_buffers;
295   \textcolor{keyword}{struct }ExternalFrameBuffer *ext\_fb;
296 \};
297 
298 \textcolor{comment}{// Callback used by libaom to request an external frame buffer. |cb\_priv|}
299 \textcolor{comment}{// Application private data passed into the set function. |min\_size| is the}
300 \textcolor{comment}{// minimum size in bytes needed to decode the next frame. |fb| pointer to the}
301 \textcolor{comment}{// frame buffer.}
302 \textcolor{keyword}{static} \textcolor{keywordtype}{int} get\_av1\_frame\_buffer(\textcolor{keywordtype}{void} *cb\_priv, \textcolor{keywordtype}{size\_t} min\_size,
303                                 \hyperlink{structaom__codec__frame__buffer}{aom\_codec\_frame\_buffer\_t} *fb) \{
304   \textcolor{keywordtype}{int} i;
305   \textcolor{keyword}{struct }ExternalFrameBufferList *\textcolor{keyword}{const} ext\_fb\_list =
306       (\textcolor{keyword}{struct }ExternalFrameBufferList *)cb\_priv;
307   \textcolor{keywordflow}{if} (ext\_fb\_list == NULL) \textcolor{keywordflow}{return} -1;
308 
309   \textcolor{comment}{// Find a free frame buffer.}
310   \textcolor{keywordflow}{for} (i = 0; i < ext\_fb\_list->num\_external\_frame\_buffers; ++i) \{
311     \textcolor{keywordflow}{if} (!ext\_fb\_list->ext\_fb[i].in\_use) \textcolor{keywordflow}{break};
312   \}
313 
314   \textcolor{keywordflow}{if} (i == ext\_fb\_list->num\_external\_frame\_buffers) \textcolor{keywordflow}{return} -1;
315 
316   \textcolor{keywordflow}{if} (ext\_fb\_list->ext\_fb[i].size < min\_size) \{
317     free(ext\_fb\_list->ext\_fb[i].data);
318     ext\_fb\_list->ext\_fb[i].data = (uint8\_t *)calloc(min\_size, \textcolor{keyword}{sizeof}(uint8\_t));
319     \textcolor{keywordflow}{if} (!ext\_fb\_list->ext\_fb[i].data) \textcolor{keywordflow}{return} -1;
320 
321     ext\_fb\_list->ext\_fb[i].size = min\_size;
322   \}
323 
324   fb->\hyperlink{structaom__codec__frame__buffer_a4b73719e1d6756516de8cbceb68822d2}{data} = ext\_fb\_list->ext\_fb[i].data;
325   fb->\hyperlink{structaom__codec__frame__buffer_a6fc24049c4e1706ce3a462825009f3d4}{size} = ext\_fb\_list->ext\_fb[i].size;
326   ext\_fb\_list->ext\_fb[i].in\_use = 1;
327 
328   \textcolor{comment}{// Set the frame buffer's private data to point at the external frame buffer.}
329   fb->\hyperlink{structaom__codec__frame__buffer_aa689f8e27421eebc9e1c70b607e415ef}{priv} = &ext\_fb\_list->ext\_fb[i];
330   \textcolor{keywordflow}{return} 0;
331 \}
332 
333 \textcolor{comment}{// Callback used by libaom when there are no references to the frame buffer.}
334 \textcolor{comment}{// |cb\_priv| user private data passed into the set function. |fb| pointer}
335 \textcolor{comment}{// to the frame buffer.}
336 \textcolor{keyword}{static} \textcolor{keywordtype}{int} release\_av1\_frame\_buffer(\textcolor{keywordtype}{void} *cb\_priv,
337                                     \hyperlink{structaom__codec__frame__buffer}{aom\_codec\_frame\_buffer\_t} *fb) \{
338   \textcolor{keyword}{struct }ExternalFrameBuffer *\textcolor{keyword}{const} ext\_fb =
339       (\textcolor{keyword}{struct }ExternalFrameBuffer *)fb->\hyperlink{structaom__codec__frame__buffer_aa689f8e27421eebc9e1c70b607e415ef}{priv};
340   (\textcolor{keywordtype}{void})cb\_priv;
341   ext\_fb->in\_use = 0;
342   \textcolor{keywordflow}{return} 0;
343 \}
344 
345 \textcolor{keyword}{static} \textcolor{keywordtype}{void} generate\_filename(\textcolor{keyword}{const} \textcolor{keywordtype}{char} *pattern, \textcolor{keywordtype}{char} *out, \textcolor{keywordtype}{size\_t} q\_len,
346                               \textcolor{keywordtype}{unsigned} \textcolor{keywordtype}{int} d\_w, \textcolor{keywordtype}{unsigned} \textcolor{keywordtype}{int} d\_h,
347                               \textcolor{keywordtype}{unsigned} \textcolor{keywordtype}{int} frame\_in) \{
348   \textcolor{keyword}{const} \textcolor{keywordtype}{char} *p = pattern;
349   \textcolor{keywordtype}{char} *q = out;
350 
351   \textcolor{keywordflow}{do} \{
352     \textcolor{keywordtype}{char} *next\_pat = strchr(p, \textcolor{charliteral}{'%'});
353 
354     \textcolor{keywordflow}{if} (p == next\_pat) \{
355       \textcolor{keywordtype}{size\_t} pat\_len;
356 
357       \textcolor{comment}{/* parse the pattern */}
358       q[q\_len - 1] = \textcolor{charliteral}{'\(\backslash\)0'};
359       \textcolor{keywordflow}{switch} (p[1]) \{
360         \textcolor{keywordflow}{case} \textcolor{charliteral}{'w'}: snprintf(q, q\_len - 1, \textcolor{stringliteral}{"%d"}, d\_w); \textcolor{keywordflow}{break};
361         \textcolor{keywordflow}{case} \textcolor{charliteral}{'h'}: snprintf(q, q\_len - 1, \textcolor{stringliteral}{"%d"}, d\_h); \textcolor{keywordflow}{break};
362         \textcolor{keywordflow}{case} \textcolor{charliteral}{'1'}: snprintf(q, q\_len - 1, \textcolor{stringliteral}{"%d"}, frame\_in); \textcolor{keywordflow}{break};
363         \textcolor{keywordflow}{case} \textcolor{charliteral}{'2'}: snprintf(q, q\_len - 1, \textcolor{stringliteral}{"%02d"}, frame\_in); \textcolor{keywordflow}{break};
364         \textcolor{keywordflow}{case} \textcolor{charliteral}{'3'}: snprintf(q, q\_len - 1, \textcolor{stringliteral}{"%03d"}, frame\_in); \textcolor{keywordflow}{break};
365         \textcolor{keywordflow}{case} \textcolor{charliteral}{'4'}: snprintf(q, q\_len - 1, \textcolor{stringliteral}{"%04d"}, frame\_in); \textcolor{keywordflow}{break};
366         \textcolor{keywordflow}{case} \textcolor{charliteral}{'5'}: snprintf(q, q\_len - 1, \textcolor{stringliteral}{"%05d"}, frame\_in); \textcolor{keywordflow}{break};
367         \textcolor{keywordflow}{case} \textcolor{charliteral}{'6'}: snprintf(q, q\_len - 1, \textcolor{stringliteral}{"%06d"}, frame\_in); \textcolor{keywordflow}{break};
368         \textcolor{keywordflow}{case} \textcolor{charliteral}{'7'}: snprintf(q, q\_len - 1, \textcolor{stringliteral}{"%07d"}, frame\_in); \textcolor{keywordflow}{break};
369         \textcolor{keywordflow}{case} \textcolor{charliteral}{'8'}: snprintf(q, q\_len - 1, \textcolor{stringliteral}{"%08d"}, frame\_in); \textcolor{keywordflow}{break};
370         \textcolor{keywordflow}{case} \textcolor{charliteral}{'9'}: snprintf(q, q\_len - 1, \textcolor{stringliteral}{"%09d"}, frame\_in); \textcolor{keywordflow}{break};
371         \textcolor{keywordflow}{default}: die(\textcolor{stringliteral}{"Unrecognized pattern %%%c\(\backslash\)n"}, p[1]); \textcolor{keywordflow}{break};
372       \}
373 
374       pat\_len = strlen(q);
375       \textcolor{keywordflow}{if} (pat\_len >= q\_len - 1) die(\textcolor{stringliteral}{"Output filename too long.\(\backslash\)n"});
376       q += pat\_len;
377       p += 2;
378       q\_len -= pat\_len;
379     \} \textcolor{keywordflow}{else} \{
380       \textcolor{keywordtype}{size\_t} copy\_len;
381 
382       \textcolor{comment}{/* copy the next segment */}
383       \textcolor{keywordflow}{if} (!next\_pat)
384         copy\_len = strlen(p);
385       \textcolor{keywordflow}{else}
386         copy\_len = next\_pat - p;
387 
388       \textcolor{keywordflow}{if} (copy\_len >= q\_len - 1) die(\textcolor{stringliteral}{"Output filename too long.\(\backslash\)n"});
389 
390       memcpy(q, p, copy\_len);
391       q[copy\_len] = \textcolor{charliteral}{'\(\backslash\)0'};
392       q += copy\_len;
393       p += copy\_len;
394       q\_len -= copy\_len;
395     \}
396   \} \textcolor{keywordflow}{while} (*p);
397 \}
398 
399 \textcolor{keyword}{static} \textcolor{keywordtype}{int} is\_single\_file(\textcolor{keyword}{const} \textcolor{keywordtype}{char} *outfile\_pattern) \{
400   \textcolor{keyword}{const} \textcolor{keywordtype}{char} *p = outfile\_pattern;
401 
402   \textcolor{keywordflow}{do} \{
403     p = strchr(p, \textcolor{charliteral}{'%'});
404     \textcolor{keywordflow}{if} (p && p[1] >= \textcolor{charliteral}{'1'} && p[1] <= \textcolor{charliteral}{'9'})
405       \textcolor{keywordflow}{return} 0;  \textcolor{comment}{// pattern contains sequence number, so it's not unique}
406     \textcolor{keywordflow}{if} (p) p++;
407   \} \textcolor{keywordflow}{while} (p);
408 
409   \textcolor{keywordflow}{return} 1;
410 \}
411 
412 \textcolor{keyword}{static} \textcolor{keywordtype}{void} print\_md5(\textcolor{keywordtype}{unsigned} \textcolor{keywordtype}{char} digest[16], \textcolor{keyword}{const} \textcolor{keywordtype}{char} *filename) \{
413   \textcolor{keywordtype}{int} i;
414 
415   \textcolor{keywordflow}{for} (i = 0; i < 16; ++i) printf(\textcolor{stringliteral}{"%02x"}, digest[i]);
416   printf(\textcolor{stringliteral}{"  %s\(\backslash\)n"}, filename);
417 \}
418 
419 \textcolor{keyword}{static} FILE *open\_outfile(\textcolor{keyword}{const} \textcolor{keywordtype}{char} *name) \{
420   \textcolor{keywordflow}{if} (strcmp(\textcolor{stringliteral}{"-"}, name) == 0) \{
421     set\_binary\_mode(stdout);
422     \textcolor{keywordflow}{return} stdout;
423   \} \textcolor{keywordflow}{else} \{
424     FILE *file = fopen(name, \textcolor{stringliteral}{"wb"});
425     \textcolor{keywordflow}{if} (!file) fatal(\textcolor{stringliteral}{"Failed to open output file '%s'"}, name);
426     \textcolor{keywordflow}{return} file;
427   \}
428 \}
429 
430 \textcolor{keyword}{static} \textcolor{keywordtype}{int} main\_loop(\textcolor{keywordtype}{int} argc, \textcolor{keyword}{const} \textcolor{keywordtype}{char} **argv\_) \{
431   \hyperlink{structaom__codec__ctx}{aom\_codec\_ctx\_t} decoder;
432   \textcolor{keywordtype}{char} *fn = NULL;
433   \textcolor{keywordtype}{int} i;
434   \textcolor{keywordtype}{int} ret = EXIT\_FAILURE;
435   uint8\_t *buf = NULL;
436   \textcolor{keywordtype}{size\_t} bytes\_in\_buffer = 0, buffer\_size = 0;
437   FILE *infile;
438   \textcolor{keywordtype}{int} frame\_in = 0, frame\_out = 0, flipuv = 0, noblit = 0;
439   \textcolor{keywordtype}{int} do\_md5 = 0, progress = 0;
440   \textcolor{keywordtype}{int} stop\_after = 0, postproc = 0, summary = 0, quiet = 1;
441   \textcolor{keywordtype}{int} arg\_skip = 0;
442   \textcolor{keywordtype}{int} keep\_going = 0;
443   \textcolor{keyword}{const} AvxInterface *\textcolor{keyword}{interface }= NULL;
444   \textcolor{keyword}{const} AvxInterface *fourcc\_interface = NULL;
445   uint64\_t dx\_time = 0;
446   \textcolor{keyword}{struct }arg arg;
447   \textcolor{keywordtype}{char} **argv, **argi, **argj;
448 
449   \textcolor{keywordtype}{int} single\_file;
450   \textcolor{keywordtype}{int} use\_y4m = 1;
451   \textcolor{keywordtype}{int} opt\_yv12 = 0;
452   \textcolor{keywordtype}{int} opt\_i420 = 0;
453   \textcolor{keywordtype}{int} opt\_raw = 0;
454   \hyperlink{structaom__codec__dec__cfg}{aom\_codec\_dec\_cfg\_t} cfg = \{ 0, 0, 0, CONFIG\_LOWBITDEPTH, \{ 1 \} \};
455   \textcolor{keywordtype}{unsigned} \textcolor{keywordtype}{int} fixed\_output\_bit\_depth = 0;
456   \textcolor{keywordtype}{unsigned} \textcolor{keywordtype}{int} is\_annexb = 0;
457   \textcolor{keywordtype}{int} frames\_corrupted = 0;
458   \textcolor{keywordtype}{int} dec\_flags = 0;
459   \textcolor{keywordtype}{int} do\_scale = 0;
460   \textcolor{keywordtype}{int} operating\_point = 0;
461   \textcolor{keywordtype}{int} output\_all\_layers = 0;
462   \textcolor{keywordtype}{int} skip\_film\_grain = 0;
463   \hyperlink{structaom__image}{aom\_image\_t} *scaled\_img = NULL;
464   \hyperlink{structaom__image}{aom\_image\_t} *img\_shifted = NULL;
465   \textcolor{keywordtype}{int} frame\_avail, got\_data, flush\_decoder = 0;
466   \textcolor{keywordtype}{int} num\_external\_frame\_buffers = 0;
467   \textcolor{keyword}{struct }ExternalFrameBufferList ext\_fb\_list = \{ 0, NULL \};
468 
469   \textcolor{keyword}{const} \textcolor{keywordtype}{char} *outfile\_pattern = NULL;
470   \textcolor{keywordtype}{char} outfile\_name[PATH\_MAX] = \{ 0 \};
471   FILE *outfile = NULL;
472 
473   FILE *framestats\_file = NULL;
474 
475   MD5Context md5\_ctx;
476   \textcolor{keywordtype}{unsigned} \textcolor{keywordtype}{char} md5\_digest[16];
477 
478   \textcolor{keyword}{struct }AvxDecInputContext input = \{ NULL, NULL, NULL \};
479   \textcolor{keyword}{struct }AvxInputContext aom\_input\_ctx;
480   memset(&aom\_input\_ctx, 0, \textcolor{keyword}{sizeof}(aom\_input\_ctx));
481 \textcolor{preprocessor}{#if CONFIG\_WEBM\_IO}
482   \textcolor{keyword}{struct }WebmInputContext webm\_ctx;
483   memset(&webm\_ctx, 0, \textcolor{keyword}{sizeof}(webm\_ctx));
484   input.webm\_ctx = &webm\_ctx;
485 \textcolor{preprocessor}{#endif}
486   \textcolor{keyword}{struct }ObuDecInputContext obu\_ctx = \{ NULL, NULL, 0, 0, 0 \};
487 
488   obu\_ctx.avx\_ctx = &aom\_input\_ctx;
489   input.obu\_ctx = &obu\_ctx;
490   input.aom\_input\_ctx = &aom\_input\_ctx;
491 
492   \textcolor{comment}{/* Parse command line */}
493   exec\_name = argv\_[0];
494   argv = argv\_dup(argc - 1, argv\_ + 1);
495 
496   \textcolor{keywordflow}{for} (argi = argj = argv; (*argj = *argi); argi += arg.argv\_step) \{
497     memset(&arg, 0, \textcolor{keyword}{sizeof}(arg));
498     arg.argv\_step = 1;
499 
500     \textcolor{keywordflow}{if} (arg\_match(&arg, &help, argi)) \{
501       show\_help(stdout, 0);
502       exit(EXIT\_SUCCESS);
503     \} \textcolor{keywordflow}{else} \textcolor{keywordflow}{if} (arg\_match(&arg, &codecarg, argi)) \{
504       \textcolor{keyword}{interface }= get\_aom\_decoder\_by\_name(arg.val);
505       \textcolor{keywordflow}{if} (!interface)
506         die(\textcolor{stringliteral}{"Error: Unrecognized argument (%s) to --codec\(\backslash\)n"}, arg.val);
507     \} \textcolor{keywordflow}{else} \textcolor{keywordflow}{if} (arg\_match(&arg, &looparg, argi)) \{
508       \textcolor{comment}{// no-op}
509     \} \textcolor{keywordflow}{else} \textcolor{keywordflow}{if} (arg\_match(&arg, &outputfile, argi)) \{
510       outfile\_pattern = arg.val;
511     \} \textcolor{keywordflow}{else} \textcolor{keywordflow}{if} (arg\_match(&arg, &use\_yv12, argi)) \{
512       use\_y4m = 0;
513       flipuv = 1;
514       opt\_yv12 = 1;
515       opt\_i420 = 0;
516       opt\_raw = 0;
517     \} \textcolor{keywordflow}{else} \textcolor{keywordflow}{if} (arg\_match(&arg, &use\_i420, argi)) \{
518       use\_y4m = 0;
519       flipuv = 0;
520       opt\_yv12 = 0;
521       opt\_i420 = 1;
522       opt\_raw = 0;
523     \} \textcolor{keywordflow}{else} \textcolor{keywordflow}{if} (arg\_match(&arg, &rawvideo, argi)) \{
524       use\_y4m = 0;
525       opt\_yv12 = 0;
526       opt\_i420 = 0;
527       opt\_raw = 1;
528     \} \textcolor{keywordflow}{else} \textcolor{keywordflow}{if} (arg\_match(&arg, &flipuvarg, argi)) \{
529       flipuv = 1;
530     \} \textcolor{keywordflow}{else} \textcolor{keywordflow}{if} (arg\_match(&arg, &noblitarg, argi)) \{
531       noblit = 1;
532     \} \textcolor{keywordflow}{else} \textcolor{keywordflow}{if} (arg\_match(&arg, &progressarg, argi)) \{
533       progress = 1;
534     \} \textcolor{keywordflow}{else} \textcolor{keywordflow}{if} (arg\_match(&arg, &limitarg, argi)) \{
535       stop\_after = arg\_parse\_uint(&arg);
536     \} \textcolor{keywordflow}{else} \textcolor{keywordflow}{if} (arg\_match(&arg, &skiparg, argi)) \{
537       arg\_skip = arg\_parse\_uint(&arg);
538     \} \textcolor{keywordflow}{else} \textcolor{keywordflow}{if} (arg\_match(&arg, &postprocarg, argi)) \{
539       postproc = 1;
540     \} \textcolor{keywordflow}{else} \textcolor{keywordflow}{if} (arg\_match(&arg, &md5arg, argi)) \{
541       do\_md5 = 1;
542     \} \textcolor{keywordflow}{else} \textcolor{keywordflow}{if} (arg\_match(&arg, &framestatsarg, argi)) \{
543       framestats\_file = fopen(arg.val, \textcolor{stringliteral}{"w"});
544       \textcolor{keywordflow}{if} (!framestats\_file) \{
545         die(\textcolor{stringliteral}{"Error: Could not open --framestats file (%s) for writing.\(\backslash\)n"},
546             arg.val);
547       \}
548     \} \textcolor{keywordflow}{else} \textcolor{keywordflow}{if} (arg\_match(&arg, &summaryarg, argi)) \{
549       summary = 1;
550     \} \textcolor{keywordflow}{else} \textcolor{keywordflow}{if} (arg\_match(&arg, &threadsarg, argi)) \{
551       cfg.\hyperlink{structaom__codec__dec__cfg_a48c68337e1071e2aee36c649e579f189}{threads} = arg\_parse\_uint(&arg);
552 \textcolor{preprocessor}{#if !CONFIG\_MULTITHREAD}
553       \textcolor{keywordflow}{if} (cfg.\hyperlink{structaom__codec__dec__cfg_a48c68337e1071e2aee36c649e579f189}{threads} > 1) \{
554         die(\textcolor{stringliteral}{"Error: --threads=%d is not supported when CONFIG\_MULTITHREAD = "}
555             \textcolor{stringliteral}{"0.\(\backslash\)n"},
556             cfg.\hyperlink{structaom__codec__dec__cfg_a48c68337e1071e2aee36c649e579f189}{threads});
557       \}
558 \textcolor{preprocessor}{#endif}
559     \} \textcolor{keywordflow}{else} \textcolor{keywordflow}{if} (arg\_match(&arg, &verbosearg, argi)) \{
560       quiet = 0;
561     \} \textcolor{keywordflow}{else} \textcolor{keywordflow}{if} (arg\_match(&arg, &scalearg, argi)) \{
562       do\_scale = 1;
563     \} \textcolor{keywordflow}{else} \textcolor{keywordflow}{if} (arg\_match(&arg, &fb\_arg, argi)) \{
564       num\_external\_frame\_buffers = arg\_parse\_uint(&arg);
565     \} \textcolor{keywordflow}{else} \textcolor{keywordflow}{if} (arg\_match(&arg, &continuearg, argi)) \{
566       keep\_going = 1;
567     \} \textcolor{keywordflow}{else} \textcolor{keywordflow}{if} (arg\_match(&arg, &outbitdeptharg, argi)) \{
568       fixed\_output\_bit\_depth = arg\_parse\_uint(&arg);
569     \} \textcolor{keywordflow}{else} \textcolor{keywordflow}{if} (arg\_match(&arg, &isannexb, argi)) \{
570       is\_annexb = 1;
571       input.obu\_ctx->is\_annexb = 1;
572     \} \textcolor{keywordflow}{else} \textcolor{keywordflow}{if} (arg\_match(&arg, &oppointarg, argi)) \{
573       operating\_point = arg\_parse\_int(&arg);
574     \} \textcolor{keywordflow}{else} \textcolor{keywordflow}{if} (arg\_match(&arg, &outallarg, argi)) \{
575       output\_all\_layers = 1;
576     \} \textcolor{keywordflow}{else} \textcolor{keywordflow}{if} (arg\_match(&arg, &skipfilmgrain, argi)) \{
577       skip\_film\_grain = 1;
578     \} \textcolor{keywordflow}{else} \{
579       argj++;
580     \}
581   \}
582 
583   \textcolor{comment}{/* Check for unrecognized options */}
584   \textcolor{keywordflow}{for} (argi = argv; *argi; argi++)
585     \textcolor{keywordflow}{if} (argi[0][0] == \textcolor{charliteral}{'-'} && strlen(argi[0]) > 1)
586       die(\textcolor{stringliteral}{"Error: Unrecognized option %s\(\backslash\)n"}, *argi);
587 
588   \textcolor{comment}{/* Handle non-option arguments */}
589   fn = argv[0];
590 
591   \textcolor{keywordflow}{if} (!fn) \{
592     free(argv);
593     fprintf(stderr, \textcolor{stringliteral}{"No input file specified!\(\backslash\)n"});
594     usage\_exit();
595   \}
596   \textcolor{comment}{/* Open file */}
597   infile = strcmp(fn, \textcolor{stringliteral}{"-"}) ? fopen(fn, \textcolor{stringliteral}{"rb"}) : set\_binary\_mode(stdin);
598 
599   \textcolor{keywordflow}{if} (!infile) \{
600     fatal(\textcolor{stringliteral}{"Failed to open input file '%s'"}, strcmp(fn, \textcolor{stringliteral}{"-"}) ? fn : \textcolor{stringliteral}{"stdin"});
601   \}
602 \textcolor{preprocessor}{#if CONFIG\_OS\_SUPPORT}
603   \textcolor{comment}{/* Make sure we don't dump to the terminal, unless forced to with -o - */}
604   \textcolor{keywordflow}{if} (!outfile\_pattern && isatty(STDOUT\_FILENO) && !do\_md5 && !noblit) \{
605     fprintf(stderr,
606             \textcolor{stringliteral}{"Not dumping raw video to your terminal. Use '-o -' to "}
607             \textcolor{stringliteral}{"override.\(\backslash\)n"});
608     \textcolor{keywordflow}{return} EXIT\_FAILURE;
609   \}
610 \textcolor{preprocessor}{#endif}
611   input.aom\_input\_ctx->filename = fn;
612   input.aom\_input\_ctx->file = infile;
613   \textcolor{keywordflow}{if} (file\_is\_ivf(input.aom\_input\_ctx))
614     input.aom\_input\_ctx->file\_type = FILE\_TYPE\_IVF;
615 \textcolor{preprocessor}{#if CONFIG\_WEBM\_IO}
616   \textcolor{keywordflow}{else} \textcolor{keywordflow}{if} (file\_is\_webm(input.webm\_ctx, input.aom\_input\_ctx))
617     input.aom\_input\_ctx->file\_type = FILE\_TYPE\_WEBM;
618 \textcolor{preprocessor}{#endif}
619   \textcolor{keywordflow}{else} \textcolor{keywordflow}{if} (file\_is\_obu(&obu\_ctx))
620     input.aom\_input\_ctx->file\_type = FILE\_TYPE\_OBU;
621   \textcolor{keywordflow}{else} \textcolor{keywordflow}{if} (file\_is\_raw(input.aom\_input\_ctx))
622     input.aom\_input\_ctx->file\_type = FILE\_TYPE\_RAW;
623   \textcolor{keywordflow}{else} \{
624     fprintf(stderr, \textcolor{stringliteral}{"Unrecognized input file type.\(\backslash\)n"});
625 \textcolor{preprocessor}{#if !CONFIG\_WEBM\_IO}
626     fprintf(stderr, \textcolor{stringliteral}{"aomdec was built without WebM container support.\(\backslash\)n"});
627 \textcolor{preprocessor}{#endif}
628     \textcolor{keywordflow}{return} EXIT\_FAILURE;
629   \}
630 
631   outfile\_pattern = outfile\_pattern ? outfile\_pattern : \textcolor{stringliteral}{"-"};
632   single\_file = is\_single\_file(outfile\_pattern);
633 
634   \textcolor{keywordflow}{if} (!noblit && single\_file) \{
635     generate\_filename(outfile\_pattern, outfile\_name, PATH\_MAX,
636                       aom\_input\_ctx.width, aom\_input\_ctx.height, 0);
637     \textcolor{keywordflow}{if} (do\_md5)
638       MD5Init(&md5\_ctx);
639     \textcolor{keywordflow}{else}
640       outfile = open\_outfile(outfile\_name);
641   \}
642 
643   \textcolor{keywordflow}{if} (use\_y4m && !noblit) \{
644     \textcolor{keywordflow}{if} (!single\_file) \{
645       fprintf(stderr,
646               \textcolor{stringliteral}{"YUV4MPEG2 not supported with output patterns,"}
647               \textcolor{stringliteral}{" try --i420 or --yv12 or --rawvideo.\(\backslash\)n"});
648       \textcolor{keywordflow}{return} EXIT\_FAILURE;
649     \}
650 
651 \textcolor{preprocessor}{#if CONFIG\_WEBM\_IO}
652     \textcolor{keywordflow}{if} (aom\_input\_ctx.file\_type == FILE\_TYPE\_WEBM) \{
653       \textcolor{keywordflow}{if} (webm\_guess\_framerate(input.webm\_ctx, input.aom\_input\_ctx)) \{
654         fprintf(stderr,
655                 \textcolor{stringliteral}{"Failed to guess framerate -- error parsing "}
656                 \textcolor{stringliteral}{"webm file?\(\backslash\)n"});
657         \textcolor{keywordflow}{return} EXIT\_FAILURE;
658       \}
659     \}
660 \textcolor{preprocessor}{#endif}
661   \}
662 
663   fourcc\_interface = get\_aom\_decoder\_by\_fourcc(aom\_input\_ctx.fourcc);
664   \textcolor{keywordflow}{if} (interface && fourcc\_interface && interface != fourcc\_interface)
665     warn(\textcolor{stringliteral}{"Header indicates codec: %s\(\backslash\)n"}, fourcc\_interface->name);
666   \textcolor{keywordflow}{else}
667     \textcolor{keyword}{interface }= fourcc\_interface;
668 
669   \textcolor{keywordflow}{if} (!interface) \textcolor{keyword}{interface }= get\_aom\_decoder\_by\_index(0);
670 
671   dec\_flags = (postproc ? \hyperlink{group__decoder_ga7b6c145833964c9edd3ff78be017f7ec}{AOM\_CODEC\_USE\_POSTPROC} : 0);
672   \textcolor{keywordflow}{if} (\hyperlink{group__decoder_gafdbfca65b19ab1f6d72b32cd01753b9b}{aom\_codec\_dec\_init}(&decoder, interface->codec\_interface(), &cfg,
673                          dec\_flags)) \{
674     fprintf(stderr, \textcolor{stringliteral}{"Failed to initialize decoder: %s\(\backslash\)n"},
675             \hyperlink{group__codec_ga50949c0854605c722832bbfb0803f5f4}{aom\_codec\_error}(&decoder));
676     \textcolor{keywordflow}{goto} fail2;
677   \}
678 
679   \textcolor{keywordflow}{if} (!quiet) fprintf(stderr, \textcolor{stringliteral}{"%s\(\backslash\)n"}, decoder.\hyperlink{structaom__codec__ctx_a3aa8abff3e05d2fbbf4f5a9fa0575f2b}{name});
680 
681   \textcolor{keywordflow}{if} (\hyperlink{group__codec_ga6da974f4eeaba1fa74106b28d0fe6ac5}{aom\_codec\_control}(&decoder, \hyperlink{group__aom__decoder_gga3865fd4b3192489baa9a5c3632ebe97ba1fb269c5c5913d9995b6c35d28e2a788}{AV1D\_SET\_IS\_ANNEXB}, is\_annexb)) \{
682     fprintf(stderr, \textcolor{stringliteral}{"Failed to set is\_annexb: %s\(\backslash\)n"}, \hyperlink{group__codec_ga50949c0854605c722832bbfb0803f5f4}{aom\_codec\_error}(&decoder));
683     \textcolor{keywordflow}{goto} fail;
684   \}
685 
686   \textcolor{keywordflow}{if} (\hyperlink{group__codec_ga6da974f4eeaba1fa74106b28d0fe6ac5}{aom\_codec\_control}(&decoder, \hyperlink{group__aom__decoder_gga3865fd4b3192489baa9a5c3632ebe97baa8b955fc5a2f6e33c6dad858d7c15f67}{AV1D\_SET\_OPERATING\_POINT}, 
      operating\_point)) \{
687     fprintf(stderr, \textcolor{stringliteral}{"Failed to set operating\_point: %s\(\backslash\)n"},
688             \hyperlink{group__codec_ga50949c0854605c722832bbfb0803f5f4}{aom\_codec\_error}(&decoder));
689     \textcolor{keywordflow}{goto} fail;
690   \}
691 
692   \textcolor{keywordflow}{if} (\hyperlink{group__codec_ga6da974f4eeaba1fa74106b28d0fe6ac5}{aom\_codec\_control}(&decoder, \hyperlink{group__aom__decoder_gga3865fd4b3192489baa9a5c3632ebe97ba8d51f96b8877b665225f5cfaa73ded8e}{AV1D\_SET\_OUTPUT\_ALL\_LAYERS},
693                         output\_all\_layers)) \{
694     fprintf(stderr, \textcolor{stringliteral}{"Failed to set output\_all\_layers: %s\(\backslash\)n"},
695             \hyperlink{group__codec_ga50949c0854605c722832bbfb0803f5f4}{aom\_codec\_error}(&decoder));
696     \textcolor{keywordflow}{goto} fail;
697   \}
698 
699   \textcolor{keywordflow}{if} (\hyperlink{group__codec_ga6da974f4eeaba1fa74106b28d0fe6ac5}{aom\_codec\_control}(&decoder, \hyperlink{group__aom__decoder_gga3865fd4b3192489baa9a5c3632ebe97ba17fa09c9ce1ae4a68eae21efd219418b}{AV1D\_SET\_SKIP\_FILM\_GRAIN}, 
      skip\_film\_grain)) \{
700     fprintf(stderr, \textcolor{stringliteral}{"Failed to set skip\_film\_grain: %s\(\backslash\)n"},
701             \hyperlink{group__codec_ga50949c0854605c722832bbfb0803f5f4}{aom\_codec\_error}(&decoder));
702     \textcolor{keywordflow}{goto} fail;
703   \}
704 
705   \textcolor{keywordflow}{if} (arg\_skip) fprintf(stderr, \textcolor{stringliteral}{"Skipping first %d frames.\(\backslash\)n"}, arg\_skip);
706   \textcolor{keywordflow}{while} (arg\_skip) \{
707     \textcolor{keywordflow}{if} (read\_frame(&input, &buf, &bytes\_in\_buffer, &buffer\_size)) \textcolor{keywordflow}{break};
708     arg\_skip--;
709   \}
710 
711   \textcolor{keywordflow}{if} (num\_external\_frame\_buffers > 0) \{
712     ext\_fb\_list.num\_external\_frame\_buffers = num\_external\_frame\_buffers;
713     ext\_fb\_list.ext\_fb = (\textcolor{keyword}{struct }ExternalFrameBuffer *)calloc(
714         num\_external\_frame\_buffers, \textcolor{keyword}{sizeof}(*ext\_fb\_list.ext\_fb));
715     \textcolor{keywordflow}{if} (\hyperlink{group__cap__external__frame__buffer_ga1818a812e4d1e70eeafbe5b0ee538d6e}{aom\_codec\_set\_frame\_buffer\_functions}(&decoder, 
      get\_av1\_frame\_buffer,
716                                              release\_av1\_frame\_buffer,
717                                              &ext\_fb\_list)) \{
718       fprintf(stderr, \textcolor{stringliteral}{"Failed to configure external frame buffers: %s\(\backslash\)n"},
719               \hyperlink{group__codec_ga50949c0854605c722832bbfb0803f5f4}{aom\_codec\_error}(&decoder));
720       \textcolor{keywordflow}{goto} fail;
721     \}
722   \}
723 
724   frame\_avail = 1;
725   got\_data = 0;
726 
727   \textcolor{keywordflow}{if} (framestats\_file) fprintf(framestats\_file, \textcolor{stringliteral}{"bytes,qp\(\backslash\)r\(\backslash\)n"});
728 
729   \textcolor{comment}{/* Decode file */}
730   \textcolor{keywordflow}{while} (frame\_avail || got\_data) \{
731     \hyperlink{group__codec_gadf9e173c9e02788a9999399edab20a02}{aom\_codec\_iter\_t} iter = NULL;
732     \hyperlink{structaom__image}{aom\_image\_t} *img;
733     \textcolor{keyword}{struct }aom\_usec\_timer timer;
734     \textcolor{keywordtype}{int} corrupted = 0;
735 
736     frame\_avail = 0;
737     \textcolor{keywordflow}{if} (!stop\_after || frame\_in < stop\_after) \{
738       \textcolor{keywordflow}{if} (!read\_frame(&input, &buf, &bytes\_in\_buffer, &buffer\_size)) \{
739         frame\_avail = 1;
740         frame\_in++;
741 
742         aom\_usec\_timer\_start(&timer);
743 
744         \textcolor{keywordflow}{if} (\hyperlink{group__decoder_gab03fdb999d1f83a5896869a3ba5f68f7}{aom\_codec\_decode}(&decoder, buf, bytes\_in\_buffer, NULL)) \{
745           \textcolor{keyword}{const} \textcolor{keywordtype}{char} *detail = \hyperlink{group__codec_ga43a70562598b485685794a4e9d9d53f7}{aom\_codec\_error\_detail}(&decoder);
746           warn(\textcolor{stringliteral}{"Failed to decode frame %d: %s"}, frame\_in,
747                \hyperlink{group__codec_ga50949c0854605c722832bbfb0803f5f4}{aom\_codec\_error}(&decoder));
748 
749           \textcolor{keywordflow}{if} (detail) warn(\textcolor{stringliteral}{"Additional information: %s"}, detail);
750           \textcolor{keywordflow}{if} (!keep\_going) \textcolor{keywordflow}{goto} fail;
751         \}
752 
753         \textcolor{keywordflow}{if} (framestats\_file) \{
754           \textcolor{keywordtype}{int} qp;
755           \textcolor{keywordflow}{if} (\hyperlink{group__codec_ga6da974f4eeaba1fa74106b28d0fe6ac5}{aom\_codec\_control}(&decoder, 
      \hyperlink{group__aom__decoder_gga3865fd4b3192489baa9a5c3632ebe97baa984acc8b42df9c7d18fc3556a14fd29}{AOMD\_GET\_LAST\_QUANTIZER}, &qp)) \{
756             warn(\textcolor{stringliteral}{"Failed AOMD\_GET\_LAST\_QUANTIZER: %s"},
757                  \hyperlink{group__codec_ga50949c0854605c722832bbfb0803f5f4}{aom\_codec\_error}(&decoder));
758             \textcolor{keywordflow}{if} (!keep\_going) \textcolor{keywordflow}{goto} fail;
759           \}
760           fprintf(framestats\_file, \textcolor{stringliteral}{"%d,%d\(\backslash\)r\(\backslash\)n"}, (\textcolor{keywordtype}{int})bytes\_in\_buffer, qp);
761         \}
762 
763         aom\_usec\_timer\_mark(&timer);
764         dx\_time += aom\_usec\_timer\_elapsed(&timer);
765       \} \textcolor{keywordflow}{else} \{
766         flush\_decoder = 1;
767       \}
768     \} \textcolor{keywordflow}{else} \{
769       flush\_decoder = 1;
770     \}
771 
772     aom\_usec\_timer\_start(&timer);
773 
774     \textcolor{keywordflow}{if} (flush\_decoder) \{
775       \textcolor{comment}{// Flush the decoder.}
776       \textcolor{keywordflow}{if} (\hyperlink{group__decoder_gab03fdb999d1f83a5896869a3ba5f68f7}{aom\_codec\_decode}(&decoder, NULL, 0, NULL)) \{
777         warn(\textcolor{stringliteral}{"Failed to flush decoder: %s"}, \hyperlink{group__codec_ga50949c0854605c722832bbfb0803f5f4}{aom\_codec\_error}(&decoder));
778       \}
779     \}
780 
781     aom\_usec\_timer\_mark(&timer);
782     dx\_time += aom\_usec\_timer\_elapsed(&timer);
783 
784     got\_data = 0;
785     \textcolor{keywordflow}{while} ((img = \hyperlink{group__decoder_ga780aad27a2728abefab725faa3bc4f79}{aom\_codec\_get\_frame}(&decoder, &iter))) \{
786       ++frame\_out;
787       got\_data = 1;
788 
789       \textcolor{keywordflow}{if} (\hyperlink{group__codec_ga6da974f4eeaba1fa74106b28d0fe6ac5}{aom\_codec\_control}(&decoder, \hyperlink{group__aom__decoder_gga3865fd4b3192489baa9a5c3632ebe97ba159ddb748cb69956226b7c13e3890ff6}{AOMD\_GET\_FRAME\_CORRUPTED}, &
      corrupted)) \{
790         warn(\textcolor{stringliteral}{"Failed AOM\_GET\_FRAME\_CORRUPTED: %s"}, \hyperlink{group__codec_ga50949c0854605c722832bbfb0803f5f4}{aom\_codec\_error}(&decoder));
791         \textcolor{keywordflow}{if} (!keep\_going) \textcolor{keywordflow}{goto} fail;
792       \}
793       frames\_corrupted += corrupted;
794 
795       \textcolor{keywordflow}{if} (progress) show\_progress(frame\_in, frame\_out, dx\_time);
796 
797       \textcolor{keywordflow}{if} (!noblit) \{
798         \textcolor{keyword}{const} \textcolor{keywordtype}{int} PLANES\_YUV[] = \{ \hyperlink{aom__image_8h_a2ad22076006b15cf809edcaa33f6d339}{AOM\_PLANE\_Y}, \hyperlink{aom__image_8h_a0845e9194541329c0f77b4bd6a38cc7c}{AOM\_PLANE\_U}, AOM\_PLANE\_V \};
799         \textcolor{keyword}{const} \textcolor{keywordtype}{int} PLANES\_YVU[] = \{ \hyperlink{aom__image_8h_a2ad22076006b15cf809edcaa33f6d339}{AOM\_PLANE\_Y}, \hyperlink{aom__image_8h_a32a43f20adb01d846af1925189c37495}{AOM\_PLANE\_V}, AOM\_PLANE\_U \};
800         \textcolor{keyword}{const} \textcolor{keywordtype}{int} *planes = flipuv ? PLANES\_YVU : PLANES\_YUV;
801 
802         \textcolor{keywordflow}{if} (do\_scale) \{
803           \textcolor{keywordflow}{if} (frame\_out == 1) \{
804             \textcolor{comment}{// If the output frames are to be scaled to a fixed display size}
805             \textcolor{comment}{// then use the width and height specified in the container. If}
806             \textcolor{comment}{// either of these is set to 0, use the display size set in the}
807             \textcolor{comment}{// first frame header. If that is unavailable, use the raw decoded}
808             \textcolor{comment}{// size of the first decoded frame.}
809             \textcolor{keywordtype}{int} render\_width = aom\_input\_ctx.width;
810             \textcolor{keywordtype}{int} render\_height = aom\_input\_ctx.height;
811             \textcolor{keywordflow}{if} (!render\_width || !render\_height) \{
812               \textcolor{keywordtype}{int} render\_size[2];
813               \textcolor{keywordflow}{if} (\hyperlink{group__codec_ga6da974f4eeaba1fa74106b28d0fe6ac5}{aom\_codec\_control}(&decoder, 
      \hyperlink{group__aom__decoder_gga3865fd4b3192489baa9a5c3632ebe97ba592a5d1390204d743ddfe7bfe8ef177c}{AV1D\_GET\_DISPLAY\_SIZE},
814                                     render\_size)) \{
815                 \textcolor{comment}{// As last resort use size of first frame as display size.}
816                 render\_width = img->\hyperlink{structaom__image_a89f80b1f58d608b9d2080635f4359034}{d\_w};
817                 render\_height = img->\hyperlink{structaom__image_ab986419a1f0fff93a2dc505f47194988}{d\_h};
818               \} \textcolor{keywordflow}{else} \{
819                 render\_width = render\_size[0];
820                 render\_height = render\_size[1];
821               \}
822             \}
823             scaled\_img =
824                 \hyperlink{aom__image_8h_a570db29fbd122951235a08fe9375f6bb}{aom\_img\_alloc}(NULL, img->\hyperlink{structaom__image_a6c64b1ab918d80d52eb8f5d6d957e825}{fmt}, render\_width, render\_height, 16);
825             scaled\_img->\hyperlink{structaom__image_a46ed9ffd741938d306a0db5a24bdcf8e}{bit\_depth} = img->\hyperlink{structaom__image_a46ed9ffd741938d306a0db5a24bdcf8e}{bit\_depth};
826             scaled\_img->\hyperlink{structaom__image_ab7886616025ff8bd0bb96d967fca9ad8}{monochrome} = img->\hyperlink{structaom__image_ab7886616025ff8bd0bb96d967fca9ad8}{monochrome};
827             scaled\_img->\hyperlink{structaom__image_a4f235c521bc95a061e9e0b2a3d5d457e}{csp} = img->\hyperlink{structaom__image_a4f235c521bc95a061e9e0b2a3d5d457e}{csp};
828           \}
829 
830           \textcolor{keywordflow}{if} (img->\hyperlink{structaom__image_a89f80b1f58d608b9d2080635f4359034}{d\_w} != scaled\_img->\hyperlink{structaom__image_a89f80b1f58d608b9d2080635f4359034}{d\_w} || img->\hyperlink{structaom__image_ab986419a1f0fff93a2dc505f47194988}{d\_h} != scaled\_img->
      \hyperlink{structaom__image_ab986419a1f0fff93a2dc505f47194988}{d\_h}) \{
831 \textcolor{preprocessor}{#if CONFIG\_LIBYUV}
832             libyuv\_scale(img, scaled\_img, kFilterBox);
833             img = scaled\_img;
834 \textcolor{preprocessor}{#else}
835             fprintf(
836                 stderr,
837                 \textcolor{stringliteral}{"Failed to scale output frame: %s.\(\backslash\)n"}
838                 \textcolor{stringliteral}{"libyuv is required for scaling but is currently disabled.\(\backslash\)n"}
839                 \textcolor{stringliteral}{"Be sure to specify -DCONFIG\_LIBYUV=1 when running cmake.\(\backslash\)n"},
840                 \hyperlink{group__codec_ga50949c0854605c722832bbfb0803f5f4}{aom\_codec\_error}(&decoder));
841             \textcolor{keywordflow}{goto} fail;
842 \textcolor{preprocessor}{#endif}
843           \}
844         \}
845         \textcolor{comment}{// Default to codec bit depth if output bit depth not set}
846         \textcolor{keywordtype}{unsigned} \textcolor{keywordtype}{int} output\_bit\_depth;
847         \textcolor{keywordflow}{if} (!fixed\_output\_bit\_depth && single\_file && !do\_md5) \{
848           output\_bit\_depth = img->\hyperlink{structaom__image_a46ed9ffd741938d306a0db5a24bdcf8e}{bit\_depth};
849         \} \textcolor{keywordflow}{else} \{
850           output\_bit\_depth = fixed\_output\_bit\_depth;
851         \}
852         \textcolor{comment}{// Shift up or down if necessary}
853         \textcolor{keywordflow}{if} (output\_bit\_depth != 0)
854           aom\_shift\_img(output\_bit\_depth, &img, &img\_shifted);
855 
856         aom\_input\_ctx.width = img->\hyperlink{structaom__image_a89f80b1f58d608b9d2080635f4359034}{d\_w};
857         aom\_input\_ctx.height = img->\hyperlink{structaom__image_ab986419a1f0fff93a2dc505f47194988}{d\_h};
858 
859         \textcolor{keywordtype}{int} num\_planes = (opt\_raw && img->\hyperlink{structaom__image_ab7886616025ff8bd0bb96d967fca9ad8}{monochrome}) ? 1 : 3;
860         \textcolor{keywordflow}{if} (single\_file) \{
861           \textcolor{keywordflow}{if} (use\_y4m) \{
862             \textcolor{keywordtype}{char} y4m\_buf[Y4M\_BUFFER\_SIZE] = \{ 0 \};
863             \textcolor{keywordtype}{size\_t} len = 0;
864             \textcolor{keywordflow}{if} (frame\_out == 1) \{
865               \textcolor{comment}{// Y4M file header}
866               len = y4m\_write\_file\_header(
867                   y4m\_buf, \textcolor{keyword}{sizeof}(y4m\_buf), aom\_input\_ctx.width,
868                   aom\_input\_ctx.height, &aom\_input\_ctx.framerate,
869                   img->\hyperlink{structaom__image_ab7886616025ff8bd0bb96d967fca9ad8}{monochrome}, img->\hyperlink{structaom__image_a4f235c521bc95a061e9e0b2a3d5d457e}{csp}, img->\hyperlink{structaom__image_a6c64b1ab918d80d52eb8f5d6d957e825}{fmt}, img->
      \hyperlink{structaom__image_a46ed9ffd741938d306a0db5a24bdcf8e}{bit\_depth});
870               \textcolor{keywordflow}{if} (img->\hyperlink{structaom__image_a4f235c521bc95a061e9e0b2a3d5d457e}{csp} == \hyperlink{aom__image_8h_a10590253ef3dbde7e93ed5d4b4e0e73ba01ef7204c2234ef43acfd493d5e18c84}{AOM\_CSP\_COLOCATED}) \{
871                 fprintf(stderr,
872                         \textcolor{stringliteral}{"Warning: Y4M lacks a colorspace for colocated "}
873                         \textcolor{stringliteral}{"chroma. Using a placeholder.\(\backslash\)n"});
874               \}
875               \textcolor{keywordflow}{if} (do\_md5) \{
876                 MD5Update(&md5\_ctx, (md5byte *)y4m\_buf, (\textcolor{keywordtype}{unsigned} \textcolor{keywordtype}{int})len);
877               \} \textcolor{keywordflow}{else} \{
878                 fputs(y4m\_buf, outfile);
879               \}
880             \}
881 
882             \textcolor{comment}{// Y4M frame header}
883             len = y4m\_write\_frame\_header(y4m\_buf, \textcolor{keyword}{sizeof}(y4m\_buf));
884             \textcolor{keywordflow}{if} (do\_md5) \{
885               MD5Update(&md5\_ctx, (md5byte *)y4m\_buf, (\textcolor{keywordtype}{unsigned} \textcolor{keywordtype}{int})len);
886               y4m\_update\_image\_md5(img, planes, &md5\_ctx);
887             \} \textcolor{keywordflow}{else} \{
888               fputs(y4m\_buf, outfile);
889               y4m\_write\_image\_file(img, planes, outfile);
890             \}
891           \} \textcolor{keywordflow}{else} \{
892             \textcolor{keywordflow}{if} (frame\_out == 1) \{
893               \textcolor{comment}{// Check if --yv12 or --i420 options are consistent with the}
894               \textcolor{comment}{// bit-stream decoded}
895               \textcolor{keywordflow}{if} (opt\_i420) \{
896                 \textcolor{keywordflow}{if} (img->\hyperlink{structaom__image_a6c64b1ab918d80d52eb8f5d6d957e825}{fmt} != \hyperlink{aom__image_8h_a930317c04b4bd0a660bb5e744055523cabd778a3d697463e89d12a1117f417b60}{AOM\_IMG\_FMT\_I420} &&
897                     img->\hyperlink{structaom__image_a6c64b1ab918d80d52eb8f5d6d957e825}{fmt} != \hyperlink{aom__image_8h_a930317c04b4bd0a660bb5e744055523ca20a9cf30277260685642b4cfb4e9273b}{AOM\_IMG\_FMT\_I42016}) \{
898                   fprintf(stderr,
899                           \textcolor{stringliteral}{"Cannot produce i420 output for bit-stream.\(\backslash\)n"});
900                   \textcolor{keywordflow}{goto} fail;
901                 \}
902               \}
903               \textcolor{keywordflow}{if} (opt\_yv12) \{
904                 \textcolor{keywordflow}{if} ((img->\hyperlink{structaom__image_a6c64b1ab918d80d52eb8f5d6d957e825}{fmt} != \hyperlink{aom__image_8h_a930317c04b4bd0a660bb5e744055523cabd778a3d697463e89d12a1117f417b60}{AOM\_IMG\_FMT\_I420} &&
905                      img->\hyperlink{structaom__image_a6c64b1ab918d80d52eb8f5d6d957e825}{fmt} != \hyperlink{aom__image_8h_a930317c04b4bd0a660bb5e744055523cad28244100a2754409f285b77a3db90a0}{AOM\_IMG\_FMT\_YV12}) ||
906                     img->\hyperlink{structaom__image_a46ed9ffd741938d306a0db5a24bdcf8e}{bit\_depth} != 8) \{
907                   fprintf(stderr,
908                           \textcolor{stringliteral}{"Cannot produce yv12 output for bit-stream.\(\backslash\)n"});
909                   \textcolor{keywordflow}{goto} fail;
910                 \}
911               \}
912             \}
913             \textcolor{keywordflow}{if} (do\_md5) \{
914               raw\_update\_image\_md5(img, planes, num\_planes, &md5\_ctx);
915             \} \textcolor{keywordflow}{else} \{
916               raw\_write\_image\_file(img, planes, num\_planes, outfile);
917             \}
918           \}
919         \} \textcolor{keywordflow}{else} \{
920           generate\_filename(outfile\_pattern, outfile\_name, PATH\_MAX, img->\hyperlink{structaom__image_a89f80b1f58d608b9d2080635f4359034}{d\_w},
921                             img->\hyperlink{structaom__image_ab986419a1f0fff93a2dc505f47194988}{d\_h}, frame\_in);
922           \textcolor{keywordflow}{if} (do\_md5) \{
923             MD5Init(&md5\_ctx);
924             \textcolor{keywordflow}{if} (use\_y4m) \{
925               y4m\_update\_image\_md5(img, planes, &md5\_ctx);
926             \} \textcolor{keywordflow}{else} \{
927               raw\_update\_image\_md5(img, planes, num\_planes, &md5\_ctx);
928             \}
929             MD5Final(md5\_digest, &md5\_ctx);
930             print\_md5(md5\_digest, outfile\_name);
931           \} \textcolor{keywordflow}{else} \{
932             outfile = open\_outfile(outfile\_name);
933             \textcolor{keywordflow}{if} (use\_y4m) \{
934               y4m\_write\_image\_file(img, planes, outfile);
935             \} \textcolor{keywordflow}{else} \{
936               raw\_write\_image\_file(img, planes, num\_planes, outfile);
937             \}
938             fclose(outfile);
939           \}
940         \}
941       \}
942     \}
943   \}
944 
945   \textcolor{keywordflow}{if} (summary || progress) \{
946     show\_progress(frame\_in, frame\_out, dx\_time);
947     fprintf(stderr, \textcolor{stringliteral}{"\(\backslash\)n"});
948   \}
949 
950   \textcolor{keywordflow}{if} (frames\_corrupted) \{
951     fprintf(stderr, \textcolor{stringliteral}{"WARNING: %d frames corrupted.\(\backslash\)n"}, frames\_corrupted);
952   \} \textcolor{keywordflow}{else} \{
953     ret = EXIT\_SUCCESS;
954   \}
955 
956 fail:
957 
958   \textcolor{keywordflow}{if} (\hyperlink{group__codec_ga9b60e186f61ba2d6ab2b8069b76a15c5}{aom\_codec\_destroy}(&decoder)) \{
959     fprintf(stderr, \textcolor{stringliteral}{"Failed to destroy decoder: %s\(\backslash\)n"},
960             \hyperlink{group__codec_ga50949c0854605c722832bbfb0803f5f4}{aom\_codec\_error}(&decoder));
961   \}
962 
963 fail2:
964 
965   \textcolor{keywordflow}{if} (!noblit && single\_file) \{
966     \textcolor{keywordflow}{if} (do\_md5) \{
967       MD5Final(md5\_digest, &md5\_ctx);
968       print\_md5(md5\_digest, outfile\_name);
969     \} \textcolor{keywordflow}{else} \{
970       fclose(outfile);
971     \}
972   \}
973 
974 \textcolor{preprocessor}{#if CONFIG\_WEBM\_IO}
975   \textcolor{keywordflow}{if} (input.aom\_input\_ctx->file\_type == FILE\_TYPE\_WEBM)
976     webm\_free(input.webm\_ctx);
977 \textcolor{preprocessor}{#endif}
978   \textcolor{keywordflow}{if} (input.aom\_input\_ctx->file\_type == FILE\_TYPE\_OBU)
979     obudec\_free(input.obu\_ctx);
980 
981   \textcolor{keywordflow}{if} (input.aom\_input\_ctx->file\_type != FILE\_TYPE\_WEBM) free(buf);
982 
983   \textcolor{keywordflow}{if} (scaled\_img) \hyperlink{aom__image_8h_afff22f7f3eb9409c5b678d1962f110a8}{aom\_img\_free}(scaled\_img);
984   \textcolor{keywordflow}{if} (img\_shifted) \hyperlink{aom__image_8h_afff22f7f3eb9409c5b678d1962f110a8}{aom\_img\_free}(img\_shifted);
985 
986   \textcolor{keywordflow}{for} (i = 0; i < ext\_fb\_list.num\_external\_frame\_buffers; ++i) \{
987     free(ext\_fb\_list.ext\_fb[i].data);
988   \}
989   free(ext\_fb\_list.ext\_fb);
990 
991   fclose(infile);
992   \textcolor{keywordflow}{if} (framestats\_file) fclose(framestats\_file);
993 
994   free(argv);
995 
996   \textcolor{keywordflow}{return} ret;
997 \}
998 
999 \textcolor{keywordtype}{int} main(\textcolor{keywordtype}{int} argc, \textcolor{keyword}{const} \textcolor{keywordtype}{char} **argv\_) \{
1000   \textcolor{keywordtype}{unsigned} \textcolor{keywordtype}{int} loops = 1, i;
1001   \textcolor{keywordtype}{char} **argv, **argi, **argj;
1002   \textcolor{keyword}{struct }arg arg;
1003   \textcolor{keywordtype}{int} error = 0;
1004 
1005   argv = argv\_dup(argc - 1, argv\_ + 1);
1006   \textcolor{keywordflow}{for} (argi = argj = argv; (*argj = *argi); argi += arg.argv\_step) \{
1007     memset(&arg, 0, \textcolor{keyword}{sizeof}(arg));
1008     arg.argv\_step = 1;
1009 
1010     \textcolor{keywordflow}{if} (arg\_match(&arg, &looparg, argi)) \{
1011       loops = arg\_parse\_uint(&arg);
1012       \textcolor{keywordflow}{break};
1013     \}
1014   \}
1015   free(argv);
1016   \textcolor{keywordflow}{for} (i = 0; !error && i < loops; i++) error = main\_loop(argc, argv\_);
1017   \textcolor{keywordflow}{return} error;
1018 \}
\end{DoxyCodeInclude}
 \hypertarget{example_aomenc}{}\subsection{aomenc}\label{example_aomenc}

\begin{DoxyCodeInclude}
1 \textcolor{comment}{/*}
2 \textcolor{comment}{ * Copyright (c) 2016, Alliance for Open Media. All rights reserved}
3 \textcolor{comment}{ *}
4 \textcolor{comment}{ * This source code is subject to the terms of the BSD 2 Clause License and}
5 \textcolor{comment}{ * the Alliance for Open Media Patent License 1.0. If the BSD 2 Clause License}
6 \textcolor{comment}{ * was not distributed with this source code in the LICENSE file, you can}
7 \textcolor{comment}{ * obtain it at www.aomedia.org/license/software. If the Alliance for Open}
8 \textcolor{comment}{ * Media Patent License 1.0 was not distributed with this source code in the}
9 \textcolor{comment}{ * PATENTS file, you can obtain it at www.aomedia.org/license/patent.}
10 \textcolor{comment}{ */}
11 
12 \textcolor{preprocessor}{#include "apps/aomenc.h"}
13 
14 \textcolor{preprocessor}{#include "config/aom\_config.h"}
15 
16 \textcolor{preprocessor}{#include <assert.h>}
17 \textcolor{preprocessor}{#include <limits.h>}
18 \textcolor{preprocessor}{#include <math.h>}
19 \textcolor{preprocessor}{#include <stdarg.h>}
20 \textcolor{preprocessor}{#include <stdio.h>}
21 \textcolor{preprocessor}{#include <stdlib.h>}
22 \textcolor{preprocessor}{#include <string.h>}
23 
24 \textcolor{preprocessor}{#if CONFIG\_AV1\_DECODER}
25 \textcolor{preprocessor}{#include "\hyperlink{aom__decoder_8h}{aom/aom\_decoder.h}"}
26 \textcolor{preprocessor}{#include "\hyperlink{aomdx_8h}{aom/aomdx.h}"}
27 \textcolor{preprocessor}{#endif}
28 
29 \textcolor{preprocessor}{#include "\hyperlink{aom__encoder_8h}{aom/aom\_encoder.h}"}
30 \textcolor{preprocessor}{#include "aom/aom\_integer.h"}
31 \textcolor{preprocessor}{#include "\hyperlink{aomcx_8h}{aom/aomcx.h}"}
32 \textcolor{preprocessor}{#include "aom\_dsp/aom\_dsp\_common.h"}
33 \textcolor{preprocessor}{#include "aom\_ports/aom\_timer.h"}
34 \textcolor{preprocessor}{#include "aom\_ports/mem\_ops.h"}
35 \textcolor{preprocessor}{#include "common/args.h"}
36 \textcolor{preprocessor}{#include "common/ivfenc.h"}
37 \textcolor{preprocessor}{#include "common/tools\_common.h"}
38 \textcolor{preprocessor}{#include "common/warnings.h"}
39 
40 \textcolor{preprocessor}{#if CONFIG\_WEBM\_IO}
41 \textcolor{preprocessor}{#include "common/webmenc.h"}
42 \textcolor{preprocessor}{#endif}
43 
44 \textcolor{preprocessor}{#include "common/y4minput.h"}
45 \textcolor{preprocessor}{#include "examples/encoder\_util.h"}
46 \textcolor{preprocessor}{#include "stats/aomstats.h"}
47 \textcolor{preprocessor}{#include "stats/rate\_hist.h"}
48 
49 \textcolor{preprocessor}{#if CONFIG\_LIBYUV}
50 \textcolor{preprocessor}{#include "third\_party/libyuv/include/libyuv/scale.h"}
51 \textcolor{preprocessor}{#endif}
52 
53 \textcolor{comment}{/* Swallow warnings about unused results of fread/fwrite */}
54 \textcolor{keyword}{static} \textcolor{keywordtype}{size\_t} wrap\_fread(\textcolor{keywordtype}{void} *ptr, \textcolor{keywordtype}{size\_t} size, \textcolor{keywordtype}{size\_t} nmemb, FILE *stream) \{
55   \textcolor{keywordflow}{return} fread(ptr, size, nmemb, stream);
56 \}
57 \textcolor{preprocessor}{#define fread wrap\_fread}
58 
59 \textcolor{keyword}{static} \textcolor{keywordtype}{size\_t} wrap\_fwrite(\textcolor{keyword}{const} \textcolor{keywordtype}{void} *ptr, \textcolor{keywordtype}{size\_t} size, \textcolor{keywordtype}{size\_t} nmemb,
60                           FILE *stream) \{
61   \textcolor{keywordflow}{return} fwrite(ptr, size, nmemb, stream);
62 \}
63 \textcolor{preprocessor}{#define fwrite wrap\_fwrite}
64 
65 \textcolor{keyword}{static} \textcolor{keyword}{const} \textcolor{keywordtype}{char} *exec\_name;
66 
67 \textcolor{keyword}{static} \textcolor{keywordtype}{void} warn\_or\_exit\_on\_errorv(\hyperlink{structaom__codec__ctx}{aom\_codec\_ctx\_t} *ctx, \textcolor{keywordtype}{int} fatal,
68                                    \textcolor{keyword}{const} \textcolor{keywordtype}{char} *s, va\_list ap) \{
69   \textcolor{keywordflow}{if} (ctx->\hyperlink{structaom__codec__ctx_a4cf9c265a7c34e92bb02d04aa3cab718}{err}) \{
70     \textcolor{keyword}{const} \textcolor{keywordtype}{char} *detail = \hyperlink{group__codec_ga43a70562598b485685794a4e9d9d53f7}{aom\_codec\_error\_detail}(ctx);
71 
72     vfprintf(stderr, s, ap);
73     fprintf(stderr, \textcolor{stringliteral}{": %s\(\backslash\)n"}, \hyperlink{group__codec_ga50949c0854605c722832bbfb0803f5f4}{aom\_codec\_error}(ctx));
74 
75     \textcolor{keywordflow}{if} (detail) fprintf(stderr, \textcolor{stringliteral}{"    %s\(\backslash\)n"}, detail);
76 
77     \textcolor{keywordflow}{if} (fatal) exit(EXIT\_FAILURE);
78   \}
79 \}
80 
81 \textcolor{keyword}{static} \textcolor{keywordtype}{void} ctx\_exit\_on\_error(\hyperlink{structaom__codec__ctx}{aom\_codec\_ctx\_t} *ctx, \textcolor{keyword}{const} \textcolor{keywordtype}{char} *s, ...) \{
82   va\_list ap;
83 
84   va\_start(ap, s);
85   warn\_or\_exit\_on\_errorv(ctx, 1, s, ap);
86   va\_end(ap);
87 \}
88 
89 \textcolor{keyword}{static} \textcolor{keywordtype}{void} warn\_or\_exit\_on\_error(\hyperlink{structaom__codec__ctx}{aom\_codec\_ctx\_t} *ctx, \textcolor{keywordtype}{int} fatal,
90                                   \textcolor{keyword}{const} \textcolor{keywordtype}{char} *s, ...) \{
91   va\_list ap;
92 
93   va\_start(ap, s);
94   warn\_or\_exit\_on\_errorv(ctx, fatal, s, ap);
95   va\_end(ap);
96 \}
97 
98 \textcolor{keyword}{static} \textcolor{keywordtype}{int} read\_frame(\textcolor{keyword}{struct} AvxInputContext *input\_ctx, \hyperlink{structaom__image}{aom\_image\_t} *img) \{
99   FILE *f = input\_ctx->file;
100   y4m\_input *y4m = &input\_ctx->y4m;
101   \textcolor{keywordtype}{int} shortread = 0;
102 
103   \textcolor{keywordflow}{if} (input\_ctx->file\_type == FILE\_TYPE\_Y4M) \{
104     \textcolor{keywordflow}{if} (y4m\_input\_fetch\_frame(y4m, f, img) < 1) \textcolor{keywordflow}{return} 0;
105   \} \textcolor{keywordflow}{else} \{
106     shortread = read\_yuv\_frame(input\_ctx, img);
107   \}
108 
109   \textcolor{keywordflow}{return} !shortread;
110 \}
111 
112 \textcolor{keyword}{static} \textcolor{keywordtype}{int} file\_is\_y4m(\textcolor{keyword}{const} \textcolor{keywordtype}{char} detect[4]) \{
113   \textcolor{keywordflow}{if} (memcmp(detect, \textcolor{stringliteral}{"YUV4"}, 4) == 0) \{
114     \textcolor{keywordflow}{return} 1;
115   \}
116   \textcolor{keywordflow}{return} 0;
117 \}
118 
119 \textcolor{keyword}{static} \textcolor{keywordtype}{int} fourcc\_is\_ivf(\textcolor{keyword}{const} \textcolor{keywordtype}{char} detect[4]) \{
120   \textcolor{keywordflow}{if} (memcmp(detect, \textcolor{stringliteral}{"DKIF"}, 4) == 0) \{
121     \textcolor{keywordflow}{return} 1;
122   \}
123   \textcolor{keywordflow}{return} 0;
124 \}
125 
126 \textcolor{keyword}{static} \textcolor{keyword}{const} arg\_def\_t help =
127     ARG\_DEF(NULL, \textcolor{stringliteral}{"help"}, 0, \textcolor{stringliteral}{"Show usage options and exit"});
128 \textcolor{keyword}{static} \textcolor{keyword}{const} arg\_def\_t debugmode =
129     ARG\_DEF(\textcolor{stringliteral}{"D"}, \textcolor{stringliteral}{"debug"}, 0, \textcolor{stringliteral}{"Debug mode (makes output deterministic)"});
130 \textcolor{keyword}{static} \textcolor{keyword}{const} arg\_def\_t outputfile =
131     ARG\_DEF(\textcolor{stringliteral}{"o"}, \textcolor{stringliteral}{"output"}, 1, \textcolor{stringliteral}{"Output filename"});
132 \textcolor{keyword}{static} \textcolor{keyword}{const} arg\_def\_t use\_yv12 =
133     ARG\_DEF(NULL, \textcolor{stringliteral}{"yv12"}, 0, \textcolor{stringliteral}{"Input file is YV12 "});
134 \textcolor{keyword}{static} \textcolor{keyword}{const} arg\_def\_t use\_i420 =
135     ARG\_DEF(NULL, \textcolor{stringliteral}{"i420"}, 0, \textcolor{stringliteral}{"Input file is I420 (default)"});
136 \textcolor{keyword}{static} \textcolor{keyword}{const} arg\_def\_t use\_i422 =
137     ARG\_DEF(NULL, \textcolor{stringliteral}{"i422"}, 0, \textcolor{stringliteral}{"Input file is I422"});
138 \textcolor{keyword}{static} \textcolor{keyword}{const} arg\_def\_t use\_i444 =
139     ARG\_DEF(NULL, \textcolor{stringliteral}{"i444"}, 0, \textcolor{stringliteral}{"Input file is I444"});
140 \textcolor{keyword}{static} \textcolor{keyword}{const} arg\_def\_t codecarg = ARG\_DEF(NULL, \textcolor{stringliteral}{"codec"}, 1, \textcolor{stringliteral}{"Codec to use"});
141 \textcolor{keyword}{static} \textcolor{keyword}{const} arg\_def\_t passes =
142     ARG\_DEF(\textcolor{stringliteral}{"p"}, \textcolor{stringliteral}{"passes"}, 1, \textcolor{stringliteral}{"Number of passes (1/2)"});
143 \textcolor{keyword}{static} \textcolor{keyword}{const} arg\_def\_t pass\_arg =
144     ARG\_DEF(NULL, \textcolor{stringliteral}{"pass"}, 1, \textcolor{stringliteral}{"Pass to execute (1/2)"});
145 \textcolor{keyword}{static} \textcolor{keyword}{const} arg\_def\_t fpf\_name =
146     ARG\_DEF(NULL, \textcolor{stringliteral}{"fpf"}, 1, \textcolor{stringliteral}{"First pass statistics file name"});
147 \textcolor{preprocessor}{#if CONFIG\_FP\_MB\_STATS}
148 \textcolor{keyword}{static} \textcolor{keyword}{const} arg\_def\_t fpmbf\_name =
149     ARG\_DEF(NULL, \textcolor{stringliteral}{"fpmbf"}, 1, \textcolor{stringliteral}{"First pass block statistics file name"});
150 \textcolor{preprocessor}{#endif}
151 \textcolor{keyword}{static} \textcolor{keyword}{const} arg\_def\_t limit =
152     ARG\_DEF(NULL, \textcolor{stringliteral}{"limit"}, 1, \textcolor{stringliteral}{"Stop encoding after n input frames"});
153 \textcolor{keyword}{static} \textcolor{keyword}{const} arg\_def\_t skip =
154     ARG\_DEF(NULL, \textcolor{stringliteral}{"skip"}, 1, \textcolor{stringliteral}{"Skip the first n input frames"});
155 \textcolor{keyword}{static} \textcolor{keyword}{const} arg\_def\_t good\_dl =
156     ARG\_DEF(NULL, \textcolor{stringliteral}{"good"}, 0, \textcolor{stringliteral}{"Use Good Quality Deadline"});
157 \textcolor{keyword}{static} \textcolor{keyword}{const} arg\_def\_t quietarg =
158     ARG\_DEF(\textcolor{stringliteral}{"q"}, \textcolor{stringliteral}{"quiet"}, 0, \textcolor{stringliteral}{"Do not print encode progress"});
159 \textcolor{keyword}{static} \textcolor{keyword}{const} arg\_def\_t verbosearg =
160     ARG\_DEF(\textcolor{stringliteral}{"v"}, \textcolor{stringliteral}{"verbose"}, 0, \textcolor{stringliteral}{"Show encoder parameters"});
161 \textcolor{keyword}{static} \textcolor{keyword}{const} arg\_def\_t psnrarg =
162     ARG\_DEF(NULL, \textcolor{stringliteral}{"psnr"}, 0, \textcolor{stringliteral}{"Show PSNR in status line"});
163 \textcolor{preprocessor}{#if CONFIG\_FILEOPTIONS}
164 \textcolor{keyword}{static} \textcolor{keyword}{const} arg\_def\_t use\_cfg = ARG\_DEF(\textcolor{stringliteral}{"c"}, \textcolor{stringliteral}{"cfg"}, 1, \textcolor{stringliteral}{"Config file to use"});
165 \textcolor{keyword}{static} \textcolor{keyword}{const} arg\_def\_t ext\_partition =
166     ARG\_DEF(NULL, \textcolor{stringliteral}{"ext-partition"}, 1, \textcolor{stringliteral}{"corresponds to extended partitions"});
167 \textcolor{preprocessor}{#endif}
168 
169 \textcolor{keyword}{static} \textcolor{keyword}{const} \textcolor{keyword}{struct }arg\_enum\_list test\_decode\_enum[] = \{
170   \{ \textcolor{stringliteral}{"off"}, TEST\_DECODE\_OFF \},
171   \{ \textcolor{stringliteral}{"fatal"}, TEST\_DECODE\_FATAL \},
172   \{ \textcolor{stringliteral}{"warn"}, TEST\_DECODE\_WARN \},
173   \{ NULL, 0 \}
174 \};
175 \textcolor{keyword}{static} \textcolor{keyword}{const} arg\_def\_t recontest = ARG\_DEF\_ENUM(
176     NULL, \textcolor{stringliteral}{"test-decode"}, 1, \textcolor{stringliteral}{"Test encode/decode mismatch"}, test\_decode\_enum);
177 \textcolor{keyword}{static} \textcolor{keyword}{const} arg\_def\_t framerate =
178     ARG\_DEF(NULL, \textcolor{stringliteral}{"fps"}, 1, \textcolor{stringliteral}{"Stream frame rate (rate/scale)"});
179 \textcolor{keyword}{static} \textcolor{keyword}{const} arg\_def\_t use\_webm =
180     ARG\_DEF(NULL, \textcolor{stringliteral}{"webm"}, 0, \textcolor{stringliteral}{"Output WebM (default when WebM IO is enabled)"});
181 \textcolor{keyword}{static} \textcolor{keyword}{const} arg\_def\_t use\_ivf = ARG\_DEF(NULL, \textcolor{stringliteral}{"ivf"}, 0, \textcolor{stringliteral}{"Output IVF"});
182 \textcolor{keyword}{static} \textcolor{keyword}{const} arg\_def\_t use\_obu = ARG\_DEF(NULL, \textcolor{stringliteral}{"obu"}, 0, \textcolor{stringliteral}{"Output OBU"});
183 \textcolor{keyword}{static} \textcolor{keyword}{const} arg\_def\_t q\_hist\_n =
184     ARG\_DEF(NULL, \textcolor{stringliteral}{"q-hist"}, 1, \textcolor{stringliteral}{"Show quantizer histogram (n-buckets)"});
185 \textcolor{keyword}{static} \textcolor{keyword}{const} arg\_def\_t rate\_hist\_n =
186     ARG\_DEF(NULL, \textcolor{stringliteral}{"rate-hist"}, 1, \textcolor{stringliteral}{"Show rate histogram (n-buckets)"});
187 \textcolor{keyword}{static} \textcolor{keyword}{const} arg\_def\_t disable\_warnings =
188     ARG\_DEF(NULL, \textcolor{stringliteral}{"disable-warnings"}, 0,
189             \textcolor{stringliteral}{"Disable warnings about potentially incorrect encode settings."});
190 \textcolor{keyword}{static} \textcolor{keyword}{const} arg\_def\_t disable\_warning\_prompt =
191     ARG\_DEF(\textcolor{stringliteral}{"y"}, \textcolor{stringliteral}{"disable-warning-prompt"}, 0,
192             \textcolor{stringliteral}{"Display warnings, but do not prompt user to continue."});
193 \textcolor{keyword}{static} \textcolor{keyword}{const} \textcolor{keyword}{struct }arg\_enum\_list bitdepth\_enum[] = \{
194   \{ \textcolor{stringliteral}{"8"}, \hyperlink{group__codec_gga6ed0e98eba4651c1ad845e39498e4153a4c7f55539160206a3fbb2a6cfc9ef89c}{AOM\_BITS\_8} \}, \{ \textcolor{stringliteral}{"10"}, \hyperlink{group__codec_gga6ed0e98eba4651c1ad845e39498e4153a91734384f432233c3d681052122ab8e7}{AOM\_BITS\_10} \}, \{ \textcolor{stringliteral}{"12"}, 
      \hyperlink{group__codec_gga6ed0e98eba4651c1ad845e39498e4153a15836a87f9e9940885d5ef59a52bf728}{AOM\_BITS\_12} \}, \{ NULL, 0 \}
195 \};
196 
197 \textcolor{keyword}{static} \textcolor{keyword}{const} arg\_def\_t bitdeptharg = ARG\_DEF\_ENUM(
198     \textcolor{stringliteral}{"b"}, \textcolor{stringliteral}{"bit-depth"}, 1,
199     \textcolor{stringliteral}{"Bit depth for codec (8 for version <=1, 10 or 12 for version 2)"},
200     bitdepth\_enum);
201 \textcolor{keyword}{static} \textcolor{keyword}{const} arg\_def\_t inbitdeptharg =
202     ARG\_DEF(NULL, \textcolor{stringliteral}{"input-bit-depth"}, 1, \textcolor{stringliteral}{"Bit depth of input"});
203 
204 \textcolor{keyword}{static} \textcolor{keyword}{const} arg\_def\_t input\_chroma\_subsampling\_x = ARG\_DEF(
205     NULL, \textcolor{stringliteral}{"input-chroma-subsampling-x"}, 1, \textcolor{stringliteral}{"chroma subsampling x value."});
206 \textcolor{keyword}{static} \textcolor{keyword}{const} arg\_def\_t input\_chroma\_subsampling\_y = ARG\_DEF(
207     NULL, \textcolor{stringliteral}{"input-chroma-subsampling-y"}, 1, \textcolor{stringliteral}{"chroma subsampling y value."});
208 
209 \textcolor{keyword}{static} \textcolor{keyword}{const} arg\_def\_t *main\_args[] = \{ &help,
210 \textcolor{preprocessor}{#if CONFIG\_FILEOPTIONS}
211                                         &use\_cfg,
212 \textcolor{preprocessor}{#endif}
213                                         &debugmode,
214                                         &outputfile,
215                                         &codecarg,
216                                         &passes,
217                                         &pass\_arg,
218                                         &fpf\_name,
219                                         &limit,
220                                         &skip,
221                                         &good\_dl,
222                                         &quietarg,
223                                         &verbosearg,
224                                         &psnrarg,
225                                         &use\_webm,
226                                         &use\_ivf,
227                                         &use\_obu,
228                                         &q\_hist\_n,
229                                         &rate\_hist\_n,
230                                         &disable\_warnings,
231                                         &disable\_warning\_prompt,
232                                         &recontest,
233                                         NULL \};
234 
235 \textcolor{keyword}{static} \textcolor{keyword}{const} arg\_def\_t usage =
236     ARG\_DEF(\textcolor{stringliteral}{"u"}, \textcolor{stringliteral}{"usage"}, 1, \textcolor{stringliteral}{"Usage profile number to use"});
237 \textcolor{keyword}{static} \textcolor{keyword}{const} arg\_def\_t threads =
238     ARG\_DEF(\textcolor{stringliteral}{"t"}, \textcolor{stringliteral}{"threads"}, 1, \textcolor{stringliteral}{"Max number of threads to use"});
239 \textcolor{keyword}{static} \textcolor{keyword}{const} arg\_def\_t profile =
240     ARG\_DEF(NULL, \textcolor{stringliteral}{"profile"}, 1, \textcolor{stringliteral}{"Bitstream profile number to use"});
241 \textcolor{keyword}{static} \textcolor{keyword}{const} arg\_def\_t width = ARG\_DEF(\textcolor{stringliteral}{"w"}, \textcolor{stringliteral}{"width"}, 1, \textcolor{stringliteral}{"Frame width"});
242 \textcolor{keyword}{static} \textcolor{keyword}{const} arg\_def\_t height = ARG\_DEF(\textcolor{stringliteral}{"h"}, \textcolor{stringliteral}{"height"}, 1, \textcolor{stringliteral}{"Frame height"});
243 \textcolor{keyword}{static} \textcolor{keyword}{const} arg\_def\_t forced\_max\_frame\_width = ARG\_DEF(
244     NULL, \textcolor{stringliteral}{"forced\_max\_frame\_width"}, 0, \textcolor{stringliteral}{"Maximum frame width value to force"});
245 \textcolor{keyword}{static} \textcolor{keyword}{const} arg\_def\_t forced\_max\_frame\_height = ARG\_DEF(
246     NULL, \textcolor{stringliteral}{"forced\_max\_frame\_height"}, 0, \textcolor{stringliteral}{"Maximum frame height value to force"});
247 \textcolor{preprocessor}{#if CONFIG\_WEBM\_IO}
248 \textcolor{keyword}{static} \textcolor{keyword}{const} \textcolor{keyword}{struct }arg\_enum\_list stereo\_mode\_enum[] = \{
249   \{ \textcolor{stringliteral}{"mono"}, STEREO\_FORMAT\_MONO \},
250   \{ \textcolor{stringliteral}{"left-right"}, STEREO\_FORMAT\_LEFT\_RIGHT \},
251   \{ \textcolor{stringliteral}{"bottom-top"}, STEREO\_FORMAT\_BOTTOM\_TOP \},
252   \{ \textcolor{stringliteral}{"top-bottom"}, STEREO\_FORMAT\_TOP\_BOTTOM \},
253   \{ \textcolor{stringliteral}{"right-left"}, STEREO\_FORMAT\_RIGHT\_LEFT \},
254   \{ NULL, 0 \}
255 \};
256 \textcolor{keyword}{static} \textcolor{keyword}{const} arg\_def\_t stereo\_mode = ARG\_DEF\_ENUM(
257     NULL, \textcolor{stringliteral}{"stereo-mode"}, 1, \textcolor{stringliteral}{"Stereo 3D video format"}, stereo\_mode\_enum);
258 \textcolor{preprocessor}{#endif}
259 \textcolor{keyword}{static} \textcolor{keyword}{const} arg\_def\_t timebase = ARG\_DEF(
260     NULL, \textcolor{stringliteral}{"timebase"}, 1, \textcolor{stringliteral}{"Output timestamp precision (fractional seconds)"});
261 \textcolor{keyword}{static} \textcolor{keyword}{const} arg\_def\_t global\_error\_resilient =
262     ARG\_DEF(NULL, \textcolor{stringliteral}{"global-error-resilient"}, 1,
263             \textcolor{stringliteral}{"Enable global error resiliency features"});
264 \textcolor{keyword}{static} \textcolor{keyword}{const} arg\_def\_t lag\_in\_frames =
265     ARG\_DEF(NULL, \textcolor{stringliteral}{"lag-in-frames"}, 1, \textcolor{stringliteral}{"Max number of frames to lag"});
266 \textcolor{keyword}{static} \textcolor{keyword}{const} arg\_def\_t large\_scale\_tile =
267     ARG\_DEF(NULL, \textcolor{stringliteral}{"large-scale-tile"}, 1,
268             \textcolor{stringliteral}{"Large scale tile coding (0: off (default), 1: on)"});
269 \textcolor{keyword}{static} \textcolor{keyword}{const} arg\_def\_t monochrome =
270     ARG\_DEF(NULL, \textcolor{stringliteral}{"monochrome"}, 0, \textcolor{stringliteral}{"Monochrome video (no chroma planes)"});
271 \textcolor{keyword}{static} \textcolor{keyword}{const} arg\_def\_t full\_still\_picture\_hdr = ARG\_DEF(
272     NULL, \textcolor{stringliteral}{"full-still-picture-hdr"}, 0, \textcolor{stringliteral}{"Use full header for still picture"});
273 
274 \textcolor{keyword}{static} \textcolor{keyword}{const} arg\_def\_t *global\_args[] = \{ &use\_yv12,
275                                           &use\_i420,
276                                           &use\_i422,
277                                           &use\_i444,
278                                           &usage,
279                                           &threads,
280                                           &profile,
281                                           &width,
282                                           &height,
283                                           &forced\_max\_frame\_width,
284                                           &forced\_max\_frame\_height,
285 \textcolor{preprocessor}{#if CONFIG\_WEBM\_IO}
286                                           &stereo\_mode,
287 \textcolor{preprocessor}{#endif}
288                                           &timebase,
289                                           &framerate,
290                                           &global\_error\_resilient,
291                                           &bitdeptharg,
292                                           &lag\_in\_frames,
293                                           &large\_scale\_tile,
294                                           &monochrome,
295                                           &full\_still\_picture\_hdr,
296                                           NULL \};
297 
298 \textcolor{keyword}{static} \textcolor{keyword}{const} arg\_def\_t dropframe\_thresh =
299     ARG\_DEF(NULL, \textcolor{stringliteral}{"drop-frame"}, 1, \textcolor{stringliteral}{"Temporal resampling threshold (buf %)"});
300 \textcolor{keyword}{static} \textcolor{keyword}{const} arg\_def\_t resize\_mode =
301     ARG\_DEF(NULL, \textcolor{stringliteral}{"resize-mode"}, 1, \textcolor{stringliteral}{"Frame resize mode"});
302 \textcolor{keyword}{static} \textcolor{keyword}{const} arg\_def\_t resize\_denominator =
303     ARG\_DEF(NULL, \textcolor{stringliteral}{"resize-denominator"}, 1, \textcolor{stringliteral}{"Frame resize denominator"});
304 \textcolor{keyword}{static} \textcolor{keyword}{const} arg\_def\_t resize\_kf\_denominator = ARG\_DEF(
305     NULL, \textcolor{stringliteral}{"resize-kf-denominator"}, 1, \textcolor{stringliteral}{"Frame resize keyframe denominator"});
306 \textcolor{keyword}{static} \textcolor{keyword}{const} arg\_def\_t superres\_mode =
307     ARG\_DEF(NULL, \textcolor{stringliteral}{"superres-mode"}, 1, \textcolor{stringliteral}{"Frame super-resolution mode"});
308 \textcolor{keyword}{static} \textcolor{keyword}{const} arg\_def\_t superres\_denominator = ARG\_DEF(
309     NULL, \textcolor{stringliteral}{"superres-denominator"}, 1, \textcolor{stringliteral}{"Frame super-resolution denominator"});
310 \textcolor{keyword}{static} \textcolor{keyword}{const} arg\_def\_t superres\_kf\_denominator =
311     ARG\_DEF(NULL, \textcolor{stringliteral}{"superres-kf-denominator"}, 1,
312             \textcolor{stringliteral}{"Frame super-resolution keyframe denominator"});
313 \textcolor{keyword}{static} \textcolor{keyword}{const} arg\_def\_t superres\_qthresh = ARG\_DEF(
314     NULL, \textcolor{stringliteral}{"superres-qthresh"}, 1, \textcolor{stringliteral}{"Frame super-resolution qindex threshold"});
315 \textcolor{keyword}{static} \textcolor{keyword}{const} arg\_def\_t superres\_kf\_qthresh =
316     ARG\_DEF(NULL, \textcolor{stringliteral}{"superres-kf-qthresh"}, 1,
317             \textcolor{stringliteral}{"Frame super-resolution keyframe qindex threshold"});
318 \textcolor{keyword}{static} \textcolor{keyword}{const} \textcolor{keyword}{struct }arg\_enum\_list end\_usage\_enum[] = \{ \{ \textcolor{stringliteral}{"vbr"}, \hyperlink{group__encoder_gga7c084d3ecef569aad166ce70b0e8a957a7d3a2574737ea63d0f160ffdbd7f0110}{AOM\_VBR} \},
319                                                        \{ \textcolor{stringliteral}{"cbr"}, \hyperlink{group__encoder_gga7c084d3ecef569aad166ce70b0e8a957a14b6057d61c61e6117f5af16dcf89b0c}{AOM\_CBR} \},
320                                                        \{ \textcolor{stringliteral}{"cq"}, \hyperlink{group__encoder_gga7c084d3ecef569aad166ce70b0e8a957a70aa1f15e91f6576ba3e63879947be64}{AOM\_CQ} \},
321                                                        \{ \textcolor{stringliteral}{"q"}, \hyperlink{group__encoder_gga7c084d3ecef569aad166ce70b0e8a957aff3bbd4fe870b4b946c2093e59eb14e5}{AOM\_Q} \},
322                                                        \{ NULL, 0 \} \};
323 \textcolor{keyword}{static} \textcolor{keyword}{const} arg\_def\_t end\_usage =
324     ARG\_DEF\_ENUM(NULL, \textcolor{stringliteral}{"end-usage"}, 1, \textcolor{stringliteral}{"Rate control mode"}, end\_usage\_enum);
325 \textcolor{keyword}{static} \textcolor{keyword}{const} arg\_def\_t target\_bitrate =
326     ARG\_DEF(NULL, \textcolor{stringliteral}{"target-bitrate"}, 1, \textcolor{stringliteral}{"Bitrate (kbps)"});
327 \textcolor{keyword}{static} \textcolor{keyword}{const} arg\_def\_t min\_quantizer =
328     ARG\_DEF(NULL, \textcolor{stringliteral}{"min-q"}, 1, \textcolor{stringliteral}{"Minimum (best) quantizer"});
329 \textcolor{keyword}{static} \textcolor{keyword}{const} arg\_def\_t max\_quantizer =
330     ARG\_DEF(NULL, \textcolor{stringliteral}{"max-q"}, 1, \textcolor{stringliteral}{"Maximum (worst) quantizer"});
331 \textcolor{keyword}{static} \textcolor{keyword}{const} arg\_def\_t undershoot\_pct =
332     ARG\_DEF(NULL, \textcolor{stringliteral}{"undershoot-pct"}, 1, \textcolor{stringliteral}{"Datarate undershoot (min) target (%)"});
333 \textcolor{keyword}{static} \textcolor{keyword}{const} arg\_def\_t overshoot\_pct =
334     ARG\_DEF(NULL, \textcolor{stringliteral}{"overshoot-pct"}, 1, \textcolor{stringliteral}{"Datarate overshoot (max) target (%)"});
335 \textcolor{keyword}{static} \textcolor{keyword}{const} arg\_def\_t buf\_sz =
336     ARG\_DEF(NULL, \textcolor{stringliteral}{"buf-sz"}, 1, \textcolor{stringliteral}{"Client buffer size (ms)"});
337 \textcolor{keyword}{static} \textcolor{keyword}{const} arg\_def\_t buf\_initial\_sz =
338     ARG\_DEF(NULL, \textcolor{stringliteral}{"buf-initial-sz"}, 1, \textcolor{stringliteral}{"Client initial buffer size (ms)"});
339 \textcolor{keyword}{static} \textcolor{keyword}{const} arg\_def\_t buf\_optimal\_sz =
340     ARG\_DEF(NULL, \textcolor{stringliteral}{"buf-optimal-sz"}, 1, \textcolor{stringliteral}{"Client optimal buffer size (ms)"});
341 \textcolor{keyword}{static} \textcolor{keyword}{const} arg\_def\_t *rc\_args[] = \{ &dropframe\_thresh,
342                                       &resize\_mode,
343                                       &resize\_denominator,
344                                       &resize\_kf\_denominator,
345                                       &superres\_mode,
346                                       &superres\_denominator,
347                                       &superres\_kf\_denominator,
348                                       &superres\_qthresh,
349                                       &superres\_kf\_qthresh,
350                                       &end\_usage,
351                                       &target\_bitrate,
352                                       &min\_quantizer,
353                                       &max\_quantizer,
354                                       &undershoot\_pct,
355                                       &overshoot\_pct,
356                                       &buf\_sz,
357                                       &buf\_initial\_sz,
358                                       &buf\_optimal\_sz,
359                                       NULL \};
360 
361 \textcolor{keyword}{static} \textcolor{keyword}{const} arg\_def\_t bias\_pct =
362     ARG\_DEF(NULL, \textcolor{stringliteral}{"bias-pct"}, 1, \textcolor{stringliteral}{"CBR/VBR bias (0=CBR, 100=VBR)"});
363 \textcolor{keyword}{static} \textcolor{keyword}{const} arg\_def\_t minsection\_pct =
364     ARG\_DEF(NULL, \textcolor{stringliteral}{"minsection-pct"}, 1, \textcolor{stringliteral}{"GOP min bitrate (% of target)"});
365 \textcolor{keyword}{static} \textcolor{keyword}{const} arg\_def\_t maxsection\_pct =
366     ARG\_DEF(NULL, \textcolor{stringliteral}{"maxsection-pct"}, 1, \textcolor{stringliteral}{"GOP max bitrate (% of target)"});
367 \textcolor{keyword}{static} \textcolor{keyword}{const} arg\_def\_t *rc\_twopass\_args[] = \{ &bias\_pct, &minsection\_pct,
368                                               &maxsection\_pct, NULL \};
369 \textcolor{keyword}{static} \textcolor{keyword}{const} arg\_def\_t fwd\_kf\_enabled =
370     ARG\_DEF(NULL, \textcolor{stringliteral}{"enable-fwd-kf"}, 1, \textcolor{stringliteral}{"Enable forward reference keyframes"});
371 \textcolor{keyword}{static} \textcolor{keyword}{const} arg\_def\_t kf\_min\_dist =
372     ARG\_DEF(NULL, \textcolor{stringliteral}{"kf-min-dist"}, 1, \textcolor{stringliteral}{"Minimum keyframe interval (frames)"});
373 \textcolor{keyword}{static} \textcolor{keyword}{const} arg\_def\_t kf\_max\_dist =
374     ARG\_DEF(NULL, \textcolor{stringliteral}{"kf-max-dist"}, 1, \textcolor{stringliteral}{"Maximum keyframe interval (frames)"});
375 \textcolor{keyword}{static} \textcolor{keyword}{const} arg\_def\_t kf\_disabled =
376     ARG\_DEF(NULL, \textcolor{stringliteral}{"disable-kf"}, 0, \textcolor{stringliteral}{"Disable keyframe placement"});
377 \textcolor{keyword}{static} \textcolor{keyword}{const} arg\_def\_t *kf\_args[] = \{ &fwd\_kf\_enabled, &kf\_min\_dist,
378                                       &kf\_max\_dist, &kf\_disabled, NULL \};
379 \textcolor{keyword}{static} \textcolor{keyword}{const} arg\_def\_t sframe\_dist =
380     ARG\_DEF(NULL, \textcolor{stringliteral}{"sframe-dist"}, 1, \textcolor{stringliteral}{"S-Frame interval (frames)"});
381 \textcolor{keyword}{static} \textcolor{keyword}{const} arg\_def\_t sframe\_mode =
382     ARG\_DEF(NULL, \textcolor{stringliteral}{"sframe-mode"}, 1, \textcolor{stringliteral}{"S-Frame insertion mode (1..2)"});
383 \textcolor{keyword}{static} \textcolor{keyword}{const} arg\_def\_t save\_as\_annexb =
384     ARG\_DEF(NULL, \textcolor{stringliteral}{"annexb"}, 1, \textcolor{stringliteral}{"Save as Annex-B"});
385 \textcolor{keyword}{static} \textcolor{keyword}{const} arg\_def\_t noise\_sens =
386     ARG\_DEF(NULL, \textcolor{stringliteral}{"noise-sensitivity"}, 1, \textcolor{stringliteral}{"Noise sensitivity (frames to blur)"});
387 \textcolor{keyword}{static} \textcolor{keyword}{const} arg\_def\_t sharpness =
388     ARG\_DEF(NULL, \textcolor{stringliteral}{"sharpness"}, 1, \textcolor{stringliteral}{"Loop filter sharpness (0..7)"});
389 \textcolor{keyword}{static} \textcolor{keyword}{const} arg\_def\_t static\_thresh =
390     ARG\_DEF(NULL, \textcolor{stringliteral}{"static-thresh"}, 1, \textcolor{stringliteral}{"Motion detection threshold"});
391 \textcolor{keyword}{static} \textcolor{keyword}{const} arg\_def\_t auto\_altref =
392     ARG\_DEF(NULL, \textcolor{stringliteral}{"auto-alt-ref"}, 1, \textcolor{stringliteral}{"Enable automatic alt reference frames"});
393 \textcolor{keyword}{static} \textcolor{keyword}{const} arg\_def\_t arnr\_maxframes =
394     ARG\_DEF(NULL, \textcolor{stringliteral}{"arnr-maxframes"}, 1, \textcolor{stringliteral}{"AltRef max frames (0..15)"});
395 \textcolor{keyword}{static} \textcolor{keyword}{const} arg\_def\_t arnr\_strength =
396     ARG\_DEF(NULL, \textcolor{stringliteral}{"arnr-strength"}, 1, \textcolor{stringliteral}{"AltRef filter strength (0..6)"});
397 \textcolor{keyword}{static} \textcolor{keyword}{const} \textcolor{keyword}{struct }arg\_enum\_list tuning\_enum[] = \{
398   \{ \textcolor{stringliteral}{"psnr"}, AOM\_TUNE\_PSNR \},
399   \{ \textcolor{stringliteral}{"ssim"}, AOM\_TUNE\_SSIM \},
400 \textcolor{preprocessor}{#ifdef CONFIG\_DIST\_8X8}
401   \{ \textcolor{stringliteral}{"cdef-dist"}, AOM\_TUNE\_CDEF\_DIST \},
402   \{ \textcolor{stringliteral}{"daala-dist"}, AOM\_TUNE\_DAALA\_DIST \},
403 \textcolor{preprocessor}{#endif}
404   \{ NULL, 0 \}
405 \};
406 \textcolor{keyword}{static} \textcolor{keyword}{const} arg\_def\_t tune\_metric =
407     ARG\_DEF\_ENUM(NULL, \textcolor{stringliteral}{"tune"}, 1, \textcolor{stringliteral}{"Distortion metric tuned with"}, tuning\_enum);
408 \textcolor{keyword}{static} \textcolor{keyword}{const} arg\_def\_t cq\_level =
409     ARG\_DEF(NULL, \textcolor{stringliteral}{"cq-level"}, 1, \textcolor{stringliteral}{"Constant/Constrained Quality level"});
410 \textcolor{keyword}{static} \textcolor{keyword}{const} arg\_def\_t max\_intra\_rate\_pct =
411     ARG\_DEF(NULL, \textcolor{stringliteral}{"max-intra-rate"}, 1, \textcolor{stringliteral}{"Max I-frame bitrate (pct)"});
412 
413 \textcolor{preprocessor}{#if CONFIG\_AV1\_ENCODER}
414 \textcolor{keyword}{static} \textcolor{keyword}{const} arg\_def\_t cpu\_used\_av1 =
415     ARG\_DEF(NULL, \textcolor{stringliteral}{"cpu-used"}, 1, \textcolor{stringliteral}{"CPU Used (0..8)"});
416 \textcolor{keyword}{static} \textcolor{keyword}{const} arg\_def\_t rowmtarg =
417     ARG\_DEF(NULL, \textcolor{stringliteral}{"row-mt"}, 1,
418             \textcolor{stringliteral}{"Enable row based multi-threading (0: off (default), 1: on)"});
419 \textcolor{keyword}{static} \textcolor{keyword}{const} arg\_def\_t tile\_cols =
420     ARG\_DEF(NULL, \textcolor{stringliteral}{"tile-columns"}, 1, \textcolor{stringliteral}{"Number of tile columns to use, log2"});
421 \textcolor{keyword}{static} \textcolor{keyword}{const} arg\_def\_t tile\_rows =
422     ARG\_DEF(NULL, \textcolor{stringliteral}{"tile-rows"}, 1, \textcolor{stringliteral}{"Number of tile rows to use, log2"});
423 \textcolor{keyword}{static} \textcolor{keyword}{const} arg\_def\_t enable\_tpl\_model =
424     ARG\_DEF(NULL, \textcolor{stringliteral}{"enable-tpl-model"}, 1,
425             \textcolor{stringliteral}{"RDO modulation based on frame temporal dependency"});
426 \textcolor{keyword}{static} \textcolor{keyword}{const} arg\_def\_t tile\_width =
427     ARG\_DEF(NULL, \textcolor{stringliteral}{"tile-width"}, 1, \textcolor{stringliteral}{"Tile widths (comma separated)"});
428 \textcolor{keyword}{static} \textcolor{keyword}{const} arg\_def\_t tile\_height =
429     ARG\_DEF(NULL, \textcolor{stringliteral}{"tile-height"}, 1, \textcolor{stringliteral}{"Tile heights (command separated)"});
430 \textcolor{keyword}{static} \textcolor{keyword}{const} arg\_def\_t lossless =
431     ARG\_DEF(NULL, \textcolor{stringliteral}{"lossless"}, 1, \textcolor{stringliteral}{"Lossless mode (0: false (default), 1: true)"});
432 \textcolor{keyword}{static} \textcolor{keyword}{const} arg\_def\_t enable\_cdef =
433     ARG\_DEF(NULL, \textcolor{stringliteral}{"enable-cdef"}, 1,
434             \textcolor{stringliteral}{"Enable the constrained directional enhancement filter (0: false, "}
435             \textcolor{stringliteral}{"1: true (default))"});
436 \textcolor{keyword}{static} \textcolor{keyword}{const} arg\_def\_t enable\_restoration =
437     ARG\_DEF(NULL, \textcolor{stringliteral}{"enable-restoration"}, 1,
438             \textcolor{stringliteral}{"Enable the loop restoration filter (0: false, "}
439             \textcolor{stringliteral}{"1: true (default))"});
440 \textcolor{keyword}{static} \textcolor{keyword}{const} arg\_def\_t enable\_rect\_partitions =
441     ARG\_DEF(NULL, \textcolor{stringliteral}{"enable-rect-partitions"}, 1,
442             \textcolor{stringliteral}{"Enable rectangular partitions "}
443             \textcolor{stringliteral}{"(0: false, 1: true (default))"});
444 \textcolor{keyword}{static} \textcolor{keyword}{const} arg\_def\_t enable\_dual\_filter =
445     ARG\_DEF(NULL, \textcolor{stringliteral}{"enable-dual-filter"}, 1,
446             \textcolor{stringliteral}{"Enable dual filter "}
447             \textcolor{stringliteral}{"(0: false, 1: true (default))"});
448 \textcolor{keyword}{static} \textcolor{keyword}{const} arg\_def\_t enable\_intra\_edge\_filter =
449     ARG\_DEF(NULL, \textcolor{stringliteral}{"enable-intra-edge-filter"}, 1,
450             \textcolor{stringliteral}{"Enable intra edge filtering "}
451             \textcolor{stringliteral}{"(0: false, 1: true (default))"});
452 \textcolor{keyword}{static} \textcolor{keyword}{const} arg\_def\_t enable\_order\_hint =
453     ARG\_DEF(NULL, \textcolor{stringliteral}{"enable-order-hint"}, 1,
454             \textcolor{stringliteral}{"Enable order hint "}
455             \textcolor{stringliteral}{"(0: false, 1: true (default))"});
456 \textcolor{keyword}{static} \textcolor{keyword}{const} arg\_def\_t enable\_tx64 =
457     ARG\_DEF(NULL, \textcolor{stringliteral}{"enable-tx64"}, 1,
458             \textcolor{stringliteral}{"Enable 64-pt transform (0: false, 1: true (default))"});
459 \textcolor{keyword}{static} \textcolor{keyword}{const} arg\_def\_t enable\_dist\_wtd\_comp =
460     ARG\_DEF(NULL, \textcolor{stringliteral}{"enable-dist-wtd-comp"}, 1,
461             \textcolor{stringliteral}{"Enable distance-weighted compound "}
462             \textcolor{stringliteral}{"(0: false, 1: true (default))"});
463 \textcolor{keyword}{static} \textcolor{keyword}{const} arg\_def\_t enable\_masked\_comp =
464     ARG\_DEF(NULL, \textcolor{stringliteral}{"enable-masked-comp"}, 1,
465             \textcolor{stringliteral}{"Enable masked (wedge/diff-wtd) compound "}
466             \textcolor{stringliteral}{"(0: false, 1: true (default))"});
467 \textcolor{keyword}{static} \textcolor{keyword}{const} arg\_def\_t enable\_interintra\_comp =
468     ARG\_DEF(NULL, \textcolor{stringliteral}{"enable-interintra-comp"}, 1,
469             \textcolor{stringliteral}{"Enable interintra compound "}
470             \textcolor{stringliteral}{"(0: false, 1: true (default))"});
471 \textcolor{keyword}{static} \textcolor{keyword}{const} arg\_def\_t enable\_smooth\_interintra =
472     ARG\_DEF(NULL, \textcolor{stringliteral}{"enable-smooth-interintra"}, 1,
473             \textcolor{stringliteral}{"Enable smooth interintra mode "}
474             \textcolor{stringliteral}{"(0: false, 1: true (default))"});
475 \textcolor{keyword}{static} \textcolor{keyword}{const} arg\_def\_t enable\_diff\_wtd\_comp =
476     ARG\_DEF(NULL, \textcolor{stringliteral}{"enable-diff-wtd-comp"}, 1,
477             \textcolor{stringliteral}{"Enable difference-weighted compound "}
478             \textcolor{stringliteral}{"(0: false, 1: true (default))"});
479 \textcolor{keyword}{static} \textcolor{keyword}{const} arg\_def\_t enable\_interinter\_wedge =
480     ARG\_DEF(NULL, \textcolor{stringliteral}{"enable-interinter-wedge"}, 1,
481             \textcolor{stringliteral}{"Enable interinter wedge compound "}
482             \textcolor{stringliteral}{"(0: false, 1: true (default))"});
483 \textcolor{keyword}{static} \textcolor{keyword}{const} arg\_def\_t enable\_interintra\_wedge =
484     ARG\_DEF(NULL, \textcolor{stringliteral}{"enable-interintra-wedge"}, 1,
485             \textcolor{stringliteral}{"Enable interintra wedge compound "}
486             \textcolor{stringliteral}{"(0: false, 1: true (default))"});
487 \textcolor{keyword}{static} \textcolor{keyword}{const} arg\_def\_t enable\_global\_motion =
488     ARG\_DEF(NULL, \textcolor{stringliteral}{"enable-global-motion"}, 1,
489             \textcolor{stringliteral}{"Enable global motion "}
490             \textcolor{stringliteral}{"(0: false, 1: true (default))"});
491 \textcolor{keyword}{static} \textcolor{keyword}{const} arg\_def\_t enable\_warped\_motion =
492     ARG\_DEF(NULL, \textcolor{stringliteral}{"enable-warped-motion"}, 1,
493             \textcolor{stringliteral}{"Enable local warped motion "}
494             \textcolor{stringliteral}{"(0: false, 1: true (default))"});
495 \textcolor{keyword}{static} \textcolor{keyword}{const} arg\_def\_t enable\_filter\_intra =
496     ARG\_DEF(NULL, \textcolor{stringliteral}{"enable-filter-intra"}, 1,
497             \textcolor{stringliteral}{"Enable filter intra prediction mode "}
498             \textcolor{stringliteral}{"(0: false, 1: true (default))"});
499 \textcolor{keyword}{static} \textcolor{keyword}{const} arg\_def\_t enable\_smooth\_intra =
500     ARG\_DEF(NULL, \textcolor{stringliteral}{"enable-smooth-intra"}, 1,
501             \textcolor{stringliteral}{"Enable smooth intra prediction modes "}
502             \textcolor{stringliteral}{"(0: false, 1: true (default))"});
503 \textcolor{keyword}{static} \textcolor{keyword}{const} arg\_def\_t enable\_paeth\_intra =
504     ARG\_DEF(NULL, \textcolor{stringliteral}{"enable-paeth-intra"}, 1,
505             \textcolor{stringliteral}{"Enable Paeth intra prediction mode (0: false, 1: true (default))"});
506 \textcolor{keyword}{static} \textcolor{keyword}{const} arg\_def\_t enable\_cfl\_intra =
507     ARG\_DEF(NULL, \textcolor{stringliteral}{"enable-cfl-intra"}, 1,
508             \textcolor{stringliteral}{"Enable chroma from luma intra prediction mode "}
509             \textcolor{stringliteral}{"(0: false, 1: true (default))"});
510 \textcolor{keyword}{static} \textcolor{keyword}{const} arg\_def\_t enable\_obmc = ARG\_DEF(
511     NULL, \textcolor{stringliteral}{"enable-obmc"}, 1, \textcolor{stringliteral}{"Enable OBMC (0: false, 1: true (default))"});
512 \textcolor{keyword}{static} \textcolor{keyword}{const} arg\_def\_t enable\_palette =
513     ARG\_DEF(NULL, \textcolor{stringliteral}{"enable-palette"}, 1,
514             \textcolor{stringliteral}{"Enable palette prediction mode (0: false, 1: true (default))"});
515 \textcolor{keyword}{static} \textcolor{keyword}{const} arg\_def\_t enable\_intrabc =
516     ARG\_DEF(NULL, \textcolor{stringliteral}{"enable-intrabc"}, 1,
517             \textcolor{stringliteral}{"Enable intra block copy prediction mode "}
518             \textcolor{stringliteral}{"(0: false, 1: true (default))"});
519 \textcolor{keyword}{static} \textcolor{keyword}{const} arg\_def\_t enable\_angle\_delta =
520     ARG\_DEF(NULL, \textcolor{stringliteral}{"enable-angle-delta"}, 1,
521             \textcolor{stringliteral}{"Enable intra angle delta (0: false, 1: true (default))"});
522 \textcolor{keyword}{static} \textcolor{keyword}{const} arg\_def\_t disable\_trellis\_quant =
523     ARG\_DEF(NULL, \textcolor{stringliteral}{"disable-trellis-quant"}, 1,
524             \textcolor{stringliteral}{"Disable trellis optimization of quantized coefficients (0: false ("}
525             \textcolor{stringliteral}{"default) 1: true)"});
526 \textcolor{keyword}{static} \textcolor{keyword}{const} arg\_def\_t enable\_qm =
527     ARG\_DEF(NULL, \textcolor{stringliteral}{"enable-qm"}, 1,
528             \textcolor{stringliteral}{"Enable quantisation matrices (0: false (default), 1: true)"});
529 \textcolor{keyword}{static} \textcolor{keyword}{const} arg\_def\_t qm\_min = ARG\_DEF(
530     NULL, \textcolor{stringliteral}{"qm-min"}, 1, \textcolor{stringliteral}{"Min quant matrix flatness (0..15), default is 8"});
531 \textcolor{keyword}{static} \textcolor{keyword}{const} arg\_def\_t qm\_max = ARG\_DEF(
532     NULL, \textcolor{stringliteral}{"qm-max"}, 1, \textcolor{stringliteral}{"Max quant matrix flatness (0..15), default is 15"});
533 \textcolor{keyword}{static} \textcolor{keyword}{const} arg\_def\_t reduced\_tx\_type\_set = ARG\_DEF(
534     NULL, \textcolor{stringliteral}{"reduced-tx-type-set"}, 1, \textcolor{stringliteral}{"Use reduced set of transform types"});
535 \textcolor{preprocessor}{#if CONFIG\_DIST\_8X8}
536 \textcolor{keyword}{static} \textcolor{keyword}{const} arg\_def\_t enable\_dist\_8x8 =
537     ARG\_DEF(NULL, \textcolor{stringliteral}{"enable-dist-8x8"}, 1,
538             \textcolor{stringliteral}{"Enable dist-8x8 (0: false (default), 1: true)"});
539 \textcolor{preprocessor}{#endif  // CONFIG\_DIST\_8X8}
540 \textcolor{keyword}{static} \textcolor{keyword}{const} arg\_def\_t num\_tg = ARG\_DEF(
541     NULL, \textcolor{stringliteral}{"num-tile-groups"}, 1, \textcolor{stringliteral}{"Maximum number of tile groups, default is 1"});
542 \textcolor{keyword}{static} \textcolor{keyword}{const} arg\_def\_t mtu\_size =
543     ARG\_DEF(NULL, \textcolor{stringliteral}{"mtu-size"}, 1,
544             \textcolor{stringliteral}{"MTU size for a tile group, default is 0 (no MTU targeting), "}
545             \textcolor{stringliteral}{"overrides maximum number of tile groups"});
546 \textcolor{keyword}{static} \textcolor{keyword}{const} \textcolor{keyword}{struct }arg\_enum\_list timing\_info\_enum[] = \{
547   \{ \textcolor{stringliteral}{"unspecified"}, AOM\_TIMING\_UNSPECIFIED \},
548   \{ \textcolor{stringliteral}{"constant"}, AOM\_TIMING\_EQUAL \},
549   \{ \textcolor{stringliteral}{"model"}, AOM\_TIMING\_DEC\_MODEL \},
550   \{ NULL, 0 \}
551 \};
552 \textcolor{keyword}{static} \textcolor{keyword}{const} arg\_def\_t timing\_info =
553     ARG\_DEF\_ENUM(NULL, \textcolor{stringliteral}{"timing-info"}, 1,
554                  \textcolor{stringliteral}{"Signal timing info in the bitstream (model unly works for no "}
555                  \textcolor{stringliteral}{"hidden frames, no super-res yet):"},
556                  timing\_info\_enum);
557 \textcolor{keyword}{static} \textcolor{keyword}{const} arg\_def\_t film\_grain\_test =
558     ARG\_DEF(NULL, \textcolor{stringliteral}{"film-grain-test"}, 1,
559             \textcolor{stringliteral}{"Film grain test vectors (0: none (default), 1: test-1  2: test-2, "}
560             \textcolor{stringliteral}{"... 16: test-16)"});
561 \textcolor{keyword}{static} \textcolor{keyword}{const} arg\_def\_t film\_grain\_table =
562     ARG\_DEF(NULL, \textcolor{stringliteral}{"film-grain-table"}, 1,
563             \textcolor{stringliteral}{"Path to file containing film grain parameters"});
564 \textcolor{preprocessor}{#if CONFIG\_DENOISE}
565 \textcolor{keyword}{static} \textcolor{keyword}{const} arg\_def\_t denoise\_noise\_level =
566     ARG\_DEF(NULL, \textcolor{stringliteral}{"denoise-noise-level"}, 1,
567             \textcolor{stringliteral}{"Amount of noise (from 0 = don't denoise, to 50)"});
568 \textcolor{keyword}{static} \textcolor{keyword}{const} arg\_def\_t denoise\_block\_size =
569     ARG\_DEF(NULL, \textcolor{stringliteral}{"denoise-block-size"}, 1, \textcolor{stringliteral}{"Denoise block size (default = 32)"});
570 \textcolor{preprocessor}{#endif}
571 \textcolor{keyword}{static} \textcolor{keyword}{const} arg\_def\_t enable\_ref\_frame\_mvs =
572     ARG\_DEF(NULL, \textcolor{stringliteral}{"enable-ref-frame-mvs"}, 1,
573             \textcolor{stringliteral}{"Enable temporal mv prediction (default is 1)"});
574 \textcolor{keyword}{static} \textcolor{keyword}{const} arg\_def\_t frame\_parallel\_decoding =
575     ARG\_DEF(NULL, \textcolor{stringliteral}{"frame-parallel"}, 1,
576             \textcolor{stringliteral}{"Enable frame parallel decodability features "}
577             \textcolor{stringliteral}{"(0: false (default), 1: true)"});
578 \textcolor{keyword}{static} \textcolor{keyword}{const} arg\_def\_t error\_resilient\_mode =
579     ARG\_DEF(NULL, \textcolor{stringliteral}{"error-resilient"}, 1,
580             \textcolor{stringliteral}{"Enable error resilient features "}
581             \textcolor{stringliteral}{"(0: false (default), 1: true)"});
582 \textcolor{keyword}{static} \textcolor{keyword}{const} arg\_def\_t aq\_mode = ARG\_DEF(
583     NULL, \textcolor{stringliteral}{"aq-mode"}, 1,
584     \textcolor{stringliteral}{"Adaptive quantization mode (0: off (default), 1: variance 2: complexity, "}
585     \textcolor{stringliteral}{"3: cyclic refresh)"});
586 \textcolor{keyword}{static} \textcolor{keyword}{const} arg\_def\_t deltaq\_mode = ARG\_DEF(
587     NULL, \textcolor{stringliteral}{"deltaq-mode"}, 1,
588     \textcolor{stringliteral}{"Delta qindex mode (0: off (default), 1: deltaq 2: deltaq + deltalf)"});
589 \textcolor{keyword}{static} \textcolor{keyword}{const} arg\_def\_t frame\_periodic\_boost =
590     ARG\_DEF(NULL, \textcolor{stringliteral}{"frame-boost"}, 1,
591             \textcolor{stringliteral}{"Enable frame periodic boost (0: off (default), 1: on)"});
592 \textcolor{keyword}{static} \textcolor{keyword}{const} arg\_def\_t gf\_cbr\_boost\_pct = ARG\_DEF(
593     NULL, \textcolor{stringliteral}{"gf-cbr-boost"}, 1, \textcolor{stringliteral}{"Boost for Golden Frame in CBR mode (pct)"});
594 \textcolor{keyword}{static} \textcolor{keyword}{const} arg\_def\_t max\_inter\_rate\_pct =
595     ARG\_DEF(NULL, \textcolor{stringliteral}{"max-inter-rate"}, 1, \textcolor{stringliteral}{"Max P-frame bitrate (pct)"});
596 \textcolor{keyword}{static} \textcolor{keyword}{const} arg\_def\_t min\_gf\_interval = ARG\_DEF(
597     NULL, \textcolor{stringliteral}{"min-gf-interval"}, 1,
598     \textcolor{stringliteral}{"min gf/arf frame interval (default 0, indicating in-built behavior)"});
599 \textcolor{keyword}{static} \textcolor{keyword}{const} arg\_def\_t max\_gf\_interval = ARG\_DEF(
600     NULL, \textcolor{stringliteral}{"max-gf-interval"}, 1,
601     \textcolor{stringliteral}{"max gf/arf frame interval (default 0, indicating in-built behavior)"});
602 \textcolor{keyword}{static} \textcolor{keyword}{const} arg\_def\_t gf\_max\_pyr\_height =
603     ARG\_DEF(NULL, \textcolor{stringliteral}{"gf-max-pyr-height"}, 1,
604             \textcolor{stringliteral}{"maximum height for GF group pyramid structure (1 to 4 (default))"});
605 
606 \textcolor{keyword}{static} \textcolor{keyword}{const} \textcolor{keyword}{struct }arg\_enum\_list color\_primaries\_enum[] = \{
607   \{ \textcolor{stringliteral}{"bt709"}, \hyperlink{aom__image_8h_a5267ad095a088ece3499336812503cefa9a2ebe055c0508a2a2f72b6c192fcce9}{AOM\_CICP\_CP\_BT\_709} \},
608   \{ \textcolor{stringliteral}{"unspecified"}, \hyperlink{aom__image_8h_a5267ad095a088ece3499336812503cefa0835a3af8e6ffc6df298b6e64f878431}{AOM\_CICP\_CP\_UNSPECIFIED} \},
609   \{ \textcolor{stringliteral}{"bt601"}, \hyperlink{aom__image_8h_a5267ad095a088ece3499336812503cefa3ce81eb125550ec2f11a58f183eeaee6}{AOM\_CICP\_CP\_BT\_601} \},
610   \{ \textcolor{stringliteral}{"bt470m"}, \hyperlink{aom__image_8h_a5267ad095a088ece3499336812503cefa5b57cb26f04f4df6585335129392d5e2}{AOM\_CICP\_CP\_BT\_470\_M} \},
611   \{ \textcolor{stringliteral}{"bt470bg"}, \hyperlink{aom__image_8h_a5267ad095a088ece3499336812503cefa8b33dc8483c16048c606d75d9f11e38a}{AOM\_CICP\_CP\_BT\_470\_B\_G} \},
612   \{ \textcolor{stringliteral}{"smpte240"}, \hyperlink{aom__image_8h_a5267ad095a088ece3499336812503cefa1a8b2e5694489121f80a406d9da25dfb}{AOM\_CICP\_CP\_SMPTE\_240} \},
613   \{ \textcolor{stringliteral}{"film"}, \hyperlink{aom__image_8h_a5267ad095a088ece3499336812503cefa8dd6ba5106c22d149a233e73232aeb65}{AOM\_CICP\_CP\_GENERIC\_FILM} \},
614   \{ \textcolor{stringliteral}{"bt2020"}, \hyperlink{aom__image_8h_a5267ad095a088ece3499336812503cefa6bb95baf09cd6e1f3596b459712c592a}{AOM\_CICP\_CP\_BT\_2020} \},
615   \{ \textcolor{stringliteral}{"xyz"}, \hyperlink{aom__image_8h_a5267ad095a088ece3499336812503cefa6032cae72a729933a6a75e3b943a542c}{AOM\_CICP\_CP\_XYZ} \},
616   \{ \textcolor{stringliteral}{"smpte431"}, \hyperlink{aom__image_8h_a5267ad095a088ece3499336812503cefa54d519c9ac0ca52ebda7caf736530e57}{AOM\_CICP\_CP\_SMPTE\_431} \},
617   \{ \textcolor{stringliteral}{"smpte432"}, \hyperlink{aom__image_8h_a5267ad095a088ece3499336812503cefa227b6e4116ed0266af20b705aebaf661}{AOM\_CICP\_CP\_SMPTE\_432} \},
618   \{ \textcolor{stringliteral}{"ebu3213"}, \hyperlink{aom__image_8h_a5267ad095a088ece3499336812503cefa9e74dcb338953bfab3101aa33ea44157}{AOM\_CICP\_CP\_EBU\_3213} \},
619   \{ NULL, 0 \}
620 \};
621 
622 \textcolor{keyword}{static} \textcolor{keyword}{const} arg\_def\_t input\_color\_primaries = ARG\_DEF\_ENUM(
623     NULL, \textcolor{stringliteral}{"color-primaries"}, 1,
624     \textcolor{stringliteral}{"Color primaries (CICP) of input content:"}, color\_primaries\_enum);
625 
626 \textcolor{keyword}{static} \textcolor{keyword}{const} \textcolor{keyword}{struct }arg\_enum\_list transfer\_characteristics\_enum[] = \{
627   \{ \textcolor{stringliteral}{"unspecified"}, \hyperlink{aom__image_8h_a5267ad095a088ece3499336812503cefa0835a3af8e6ffc6df298b6e64f878431}{AOM\_CICP\_CP\_UNSPECIFIED} \},
628   \{ \textcolor{stringliteral}{"bt709"}, \hyperlink{aom__image_8h_a30655997e3fb79889ee23eb294cb1992affe340e422646b7d70ef91edd6a8053c}{AOM\_CICP\_TC\_BT\_709} \},
629   \{ \textcolor{stringliteral}{"bt470m"}, \hyperlink{aom__image_8h_a30655997e3fb79889ee23eb294cb1992a356d6943d11d88e7a42370c1c698c214}{AOM\_CICP\_TC\_BT\_470\_M} \},
630   \{ \textcolor{stringliteral}{"bt470bg"}, \hyperlink{aom__image_8h_a30655997e3fb79889ee23eb294cb1992a7a347c6d5605db0a6ee89cc81dec0b37}{AOM\_CICP\_TC\_BT\_470\_B\_G} \},
631   \{ \textcolor{stringliteral}{"bt601"}, \hyperlink{aom__image_8h_a30655997e3fb79889ee23eb294cb1992a5b51bfcf0f3779a7d907ac45ee4067a4}{AOM\_CICP\_TC\_BT\_601} \},
632   \{ \textcolor{stringliteral}{"smpte240"}, \hyperlink{aom__image_8h_a30655997e3fb79889ee23eb294cb1992ac3b5e95e3400830c334268fca69a1226}{AOM\_CICP\_TC\_SMPTE\_240} \},
633   \{ \textcolor{stringliteral}{"lin"}, \hyperlink{aom__image_8h_a30655997e3fb79889ee23eb294cb1992a99ebdb0b1a35e0bf25808f851aa80a35}{AOM\_CICP\_TC\_LINEAR} \},
634   \{ \textcolor{stringliteral}{"log100"}, \hyperlink{aom__image_8h_a30655997e3fb79889ee23eb294cb1992a54ec8cfad46215d855696bafe371ffe1}{AOM\_CICP\_TC\_LOG\_100} \},
635   \{ \textcolor{stringliteral}{"log100sq10"}, \hyperlink{aom__image_8h_a30655997e3fb79889ee23eb294cb1992a7d79c257042a5958bafa6b5ccfbd96cb}{AOM\_CICP\_TC\_LOG\_100\_SQRT10} \},
636   \{ \textcolor{stringliteral}{"iec61966"}, \hyperlink{aom__image_8h_a30655997e3fb79889ee23eb294cb1992a57f92f410badf8a43b19df18edc9b8b9}{AOM\_CICP\_TC\_IEC\_61966} \},
637   \{ \textcolor{stringliteral}{"bt1361"}, \hyperlink{aom__image_8h_a30655997e3fb79889ee23eb294cb1992ac60ca749a2d0ca1c860d82f0825a3e2d}{AOM\_CICP\_TC\_BT\_1361} \},
638   \{ \textcolor{stringliteral}{"srgb"}, \hyperlink{aom__image_8h_a30655997e3fb79889ee23eb294cb1992a94553e773e3d3fb005236ed70eeedfea}{AOM\_CICP\_TC\_SRGB} \},
639   \{ \textcolor{stringliteral}{"bt2020-10bit"}, \hyperlink{aom__image_8h_a30655997e3fb79889ee23eb294cb1992a1ce5fbca5277266680d70bb7211646d6}{AOM\_CICP\_TC\_BT\_2020\_10\_BIT} \},
640   \{ \textcolor{stringliteral}{"bt2020-12bit"}, \hyperlink{aom__image_8h_a30655997e3fb79889ee23eb294cb1992afcc74c6858aefc13c426dd6992198e75}{AOM\_CICP\_TC\_BT\_2020\_12\_BIT} \},
641   \{ \textcolor{stringliteral}{"smpte2084"}, \hyperlink{aom__image_8h_a30655997e3fb79889ee23eb294cb1992ab48fdcc8c2c0350f6423b9c116c1876d}{AOM\_CICP\_TC\_SMPTE\_2084} \},
642   \{ \textcolor{stringliteral}{"hlg"}, \hyperlink{aom__image_8h_a30655997e3fb79889ee23eb294cb1992a3d7b83c425c539d1a36fb36e9aebf268}{AOM\_CICP\_TC\_HLG} \},
643   \{ \textcolor{stringliteral}{"smpte428"}, \hyperlink{aom__image_8h_a30655997e3fb79889ee23eb294cb1992a45df590313483af0c614708f346028c4}{AOM\_CICP\_TC\_SMPTE\_428} \},
644   \{ NULL, 0 \}
645 \};
646 
647 \textcolor{keyword}{static} \textcolor{keyword}{const} arg\_def\_t input\_transfer\_characteristics =
648     ARG\_DEF\_ENUM(NULL, \textcolor{stringliteral}{"transfer-characteristics"}, 1,
649                  \textcolor{stringliteral}{"Transfer characteristics (CICP) of input content:"},
650                  transfer\_characteristics\_enum);
651 
652 \textcolor{keyword}{static} \textcolor{keyword}{const} \textcolor{keyword}{struct }arg\_enum\_list matrix\_coefficients\_enum[] = \{
653   \{ \textcolor{stringliteral}{"identity"}, \hyperlink{aom__image_8h_a6bc018ed9689367acae810bc58527081a17489bf0aed544427f7c6bbe4837b212}{AOM\_CICP\_MC\_IDENTITY} \},
654   \{ \textcolor{stringliteral}{"bt709"}, \hyperlink{aom__image_8h_a6bc018ed9689367acae810bc58527081aa70fd9b88bc91bd0d126aaa07421c49a}{AOM\_CICP\_MC\_BT\_709} \},
655   \{ \textcolor{stringliteral}{"unspecified"}, \hyperlink{aom__image_8h_a6bc018ed9689367acae810bc58527081a06a4defb1e5d9bb1d2aad092b8656a03}{AOM\_CICP\_MC\_UNSPECIFIED} \},
656   \{ \textcolor{stringliteral}{"fcc73"}, \hyperlink{aom__image_8h_a6bc018ed9689367acae810bc58527081ae368663c2c2f34683b513e159c5738b9}{AOM\_CICP\_MC\_FCC} \},
657   \{ \textcolor{stringliteral}{"bt470bg"}, \hyperlink{aom__image_8h_a6bc018ed9689367acae810bc58527081ae9107262b437659514abdcd928e977db}{AOM\_CICP\_MC\_BT\_470\_B\_G} \},
658   \{ \textcolor{stringliteral}{"bt601"}, \hyperlink{aom__image_8h_a6bc018ed9689367acae810bc58527081a0f81310501079cc1184d5265ae2c18a5}{AOM\_CICP\_MC\_BT\_601} \},
659   \{ \textcolor{stringliteral}{"smpte240"}, \hyperlink{aom__image_8h_a5267ad095a088ece3499336812503cefa1a8b2e5694489121f80a406d9da25dfb}{AOM\_CICP\_CP\_SMPTE\_240} \},
660   \{ \textcolor{stringliteral}{"ycgco"}, \hyperlink{aom__image_8h_a6bc018ed9689367acae810bc58527081aa2140164b26b42404c376cc921ce27c5}{AOM\_CICP\_MC\_SMPTE\_YCGCO} \},
661   \{ \textcolor{stringliteral}{"bt2020ncl"}, \hyperlink{aom__image_8h_a6bc018ed9689367acae810bc58527081adf60aa79c6a68f4eb41e1095f8bf7bf6}{AOM\_CICP\_MC\_BT\_2020\_NCL} \},
662   \{ \textcolor{stringliteral}{"bt2020cl"}, \hyperlink{aom__image_8h_a6bc018ed9689367acae810bc58527081a34148eae7b467eece6af5c90405dde6b}{AOM\_CICP\_MC\_BT\_2020\_CL} \},
663   \{ \textcolor{stringliteral}{"smpte2085"}, \hyperlink{aom__image_8h_a6bc018ed9689367acae810bc58527081a3aeb0ed0afc0a92ce758f109cd05ee80}{AOM\_CICP\_MC\_SMPTE\_2085} \},
664   \{ \textcolor{stringliteral}{"chromncl"}, \hyperlink{aom__image_8h_a6bc018ed9689367acae810bc58527081a30661e9d9b70ffe9f51f3bdbfd02865b}{AOM\_CICP\_MC\_CHROMAT\_NCL} \},
665   \{ \textcolor{stringliteral}{"chromcl"}, \hyperlink{aom__image_8h_a6bc018ed9689367acae810bc58527081aa391f9255e4775da0120f7472b417193}{AOM\_CICP\_MC\_CHROMAT\_CL} \},
666   \{ \textcolor{stringliteral}{"ictcp"}, \hyperlink{aom__image_8h_a6bc018ed9689367acae810bc58527081a7695b0577d3884a89c578f28f4237aee}{AOM\_CICP\_MC\_ICTCP} \},
667   \{ NULL, 0 \}
668 \};
669 
670 \textcolor{keyword}{static} \textcolor{keyword}{const} arg\_def\_t input\_matrix\_coefficients = ARG\_DEF\_ENUM(
671     NULL, \textcolor{stringliteral}{"matrix-coefficients"}, 1,
672     \textcolor{stringliteral}{"Matrix coefficients (CICP) of input content:"}, matrix\_coefficients\_enum);
673 
674 \textcolor{keyword}{static} \textcolor{keyword}{const} \textcolor{keyword}{struct }arg\_enum\_list chroma\_sample\_position\_enum[] = \{
675   \{ \textcolor{stringliteral}{"unknown"}, \hyperlink{aom__image_8h_a10590253ef3dbde7e93ed5d4b4e0e73ba7843506f3e28f720be0d4f03237fb48c}{AOM\_CSP\_UNKNOWN} \},
676   \{ \textcolor{stringliteral}{"vertical"}, \hyperlink{aom__image_8h_a10590253ef3dbde7e93ed5d4b4e0e73baf95ced9b8288642205301cc51e0b55c6}{AOM\_CSP\_VERTICAL} \},
677   \{ \textcolor{stringliteral}{"colocated"}, \hyperlink{aom__image_8h_a10590253ef3dbde7e93ed5d4b4e0e73ba01ef7204c2234ef43acfd493d5e18c84}{AOM\_CSP\_COLOCATED} \},
678   \{ NULL, 0 \}
679 \};
680 
681 \textcolor{keyword}{static} \textcolor{keyword}{const} arg\_def\_t input\_chroma\_sample\_position =
682     ARG\_DEF\_ENUM(NULL, \textcolor{stringliteral}{"chroma-sample-position"}, 1,
683                  \textcolor{stringliteral}{"The chroma sample position when chroma 4:2:0 is signaled:"},
684                  chroma\_sample\_position\_enum);
685 
686 \textcolor{keyword}{static} \textcolor{keyword}{const} \textcolor{keyword}{struct }arg\_enum\_list tune\_content\_enum[] = \{
687   \{ \textcolor{stringliteral}{"default"}, AOM\_CONTENT\_DEFAULT \},
688   \{ \textcolor{stringliteral}{"screen"}, AOM\_CONTENT\_SCREEN \},
689   \{ NULL, 0 \}
690 \};
691 
692 \textcolor{keyword}{static} \textcolor{keyword}{const} arg\_def\_t tune\_content = ARG\_DEF\_ENUM(
693     NULL, \textcolor{stringliteral}{"tune-content"}, 1, \textcolor{stringliteral}{"Tune content type"}, tune\_content\_enum);
694 
695 \textcolor{keyword}{static} \textcolor{keyword}{const} arg\_def\_t cdf\_update\_mode =
696     ARG\_DEF(NULL, \textcolor{stringliteral}{"cdf-update-mode"}, 1,
697             \textcolor{stringliteral}{"CDF update mode for entropy coding "}
698             \textcolor{stringliteral}{"(0: no CDF update; 1: update CDF on all frames(default); "}
699             \textcolor{stringliteral}{"2: selectively update CDF on some frames"});
700 
701 \textcolor{keyword}{static} \textcolor{keyword}{const} \textcolor{keyword}{struct }arg\_enum\_list superblock\_size\_enum[] = \{
702   \{ \textcolor{stringliteral}{"dynamic"}, \hyperlink{group__codec_ggac34a24f7c6c0fef7518aed0da4425f61aaabb4d9ad771b2fa177ff6fb5437b179}{AOM\_SUPERBLOCK\_SIZE\_DYNAMIC} \},
703   \{ \textcolor{stringliteral}{"64"}, \hyperlink{group__codec_ggac34a24f7c6c0fef7518aed0da4425f61a5abd24080a18d4f7e33217d93a73e968}{AOM\_SUPERBLOCK\_SIZE\_64X64} \},
704   \{ \textcolor{stringliteral}{"128"}, \hyperlink{group__codec_ggac34a24f7c6c0fef7518aed0da4425f61a17127133dafcd42b1d792770981d67d0}{AOM\_SUPERBLOCK\_SIZE\_128X128} \},
705   \{ NULL, 0 \}
706 \};
707 \textcolor{keyword}{static} \textcolor{keyword}{const} arg\_def\_t superblock\_size = ARG\_DEF\_ENUM(
708     NULL, \textcolor{stringliteral}{"sb-size"}, 1, \textcolor{stringliteral}{"Superblock size to use"}, superblock\_size\_enum);
709 
710 \textcolor{keyword}{static} \textcolor{keyword}{const} arg\_def\_t *av1\_args[] = \{ &cpu\_used\_av1,
711                                        &auto\_altref,
712                                        &sharpness,
713                                        &static\_thresh,
714                                        &rowmtarg,
715                                        &tile\_cols,
716                                        &tile\_rows,
717                                        &enable\_tpl\_model,
718                                        &arnr\_maxframes,
719                                        &arnr\_strength,
720                                        &tune\_metric,
721                                        &cq\_level,
722                                        &max\_intra\_rate\_pct,
723                                        &max\_inter\_rate\_pct,
724                                        &gf\_cbr\_boost\_pct,
725                                        &lossless,
726                                        &enable\_cdef,
727                                        &enable\_restoration,
728                                        &enable\_rect\_partitions,
729                                        &enable\_dual\_filter,
730                                        &enable\_intra\_edge\_filter,
731                                        &enable\_order\_hint,
732                                        &enable\_tx64,
733                                        &enable\_dist\_wtd\_comp,
734                                        &enable\_masked\_comp,
735                                        &enable\_interintra\_comp,
736                                        &enable\_smooth\_interintra,
737                                        &enable\_diff\_wtd\_comp,
738                                        &enable\_interinter\_wedge,
739                                        &enable\_interintra\_wedge,
740                                        &enable\_global\_motion,
741                                        &enable\_warped\_motion,
742                                        &enable\_filter\_intra,
743                                        &enable\_smooth\_intra,
744                                        &enable\_paeth\_intra,
745                                        &enable\_cfl\_intra,
746                                        &enable\_obmc,
747                                        &enable\_palette,
748                                        &enable\_intrabc,
749                                        &enable\_angle\_delta,
750                                        &disable\_trellis\_quant,
751                                        &enable\_qm,
752                                        &qm\_min,
753                                        &qm\_max,
754                                        &reduced\_tx\_type\_set,
755 \textcolor{preprocessor}{#if CONFIG\_DIST\_8X8}
756                                        &enable\_dist\_8x8,
757 \textcolor{preprocessor}{#endif}
758                                        &frame\_parallel\_decoding,
759                                        &error\_resilient\_mode,
760                                        &aq\_mode,
761                                        &deltaq\_mode,
762                                        &frame\_periodic\_boost,
763                                        &noise\_sens,
764                                        &tune\_content,
765                                        &cdf\_update\_mode,
766                                        &input\_color\_primaries,
767                                        &input\_transfer\_characteristics,
768                                        &input\_matrix\_coefficients,
769                                        &input\_chroma\_sample\_position,
770                                        &min\_gf\_interval,
771                                        &max\_gf\_interval,
772                                        &gf\_max\_pyr\_height,
773                                        &superblock\_size,
774                                        &num\_tg,
775                                        &mtu\_size,
776                                        &timing\_info,
777                                        &film\_grain\_test,
778                                        &film\_grain\_table,
779 \textcolor{preprocessor}{#if CONFIG\_DENOISE}
780                                        &denoise\_noise\_level,
781                                        &denoise\_block\_size,
782 \textcolor{preprocessor}{#endif}
783                                        &enable\_ref\_frame\_mvs,
784                                        &bitdeptharg,
785                                        &inbitdeptharg,
786                                        &input\_chroma\_subsampling\_x,
787                                        &input\_chroma\_subsampling\_y,
788                                        &sframe\_dist,
789                                        &sframe\_mode,
790                                        &save\_as\_annexb,
791                                        NULL \};
792 \textcolor{keyword}{static} \textcolor{keyword}{const} \textcolor{keywordtype}{int} av1\_arg\_ctrl\_map[] = \{ \hyperlink{group__aom__encoder_ggae78dde67a6d78f332e9bdba0dde42db5adac09e1a8da079b08fca5ccbf981f1a6}{AOME\_SET\_CPUUSED},
793                                         \hyperlink{group__aom__encoder_ggae78dde67a6d78f332e9bdba0dde42db5ac8a24393f214823f5a6bd345afb840b6}{AOME\_SET\_ENABLEAUTOALTREF},
794                                         \hyperlink{group__aom__encoder_ggae78dde67a6d78f332e9bdba0dde42db5a0df0d30e82bb9683f3131138dfa2949a}{AOME\_SET\_SHARPNESS},
795                                         \hyperlink{group__aom__encoder_ggae78dde67a6d78f332e9bdba0dde42db5aa4f58f6a86b710e403daeac055738111}{AOME\_SET\_STATIC\_THRESHOLD},
796                                         \hyperlink{group__aom__encoder_ggae78dde67a6d78f332e9bdba0dde42db5a095d0817d339940aa2578924a840fc84}{AV1E\_SET\_ROW\_MT},
797                                         \hyperlink{group__aom__encoder_ggae78dde67a6d78f332e9bdba0dde42db5acf4ab1ff2fa8d76a78881ad7f1a1294d}{AV1E\_SET\_TILE\_COLUMNS},
798                                         \hyperlink{group__aom__encoder_ggae78dde67a6d78f332e9bdba0dde42db5a57f2f2a54f593b398a5e97db7982f817}{AV1E\_SET\_TILE\_ROWS},
799                                         \hyperlink{group__aom__encoder_ggae78dde67a6d78f332e9bdba0dde42db5a174ffbc2e91a020a8225900e38894137}{AV1E\_SET\_ENABLE\_TPL\_MODEL},
800                                         \hyperlink{group__aom__encoder_ggae78dde67a6d78f332e9bdba0dde42db5a327fb270f37bbb008b0f146542ce7483}{AOME\_SET\_ARNR\_MAXFRAMES},
801                                         \hyperlink{group__aom__encoder_ggae78dde67a6d78f332e9bdba0dde42db5affd2c213f24a12d13bb51e31be993e60}{AOME\_SET\_ARNR\_STRENGTH},
802                                         \hyperlink{group__aom__encoder_ggae78dde67a6d78f332e9bdba0dde42db5aba539b6646278e7ff40f67f38639d294}{AOME\_SET\_TUNING},
803                                         \hyperlink{group__aom__encoder_ggae78dde67a6d78f332e9bdba0dde42db5af67f265bf63bf8f1268b3a14ae26606c}{AOME\_SET\_CQ\_LEVEL},
804                                         \hyperlink{group__aom__encoder_ggae78dde67a6d78f332e9bdba0dde42db5a9e1965ffa40d2d87556b65748c63adcc}{AOME\_SET\_MAX\_INTRA\_BITRATE\_PCT},
805                                         \hyperlink{group__aom__encoder_ggae78dde67a6d78f332e9bdba0dde42db5a54b7c950e51f39a3cb7344a2665b9929}{AV1E\_SET\_MAX\_INTER\_BITRATE\_PCT},
806                                         \hyperlink{group__aom__encoder_ggae78dde67a6d78f332e9bdba0dde42db5ade327180f01d27d22abd94c1f0a8bc9e}{AV1E\_SET\_GF\_CBR\_BOOST\_PCT},
807                                         \hyperlink{group__aom__encoder_ggae78dde67a6d78f332e9bdba0dde42db5afe875c6bb02f236be503c8c7b1f15875}{AV1E\_SET\_LOSSLESS},
808                                         \hyperlink{group__aom__encoder_ggae78dde67a6d78f332e9bdba0dde42db5a6879fe104e23de00f034ed11eb605031}{AV1E\_SET\_ENABLE\_CDEF},
809                                         \hyperlink{group__aom__encoder_ggae78dde67a6d78f332e9bdba0dde42db5a2ea70b4b379e701a4b3b7cc33eb05e65}{AV1E\_SET\_ENABLE\_RESTORATION},
810                                         \hyperlink{group__aom__encoder_ggae78dde67a6d78f332e9bdba0dde42db5af3db44e9871c69defc5ae2cc6c5e3ba0}{AV1E\_SET\_ENABLE\_RECT\_PARTITIONS},
811                                         \hyperlink{group__aom__encoder_ggae78dde67a6d78f332e9bdba0dde42db5a45867a101866f7ad1a67e7d72f84054a}{AV1E\_SET\_ENABLE\_DUAL\_FILTER},
812                                         \hyperlink{group__aom__encoder_ggae78dde67a6d78f332e9bdba0dde42db5a518cc32bbf169f8e9d4d71e7c1193748}{AV1E\_SET\_ENABLE\_INTRA\_EDGE\_FILTER},
813                                         \hyperlink{group__aom__encoder_ggae78dde67a6d78f332e9bdba0dde42db5ad0eaf349d653c8357acbba84ad95d5e6}{AV1E\_SET\_ENABLE\_ORDER\_HINT},
814                                         \hyperlink{group__aom__encoder_ggae78dde67a6d78f332e9bdba0dde42db5ab6d4110cee235e35452d0beb89a28604}{AV1E\_SET\_ENABLE\_TX64},
815                                         \hyperlink{group__aom__encoder_ggae78dde67a6d78f332e9bdba0dde42db5a80d59744d531d9e0d48c8274792b69dc}{AV1E\_SET\_ENABLE\_DIST\_WTD\_COMP},
816                                         \hyperlink{group__aom__encoder_ggae78dde67a6d78f332e9bdba0dde42db5a643067b985c437490d6248decad39235}{AV1E\_SET\_ENABLE\_MASKED\_COMP},
817                                         \hyperlink{group__aom__encoder_ggae78dde67a6d78f332e9bdba0dde42db5a4032b6c7ad5f4499af95ddaab863d3d6}{AV1E\_SET\_ENABLE\_INTERINTRA\_COMP},
818                                         \hyperlink{group__aom__encoder_ggae78dde67a6d78f332e9bdba0dde42db5aa15748a927789e02f586d2408eaa78fe}{AV1E\_SET\_ENABLE\_SMOOTH\_INTERINTRA},
819                                         \hyperlink{group__aom__encoder_ggae78dde67a6d78f332e9bdba0dde42db5a951b38c88fb632d63568da3cce275ecd}{AV1E\_SET\_ENABLE\_DIFF\_WTD\_COMP},
820                                         \hyperlink{group__aom__encoder_ggae78dde67a6d78f332e9bdba0dde42db5a013aa12c1a51471d2f2f401d6abcb40d}{AV1E\_SET\_ENABLE\_INTERINTER\_WEDGE},
821                                         \hyperlink{group__aom__encoder_ggae78dde67a6d78f332e9bdba0dde42db5a8b3e315575be2741071813f5a3830b79}{AV1E\_SET\_ENABLE\_INTERINTRA\_WEDGE},
822                                         \hyperlink{group__aom__encoder_ggae78dde67a6d78f332e9bdba0dde42db5ad4da3bb77e25bac4a0afc2135617cbd9}{AV1E\_SET\_ENABLE\_GLOBAL\_MOTION},
823                                         \hyperlink{group__aom__encoder_ggae78dde67a6d78f332e9bdba0dde42db5a4c4ae7f4158f795667b16c99fcdc5dd3}{AV1E\_SET\_ENABLE\_WARPED\_MOTION},
824                                         \hyperlink{group__aom__encoder_ggae78dde67a6d78f332e9bdba0dde42db5a9774262de47ffd2bb7d674bb55951a7e}{AV1E\_SET\_ENABLE\_FILTER\_INTRA},
825                                         \hyperlink{group__aom__encoder_ggae78dde67a6d78f332e9bdba0dde42db5a0a1d54150968c5c20b410bc29dc0caa4}{AV1E\_SET\_ENABLE\_SMOOTH\_INTRA},
826                                         \hyperlink{group__aom__encoder_ggae78dde67a6d78f332e9bdba0dde42db5a25f7c646aaec0702964c1fb1bf16e298}{AV1E\_SET\_ENABLE\_PAETH\_INTRA},
827                                         \hyperlink{group__aom__encoder_ggae78dde67a6d78f332e9bdba0dde42db5a993e0e437aa0d152fe654ba0ab46f9d2}{AV1E\_SET\_ENABLE\_CFL\_INTRA},
828                                         \hyperlink{group__aom__encoder_ggae78dde67a6d78f332e9bdba0dde42db5aa51bc0690a7d51765a01afa015ec2077}{AV1E\_SET\_ENABLE\_OBMC},
829                                         \hyperlink{group__aom__encoder_ggae78dde67a6d78f332e9bdba0dde42db5a98d0e84130317b6c072c2deac106dede}{AV1E\_SET\_ENABLE\_PALETTE},
830                                         \hyperlink{group__aom__encoder_ggae78dde67a6d78f332e9bdba0dde42db5a3e59c51f12c7350fee92c1c0d4901ab0}{AV1E\_SET\_ENABLE\_INTRABC},
831                                         \hyperlink{group__aom__encoder_ggae78dde67a6d78f332e9bdba0dde42db5a3155057080db493c868eb2d42d435b61}{AV1E\_SET\_ENABLE\_ANGLE\_DELTA},
832                                         \hyperlink{group__aom__encoder_ggae78dde67a6d78f332e9bdba0dde42db5a374b5581d0b68d5f8cc3e3f73495cfbb}{AV1E\_SET\_DISABLE\_TRELLIS\_QUANT},
833                                         \hyperlink{group__aom__encoder_ggae78dde67a6d78f332e9bdba0dde42db5ae63993934cdc5aa36efeec4df87a577e}{AV1E\_SET\_ENABLE\_QM},
834                                         \hyperlink{group__aom__encoder_ggae78dde67a6d78f332e9bdba0dde42db5ae611944ba148b6446d4387dd9b452917}{AV1E\_SET\_QM\_MIN},
835                                         \hyperlink{group__aom__encoder_ggae78dde67a6d78f332e9bdba0dde42db5ad897674e1b68b24ec14a01a4e3edacc7}{AV1E\_SET\_QM\_MAX},
836                                         \hyperlink{group__aom__encoder_ggae78dde67a6d78f332e9bdba0dde42db5abc82eae151e4a5050dbc324b5d16be2d}{AV1E\_SET\_REDUCED\_TX\_TYPE\_SET},
837 \textcolor{preprocessor}{#if CONFIG\_DIST\_8X8}
838                                         \hyperlink{group__aom__encoder_ggae78dde67a6d78f332e9bdba0dde42db5a7ef16c780349c5fee8281f1e5b4a6718}{AV1E\_SET\_ENABLE\_DIST\_8X8},
839 \textcolor{preprocessor}{#endif}
840                                         \hyperlink{group__aom__encoder_ggae78dde67a6d78f332e9bdba0dde42db5a465382b6bbca24467739c3c1b94e6483}{AV1E\_SET\_FRAME\_PARALLEL\_DECODING},
841                                         \hyperlink{group__aom__encoder_ggae78dde67a6d78f332e9bdba0dde42db5aa0d049453fced5f8079861b16e356c69}{AV1E\_SET\_ERROR\_RESILIENT\_MODE},
842                                         \hyperlink{group__aom__encoder_ggae78dde67a6d78f332e9bdba0dde42db5a17bd297efc31082157785d68fc5a6067}{AV1E\_SET\_AQ\_MODE},
843                                         \hyperlink{group__aom__encoder_ggae78dde67a6d78f332e9bdba0dde42db5ad26eda6211bf3d5fe4f5999ec52b264b}{AV1E\_SET\_DELTAQ\_MODE},
844                                         \hyperlink{group__aom__encoder_ggae78dde67a6d78f332e9bdba0dde42db5a737368591a37417b108c0706f7510885}{AV1E\_SET\_FRAME\_PERIODIC\_BOOST},
845                                         \hyperlink{group__aom__encoder_ggae78dde67a6d78f332e9bdba0dde42db5a8d415cd6976ea5860206e1d3cd3dd222}{AV1E\_SET\_NOISE\_SENSITIVITY},
846                                         \hyperlink{group__aom__encoder_ggae78dde67a6d78f332e9bdba0dde42db5a2625f566fd5c2675eb2bcd40af858652}{AV1E\_SET\_TUNE\_CONTENT},
847                                         \hyperlink{group__aom__encoder_ggae78dde67a6d78f332e9bdba0dde42db5a277526a4a9b8c413e870ee17ff986e87}{AV1E\_SET\_CDF\_UPDATE\_MODE},
848                                         \hyperlink{group__aom__encoder_ggae78dde67a6d78f332e9bdba0dde42db5af64e990728fe37287bac0874d77b22db}{AV1E\_SET\_COLOR\_PRIMARIES},
849                                         \hyperlink{group__aom__encoder_ggae78dde67a6d78f332e9bdba0dde42db5a336fc3607a5987f9077c634f07b3cd53}{AV1E\_SET\_TRANSFER\_CHARACTERISTICS},
850                                         \hyperlink{group__aom__encoder_ggae78dde67a6d78f332e9bdba0dde42db5a0111ed659d2cd11827ac5cd1f3d774b0}{AV1E\_SET\_MATRIX\_COEFFICIENTS},
851                                         \hyperlink{group__aom__encoder_ggae78dde67a6d78f332e9bdba0dde42db5abc5bb5cf57ba1a1193a0593225e881ff}{AV1E\_SET\_CHROMA\_SAMPLE\_POSITION},
852                                         \hyperlink{group__aom__encoder_ggae78dde67a6d78f332e9bdba0dde42db5a31bcfcb7057884ceb831146c90086ddd}{AV1E\_SET\_MIN\_GF\_INTERVAL},
853                                         \hyperlink{group__aom__encoder_ggae78dde67a6d78f332e9bdba0dde42db5a0355cea227ab76f9bd77028a39bbfca8}{AV1E\_SET\_MAX\_GF\_INTERVAL},
854                                         \hyperlink{group__aom__encoder_ggae78dde67a6d78f332e9bdba0dde42db5a685f831a5a5d08f9b5a14209d55ac129}{AV1E\_SET\_GF\_MAX\_PYRAMID\_HEIGHT},
855                                         \hyperlink{group__aom__encoder_ggae78dde67a6d78f332e9bdba0dde42db5a8854a06c62269e866d6bac0f3a2e3dc2}{AV1E\_SET\_SUPERBLOCK\_SIZE},
856                                         \hyperlink{group__aom__encoder_ggae78dde67a6d78f332e9bdba0dde42db5a9ac0044ad63e6848a482db04f0858c44}{AV1E\_SET\_NUM\_TG},
857                                         \hyperlink{group__aom__encoder_ggae78dde67a6d78f332e9bdba0dde42db5a353037d84b6c47ac0138fa843b70a2bb}{AV1E\_SET\_MTU},
858                                         \hyperlink{group__aom__encoder_ggae78dde67a6d78f332e9bdba0dde42db5a857e822046c62a4c774b1d16c4e453dd}{AV1E\_SET\_TIMING\_INFO\_TYPE},
859                                         \hyperlink{group__aom__encoder_ggae78dde67a6d78f332e9bdba0dde42db5a437e6b282a2395b4b08a9acde3e41cfb}{AV1E\_SET\_FILM\_GRAIN\_TEST\_VECTOR},
860                                         \hyperlink{group__aom__encoder_ggae78dde67a6d78f332e9bdba0dde42db5ad5846c6f49d37e65a03c39e68d487097}{AV1E\_SET\_FILM\_GRAIN\_TABLE},
861 \textcolor{preprocessor}{#if CONFIG\_DENOISE}
862                                         \hyperlink{group__aom__encoder_ggae78dde67a6d78f332e9bdba0dde42db5a54fe460f126a7566aa627cd82826faf0}{AV1E\_SET\_DENOISE\_NOISE\_LEVEL},
863                                         \hyperlink{group__aom__encoder_ggae78dde67a6d78f332e9bdba0dde42db5ae113c7e68a6c39b872a268ed6cdf6d10}{AV1E\_SET\_DENOISE\_BLOCK\_SIZE},
864 \textcolor{preprocessor}{#endif}
865                                         \hyperlink{group__aom__encoder_ggae78dde67a6d78f332e9bdba0dde42db5a5e82346d8463bf758967abb0d03ebc88}{AV1E\_SET\_ENABLE\_REF\_FRAME\_MVS},
866                                         0 \};
867 \textcolor{preprocessor}{#endif  // CONFIG\_AV1\_ENCODER}
868 
869 \textcolor{keyword}{static} \textcolor{keyword}{const} arg\_def\_t *no\_args[] = \{ NULL \};
870 
871 \textcolor{keyword}{static} \textcolor{keywordtype}{void} show\_help(FILE *fout, \textcolor{keywordtype}{int} shorthelp) \{
872   fprintf(fout, \textcolor{stringliteral}{"Usage: %s <options> -o dst\_filename src\_filename \(\backslash\)n"},
873           exec\_name);
874 
875   \textcolor{keywordflow}{if} (shorthelp) \{
876     fprintf(fout, \textcolor{stringliteral}{"Use --help to see the full list of options.\(\backslash\)n"});
877     \textcolor{keywordflow}{return};
878   \}
879 
880   fprintf(fout, \textcolor{stringliteral}{"\(\backslash\)nOptions:\(\backslash\)n"});
881   arg\_show\_usage(fout, main\_args);
882   fprintf(fout, \textcolor{stringliteral}{"\(\backslash\)nEncoder Global Options:\(\backslash\)n"});
883   arg\_show\_usage(fout, global\_args);
884   fprintf(fout, \textcolor{stringliteral}{"\(\backslash\)nRate Control Options:\(\backslash\)n"});
885   arg\_show\_usage(fout, rc\_args);
886   fprintf(fout, \textcolor{stringliteral}{"\(\backslash\)nTwopass Rate Control Options:\(\backslash\)n"});
887   arg\_show\_usage(fout, rc\_twopass\_args);
888   fprintf(fout, \textcolor{stringliteral}{"\(\backslash\)nKeyframe Placement Options:\(\backslash\)n"});
889   arg\_show\_usage(fout, kf\_args);
890 \textcolor{preprocessor}{#if CONFIG\_AV1\_ENCODER}
891   fprintf(fout, \textcolor{stringliteral}{"\(\backslash\)nAV1 Specific Options:\(\backslash\)n"});
892   arg\_show\_usage(fout, av1\_args);
893 \textcolor{preprocessor}{#endif}
894   fprintf(fout,
895           \textcolor{stringliteral}{"\(\backslash\)nStream timebase (--timebase):\(\backslash\)n"}
896           \textcolor{stringliteral}{"  The desired precision of timestamps in the output, expressed\(\backslash\)n"}
897           \textcolor{stringliteral}{"  in fractional seconds. Default is 1/1000.\(\backslash\)n"});
898   fprintf(fout, \textcolor{stringliteral}{"\(\backslash\)nIncluded encoders:\(\backslash\)n\(\backslash\)n"});
899 
900   \textcolor{keyword}{const} \textcolor{keywordtype}{int} num\_encoder = get\_aom\_encoder\_count();
901   \textcolor{keywordflow}{for} (\textcolor{keywordtype}{int} i = 0; i < num\_encoder; ++i) \{
902     \textcolor{keyword}{const} AvxInterface *\textcolor{keyword}{const} encoder = get\_aom\_encoder\_by\_index(i);
903     \textcolor{keyword}{const} \textcolor{keywordtype}{char} *defstr = (i == (num\_encoder - 1)) ? \textcolor{stringliteral}{"(default)"} : \textcolor{stringliteral}{""};
904     fprintf(fout, \textcolor{stringliteral}{"    %-6s - %s %s\(\backslash\)n"}, encoder->name,
905             \hyperlink{group__codec_ga013b1f6d96b2cf9489396311a7e5179b}{aom\_codec\_iface\_name}(encoder->codec\_interface()), defstr);
906   \}
907   fprintf(fout, \textcolor{stringliteral}{"\(\backslash\)n        "});
908   fprintf(fout, \textcolor{stringliteral}{"Use --codec to switch to a non-default encoder.\(\backslash\)n\(\backslash\)n"});
909 \}
910 
911 \textcolor{keywordtype}{void} usage\_exit(\textcolor{keywordtype}{void}) \{
912   show\_help(stderr, 1);
913   exit(EXIT\_FAILURE);
914 \}
915 
916 \textcolor{preprocessor}{#if CONFIG\_AV1\_ENCODER}
917 \textcolor{preprocessor}{#define ARG\_CTRL\_CNT\_MAX NELEMENTS(av1\_arg\_ctrl\_map)}
918 \textcolor{preprocessor}{#endif}
919 
920 \textcolor{preprocessor}{#if !CONFIG\_WEBM\_IO}
921 \textcolor{keyword}{typedef} \textcolor{keywordtype}{int} stereo\_format\_t;
922 \textcolor{keyword}{struct }WebmOutputContext \{
923   \textcolor{keywordtype}{int} debug;
924 \};
925 \textcolor{preprocessor}{#endif}
926 
927 \textcolor{comment}{/* Per-stream configuration */}
928 \textcolor{keyword}{struct }stream\_config \{
929   \textcolor{keyword}{struct }\hyperlink{structaom__codec__enc__cfg}{aom\_codec\_enc\_cfg} cfg;
930   \textcolor{keyword}{const} \textcolor{keywordtype}{char} *out\_fn;
931   \textcolor{keyword}{const} \textcolor{keywordtype}{char} *stats\_fn;
932 \textcolor{preprocessor}{#if CONFIG\_FP\_MB\_STATS}
933   \textcolor{keyword}{const} \textcolor{keywordtype}{char} *fpmb\_stats\_fn;
934 \textcolor{preprocessor}{#endif}
935   stereo\_format\_t stereo\_fmt;
936   \textcolor{keywordtype}{int} arg\_ctrls[ARG\_CTRL\_CNT\_MAX][2];
937   \textcolor{keywordtype}{int} arg\_ctrl\_cnt;
938   \textcolor{keywordtype}{int} write\_webm;
939   \textcolor{keyword}{const} \textcolor{keywordtype}{char} *film\_grain\_filename;
940   \textcolor{keywordtype}{int} write\_ivf;
941   \textcolor{comment}{// whether to use 16bit internal buffers}
942   \textcolor{keywordtype}{int} use\_16bit\_internal;
943 \};
944 
945 \textcolor{keyword}{struct }stream\_state \{
946   \textcolor{keywordtype}{int} index;
947   \textcolor{keyword}{struct }stream\_state *next;
948   \textcolor{keyword}{struct }stream\_config config;
949   FILE *file;
950   \textcolor{keyword}{struct }rate\_hist *rate\_hist;
951   \textcolor{keyword}{struct }WebmOutputContext webm\_ctx;
952   uint64\_t psnr\_sse\_total;
953   uint64\_t psnr\_samples\_total;
954   \textcolor{keywordtype}{double} psnr\_totals[4];
955   \textcolor{keywordtype}{int} psnr\_count;
956   \textcolor{keywordtype}{int} counts[64];
957   \hyperlink{structaom__codec__ctx}{aom\_codec\_ctx\_t} encoder;
958   \textcolor{keywordtype}{unsigned} \textcolor{keywordtype}{int} frames\_out;
959   uint64\_t cx\_time;
960   \textcolor{keywordtype}{size\_t} nbytes;
961   stats\_io\_t stats;
962 \textcolor{preprocessor}{#if CONFIG\_FP\_MB\_STATS}
963   stats\_io\_t fpmb\_stats;
964 \textcolor{preprocessor}{#endif}
965   \textcolor{keyword}{struct }\hyperlink{structaom__image}{aom\_image} *img;
966   \hyperlink{structaom__codec__ctx}{aom\_codec\_ctx\_t} decoder;
967   \textcolor{keywordtype}{int} mismatch\_seen;
968   \textcolor{keywordtype}{unsigned} \textcolor{keywordtype}{int} chroma\_subsampling\_x;
969   \textcolor{keywordtype}{unsigned} \textcolor{keywordtype}{int} chroma\_subsampling\_y;
970 \};
971 
972 \textcolor{keyword}{static} \textcolor{keywordtype}{void} validate\_positive\_rational(\textcolor{keyword}{const} \textcolor{keywordtype}{char} *msg,
973                                        \textcolor{keyword}{struct} \hyperlink{structaom__rational}{aom\_rational} *rat) \{
974   \textcolor{keywordflow}{if} (rat->\hyperlink{structaom__rational_adeddf2ea01c12b7be66536e0a0fb92c5}{den} < 0) \{
975     rat->\hyperlink{structaom__rational_a7b48174411798c780a15f132c4650839}{num} *= -1;
976     rat->\hyperlink{structaom__rational_adeddf2ea01c12b7be66536e0a0fb92c5}{den} *= -1;
977   \}
978 
979   \textcolor{keywordflow}{if} (rat->\hyperlink{structaom__rational_a7b48174411798c780a15f132c4650839}{num} < 0) die(\textcolor{stringliteral}{"Error: %s must be positive\(\backslash\)n"}, msg);
980 
981   \textcolor{keywordflow}{if} (!rat->\hyperlink{structaom__rational_adeddf2ea01c12b7be66536e0a0fb92c5}{den}) die(\textcolor{stringliteral}{"Error: %s has zero denominator\(\backslash\)n"}, msg);
982 \}
983 
984 \textcolor{comment}{/* Parses global config arguments into the AvxEncoderConfig. Note that}
985 \textcolor{comment}{ * argv is modified and overwrites all parsed arguments.}
986 \textcolor{comment}{ */}
987 \textcolor{keyword}{static} \textcolor{keywordtype}{void} parse\_global\_config(\textcolor{keyword}{struct} AvxEncoderConfig *global, \textcolor{keywordtype}{int} argc,
988                                 \textcolor{keywordtype}{char} ***argv) \{
989   \textcolor{keywordtype}{char} **argi, **argj;
990   \textcolor{keyword}{struct }arg arg;
991   \textcolor{keyword}{const} \textcolor{keywordtype}{int} num\_encoder = get\_aom\_encoder\_count();
992   \textcolor{keywordtype}{char} **argv\_local = (\textcolor{keywordtype}{char} **)*argv;
993 \textcolor{preprocessor}{#if CONFIG\_FILEOPTIONS}
994   \textcolor{keywordtype}{int} argc\_local = argc;
995 \textcolor{preprocessor}{#endif}
996   \textcolor{keywordflow}{if} (num\_encoder < 1) die(\textcolor{stringliteral}{"Error: no valid encoder available\(\backslash\)n"});
997 
998   \textcolor{comment}{/* Initialize default parameters */}
999   memset(global, 0, \textcolor{keyword}{sizeof}(*global));
1000   global->codec = get\_aom\_encoder\_by\_index(num\_encoder - 1);
1001   global->passes = 0;
1002   global->color\_type = I420;
1003   global->csp = \hyperlink{aom__image_8h_a10590253ef3dbde7e93ed5d4b4e0e73ba7843506f3e28f720be0d4f03237fb48c}{AOM\_CSP\_UNKNOWN};
1004 
1005 \textcolor{preprocessor}{#if CONFIG\_FILEOPTIONS}
1006   \textcolor{keyword}{const} \textcolor{keywordtype}{char} *cfg = NULL;
1007   \textcolor{keywordtype}{int} cfg\_included = 0;
1008 \textcolor{preprocessor}{#endif}
1009   \textcolor{keywordflow}{for} (argi = argj = argv\_local; (*argj = *argi); argi += arg.argv\_step) \{
1010     arg.argv\_step = 1;
1011 
1012 \textcolor{preprocessor}{#if CONFIG\_FILEOPTIONS}
1013     \textcolor{keywordflow}{if} (arg\_match(&arg, &use\_cfg, argi)) \{
1014       \textcolor{keywordflow}{if} (cfg\_included) \textcolor{keywordflow}{continue};
1015       cfg = arg.val;
1016 
1017       arg\_cfg(&argc\_local, &argv\_local, cfg);
1018 
1019       *argj = *argi = *argv\_local;
1020       argj = argi = argv\_local;
1021       *argv = argv\_local;
1022       cfg\_included = 1;
1023       \textcolor{keywordflow}{continue};
1024     \}
1025 \textcolor{preprocessor}{#endif}
1026     \textcolor{keywordflow}{if} (arg\_match(&arg, &help, argi)) \{
1027       show\_help(stdout, 0);
1028       exit(EXIT\_SUCCESS);
1029     \} \textcolor{keywordflow}{else} \textcolor{keywordflow}{if} (arg\_match(&arg, &codecarg, argi)) \{
1030       global->codec = get\_aom\_encoder\_by\_name(arg.val);
1031       \textcolor{keywordflow}{if} (!global->codec)
1032         die(\textcolor{stringliteral}{"Error: Unrecognized argument (%s) to --codec\(\backslash\)n"}, arg.val);
1033     \} \textcolor{keywordflow}{else} \textcolor{keywordflow}{if} (arg\_match(&arg, &passes, argi)) \{
1034       global->passes = arg\_parse\_uint(&arg);
1035 
1036       \textcolor{keywordflow}{if} (global->passes < 1 || global->passes > 2)
1037         die(\textcolor{stringliteral}{"Error: Invalid number of passes (%d)\(\backslash\)n"}, global->passes);
1038     \} \textcolor{keywordflow}{else} \textcolor{keywordflow}{if} (arg\_match(&arg, &pass\_arg, argi)) \{
1039       global->pass = arg\_parse\_uint(&arg);
1040 
1041       \textcolor{keywordflow}{if} (global->pass < 1 || global->pass > 2)
1042         die(\textcolor{stringliteral}{"Error: Invalid pass selected (%d)\(\backslash\)n"}, global->pass);
1043     \} \textcolor{keywordflow}{else} \textcolor{keywordflow}{if} (arg\_match(&arg, &input\_chroma\_sample\_position, argi)) \{
1044       global->csp = arg\_parse\_enum(&arg);
1045       \textcolor{comment}{/* Flag is used by later code as well, preserve it. */}
1046       argj++;
1047     \} \textcolor{keywordflow}{else} \textcolor{keywordflow}{if} (arg\_match(&arg, &usage, argi))
1048       global->usage = arg\_parse\_uint(&arg);
1049     \textcolor{keywordflow}{else} \textcolor{keywordflow}{if} (arg\_match(&arg, &good\_dl, argi))
1050       warn(\textcolor{stringliteral}{"Deprecated --good option! Ignoring\(\backslash\)n"});
1051     \textcolor{keywordflow}{else} \textcolor{keywordflow}{if} (arg\_match(&arg, &use\_yv12, argi))
1052       global->color\_type = YV12;
1053     \textcolor{keywordflow}{else} \textcolor{keywordflow}{if} (arg\_match(&arg, &use\_i420, argi))
1054       global->color\_type = I420;
1055     \textcolor{keywordflow}{else} \textcolor{keywordflow}{if} (arg\_match(&arg, &use\_i422, argi))
1056       global->color\_type = I422;
1057     \textcolor{keywordflow}{else} \textcolor{keywordflow}{if} (arg\_match(&arg, &use\_i444, argi))
1058       global->color\_type = I444;
1059     \textcolor{keywordflow}{else} \textcolor{keywordflow}{if} (arg\_match(&arg, &quietarg, argi))
1060       global->quiet = 1;
1061     \textcolor{keywordflow}{else} \textcolor{keywordflow}{if} (arg\_match(&arg, &verbosearg, argi))
1062       global->verbose = 1;
1063     \textcolor{keywordflow}{else} \textcolor{keywordflow}{if} (arg\_match(&arg, &limit, argi))
1064       global->limit = arg\_parse\_uint(&arg);
1065     \textcolor{keywordflow}{else} \textcolor{keywordflow}{if} (arg\_match(&arg, &skip, argi))
1066       global->skip\_frames = arg\_parse\_uint(&arg);
1067     \textcolor{keywordflow}{else} \textcolor{keywordflow}{if} (arg\_match(&arg, &psnrarg, argi))
1068       global->show\_psnr = 1;
1069     \textcolor{keywordflow}{else} \textcolor{keywordflow}{if} (arg\_match(&arg, &recontest, argi))
1070       global->test\_decode = arg\_parse\_enum\_or\_int(&arg);
1071     \textcolor{keywordflow}{else} \textcolor{keywordflow}{if} (arg\_match(&arg, &framerate, argi)) \{
1072       global->framerate = arg\_parse\_rational(&arg);
1073       validate\_positive\_rational(arg.name, &global->framerate);
1074       global->have\_framerate = 1;
1075     \} \textcolor{keywordflow}{else} \textcolor{keywordflow}{if} (arg\_match(&arg, &debugmode, argi))
1076       global->debug = 1;
1077     \textcolor{keywordflow}{else} \textcolor{keywordflow}{if} (arg\_match(&arg, &q\_hist\_n, argi))
1078       global->show\_q\_hist\_buckets = arg\_parse\_uint(&arg);
1079     \textcolor{keywordflow}{else} \textcolor{keywordflow}{if} (arg\_match(&arg, &rate\_hist\_n, argi))
1080       global->show\_rate\_hist\_buckets = arg\_parse\_uint(&arg);
1081     \textcolor{keywordflow}{else} \textcolor{keywordflow}{if} (arg\_match(&arg, &disable\_warnings, argi))
1082       global->disable\_warnings = 1;
1083     \textcolor{keywordflow}{else} \textcolor{keywordflow}{if} (arg\_match(&arg, &disable\_warning\_prompt, argi))
1084       global->disable\_warning\_prompt = 1;
1085     \textcolor{keywordflow}{else}
1086       argj++;
1087   \}
1088 
1089   \textcolor{keywordflow}{if} (global->pass) \{
1090     \textcolor{comment}{/* DWIM: Assume the user meant passes=2 if pass=2 is specified */}
1091     \textcolor{keywordflow}{if} (global->pass > global->passes) \{
1092       warn(\textcolor{stringliteral}{"Assuming --pass=%d implies --passes=%d\(\backslash\)n"}, global->pass,
1093            global->pass);
1094       global->passes = global->pass;
1095     \}
1096   \}
1097   \textcolor{comment}{/* Validate global config */}
1098   \textcolor{keywordflow}{if} (global->passes == 0) \{
1099 \textcolor{preprocessor}{#if CONFIG\_AV1\_ENCODER}
1100     \textcolor{comment}{// Make default AV1 passes = 2 until there is a better quality 1-pass}
1101     \textcolor{comment}{// encoder}
1102     \textcolor{keywordflow}{if} (global->codec != NULL && global->codec->name != NULL)
1103       global->passes = (strcmp(global->codec->name, \textcolor{stringliteral}{"av1"}) == 0) ? 2 : 1;
1104 \textcolor{preprocessor}{#else}
1105     global->passes = 1;
1106 \textcolor{preprocessor}{#endif}
1107   \}
1108 \}
1109 
1110 \textcolor{keyword}{static} \textcolor{keywordtype}{void} open\_input\_file(\textcolor{keyword}{struct} AvxInputContext *input,
1111                             \hyperlink{aom__image_8h_a48f259fc7774b1c799b3ebe7530c19bd}{aom\_chroma\_sample\_position\_t} csp) \{
1112   \textcolor{comment}{/* Parse certain options from the input file, if possible */}
1113   input->file = strcmp(input->filename, \textcolor{stringliteral}{"-"}) ? fopen(input->filename, \textcolor{stringliteral}{"rb"})
1114                                              : set\_binary\_mode(stdin);
1115 
1116   \textcolor{keywordflow}{if} (!input->file) fatal(\textcolor{stringliteral}{"Failed to open input file"});
1117 
1118   \textcolor{keywordflow}{if} (!fseeko(input->file, 0, SEEK\_END)) \{
1119     \textcolor{comment}{/* Input file is seekable. Figure out how long it is, so we can get}
1120 \textcolor{comment}{     * progress info.}
1121 \textcolor{comment}{     */}
1122     input->length = ftello(input->file);
1123     rewind(input->file);
1124   \}
1125 
1126   \textcolor{comment}{/* Default to 1:1 pixel aspect ratio. */}
1127   input->pixel\_aspect\_ratio.numerator = 1;
1128   input->pixel\_aspect\_ratio.denominator = 1;
1129 
1130   \textcolor{comment}{/* For RAW input sources, these bytes will applied on the first frame}
1131 \textcolor{comment}{   *  in read\_frame().}
1132 \textcolor{comment}{   */}
1133   input->detect.buf\_read = fread(input->detect.buf, 1, 4, input->file);
1134   input->detect.position = 0;
1135 
1136   \textcolor{keywordflow}{if} (input->detect.buf\_read == 4 && file\_is\_y4m(input->detect.buf)) \{
1137     \textcolor{keywordflow}{if} (y4m\_input\_open(&input->y4m, input->file, input->detect.buf, 4, csp,
1138                        input->only\_i420) >= 0) \{
1139       input->file\_type = FILE\_TYPE\_Y4M;
1140       input->width = input->y4m.pic\_w;
1141       input->height = input->y4m.pic\_h;
1142       input->pixel\_aspect\_ratio.numerator = input->y4m.par\_n;
1143       input->pixel\_aspect\_ratio.denominator = input->y4m.par\_d;
1144       input->framerate.numerator = input->y4m.fps\_n;
1145       input->framerate.denominator = input->y4m.fps\_d;
1146       input->fmt = input->y4m.aom\_fmt;
1147       input->bit\_depth = input->y4m.bit\_depth;
1148     \} \textcolor{keywordflow}{else}
1149       fatal(\textcolor{stringliteral}{"Unsupported Y4M stream."});
1150   \} \textcolor{keywordflow}{else} \textcolor{keywordflow}{if} (input->detect.buf\_read == 4 && fourcc\_is\_ivf(input->detect.buf)) \{
1151     fatal(\textcolor{stringliteral}{"IVF is not supported as input."});
1152   \} \textcolor{keywordflow}{else} \{
1153     input->file\_type = FILE\_TYPE\_RAW;
1154   \}
1155 \}
1156 
1157 \textcolor{keyword}{static} \textcolor{keywordtype}{void} close\_input\_file(\textcolor{keyword}{struct} AvxInputContext *input) \{
1158   fclose(input->file);
1159   \textcolor{keywordflow}{if} (input->file\_type == FILE\_TYPE\_Y4M) y4m\_input\_close(&input->y4m);
1160 \}
1161 
1162 \textcolor{keyword}{static} \textcolor{keyword}{struct }stream\_state *new\_stream(\textcolor{keyword}{struct} AvxEncoderConfig *global,
1163                                        \textcolor{keyword}{struct} stream\_state *prev) \{
1164   \textcolor{keyword}{struct }stream\_state *stream;
1165 
1166   stream = calloc(1, \textcolor{keyword}{sizeof}(*stream));
1167   \textcolor{keywordflow}{if} (stream == NULL) \{
1168     fatal(\textcolor{stringliteral}{"Failed to allocate new stream."});
1169   \}
1170 
1171   \textcolor{keywordflow}{if} (prev) \{
1172     memcpy(stream, prev, \textcolor{keyword}{sizeof}(*stream));
1173     stream->index++;
1174     prev->next = stream;
1175   \} \textcolor{keywordflow}{else} \{
1176     \hyperlink{group__codec_gaaae61e0f8663e6137f1e228757248e7c}{aom\_codec\_err\_t} res;
1177 
1178     \textcolor{comment}{/* Populate encoder configuration */}
1179     res = \hyperlink{group__encoder_gabe456ab6f99bdebc47018779b75d2521}{aom\_codec\_enc\_config\_default}(global->codec->codec\_interface(),
1180                                        &stream->config.cfg, global->usage);
1181     \textcolor{keywordflow}{if} (res) fatal(\textcolor{stringliteral}{"Failed to get config: %s\(\backslash\)n"}, \hyperlink{group__codec_ga83c6525528574d1a88e73a9f605c9115}{aom\_codec\_err\_to\_string}(res));
1182 
1183     \textcolor{comment}{/* Change the default timebase to a high enough value so that the}
1184 \textcolor{comment}{     * encoder will always create strictly increasing timestamps.}
1185 \textcolor{comment}{     */}
1186     stream->config.cfg.g\_timebase.den = 1000;
1187 
1188     \textcolor{comment}{/* Never use the library's default resolution, require it be parsed}
1189 \textcolor{comment}{     * from the file or set on the command line.}
1190 \textcolor{comment}{     */}
1191     stream->config.cfg.g\_w = 0;
1192     stream->config.cfg.g\_h = 0;
1193 
1194     \textcolor{comment}{/* Initialize remaining stream parameters */}
1195     stream->config.write\_webm = 1;
1196     stream->config.write\_ivf = 0;
1197 
1198 \textcolor{preprocessor}{#if CONFIG\_WEBM\_IO}
1199     stream->config.stereo\_fmt = STEREO\_FORMAT\_MONO;
1200     stream->webm\_ctx.last\_pts\_ns = -1;
1201     stream->webm\_ctx.writer = NULL;
1202     stream->webm\_ctx.segment = NULL;
1203 \textcolor{preprocessor}{#endif}
1204 
1205     \textcolor{comment}{/* Allows removal of the application version from the EBML tags */}
1206     stream->webm\_ctx.debug = global->debug;
1207   \}
1208 
1209   \textcolor{comment}{/* Output files must be specified for each stream */}
1210   stream->config.out\_fn = NULL;
1211 
1212   stream->next = NULL;
1213   \textcolor{keywordflow}{return} stream;
1214 \}
1215 
1216 \textcolor{keyword}{static} \textcolor{keywordtype}{void} set\_config\_arg\_ctrls(\textcolor{keyword}{struct} stream\_config *config, \textcolor{keywordtype}{int} key,
1217                                  \textcolor{keyword}{const} \textcolor{keyword}{struct} arg *arg) \{
1218   \textcolor{keywordtype}{int} j;
1219   \textcolor{keywordflow}{if} (key == \hyperlink{group__aom__encoder_ggae78dde67a6d78f332e9bdba0dde42db5ad5846c6f49d37e65a03c39e68d487097}{AV1E\_SET\_FILM\_GRAIN\_TABLE}) \{
1220     config->film\_grain\_filename = arg->val;
1221     \textcolor{keywordflow}{return};
1222   \}
1223 
1224   \textcolor{comment}{/* Point either to the next free element or the first instance of this}
1225 \textcolor{comment}{   * control.}
1226 \textcolor{comment}{   */}
1227   \textcolor{keywordflow}{for} (j = 0; j < config->arg\_ctrl\_cnt; j++)
1228     \textcolor{keywordflow}{if} (config->arg\_ctrls[j][0] == key) \textcolor{keywordflow}{break};
1229 
1230   \textcolor{comment}{/* Update/insert */}
1231   assert(j < (\textcolor{keywordtype}{int})ARG\_CTRL\_CNT\_MAX);
1232   config->arg\_ctrls[j][0] = key;
1233   config->arg\_ctrls[j][1] = arg\_parse\_enum\_or\_int(arg);
1234 
1235   \textcolor{keywordflow}{if} (key == \hyperlink{group__aom__encoder_ggae78dde67a6d78f332e9bdba0dde42db5ac8a24393f214823f5a6bd345afb840b6}{AOME\_SET\_ENABLEAUTOALTREF} && config->arg\_ctrls[j][1] > 1) \{
1236     warn(\textcolor{stringliteral}{"auto-alt-ref > 1 is deprecated... setting auto-alt-ref=1\(\backslash\)n"});
1237     config->arg\_ctrls[j][1] = 1;
1238   \}
1239   \textcolor{keywordflow}{if} (j == config->arg\_ctrl\_cnt) config->arg\_ctrl\_cnt++;
1240 \}
1241 
1242 \textcolor{keyword}{static} \textcolor{keywordtype}{int} parse\_stream\_params(\textcolor{keyword}{struct} AvxEncoderConfig *global,
1243                                \textcolor{keyword}{struct} stream\_state *stream, \textcolor{keywordtype}{char} **argv) \{
1244   \textcolor{keywordtype}{char} **argi, **argj;
1245   \textcolor{keyword}{struct }arg arg;
1246   \textcolor{keyword}{static} \textcolor{keyword}{const} arg\_def\_t **ctrl\_args = no\_args;
1247   \textcolor{keyword}{static} \textcolor{keyword}{const} \textcolor{keywordtype}{int} *ctrl\_args\_map = NULL;
1248   \textcolor{keyword}{struct }stream\_config *config = &stream->config;
1249   \textcolor{keywordtype}{int} eos\_mark\_found = 0;
1250   \textcolor{keywordtype}{int} webm\_forced = 0;
1251 
1252   \textcolor{comment}{// Handle codec specific options}
1253   \textcolor{keywordflow}{if} (0) \{
1254 \textcolor{preprocessor}{#if CONFIG\_AV1\_ENCODER}
1255   \} \textcolor{keywordflow}{else} \textcolor{keywordflow}{if} (strcmp(global->codec->name, \textcolor{stringliteral}{"av1"}) == 0) \{
1256     \textcolor{comment}{// TODO(jingning): Reuse AV1 specific encoder configuration parameters.}
1257     \textcolor{comment}{// Consider to expand this set for AV1 encoder control.}
1258     ctrl\_args = av1\_args;
1259     ctrl\_args\_map = av1\_arg\_ctrl\_map;
1260 \textcolor{preprocessor}{#endif}
1261   \}
1262 
1263   \textcolor{keywordflow}{for} (argi = argj = argv; (*argj = *argi); argi += arg.argv\_step) \{
1264     arg.argv\_step = 1;
1265 
1266     \textcolor{comment}{/* Once we've found an end-of-stream marker (--) we want to continue}
1267 \textcolor{comment}{     * shifting arguments but not consuming them.}
1268 \textcolor{comment}{     */}
1269     \textcolor{keywordflow}{if} (eos\_mark\_found) \{
1270       argj++;
1271       \textcolor{keywordflow}{continue};
1272     \} \textcolor{keywordflow}{else} \textcolor{keywordflow}{if} (!strcmp(*argj, \textcolor{stringliteral}{"--"})) \{
1273       eos\_mark\_found = 1;
1274       \textcolor{keywordflow}{continue};
1275     \}
1276 
1277     \textcolor{keywordflow}{if} (arg\_match(&arg, &outputfile, argi)) \{
1278       config->out\_fn = arg.val;
1279       \textcolor{keywordflow}{if} (!webm\_forced) \{
1280         \textcolor{keyword}{const} \textcolor{keywordtype}{size\_t} out\_fn\_len = strlen(config->out\_fn);
1281         \textcolor{keywordflow}{if} (out\_fn\_len >= 4 &&
1282             !strcmp(config->out\_fn + out\_fn\_len - 4, \textcolor{stringliteral}{".ivf"})) \{
1283           config->write\_webm = 0;
1284           config->write\_ivf = 1;
1285         \} \textcolor{keywordflow}{else} \textcolor{keywordflow}{if} (out\_fn\_len >= 4 &&
1286                    !strcmp(config->out\_fn + out\_fn\_len - 4, \textcolor{stringliteral}{".obu"})) \{
1287           config->write\_webm = 0;
1288           config->write\_ivf = 0;
1289         \}
1290       \}
1291     \} \textcolor{keywordflow}{else} \textcolor{keywordflow}{if} (arg\_match(&arg, &fpf\_name, argi)) \{
1292       config->stats\_fn = arg.val;
1293 \textcolor{preprocessor}{#if CONFIG\_FP\_MB\_STATS}
1294     \} \textcolor{keywordflow}{else} \textcolor{keywordflow}{if} (arg\_match(&arg, &fpmbf\_name, argi)) \{
1295       config->fpmb\_stats\_fn = arg.val;
1296 \textcolor{preprocessor}{#endif}
1297     \} \textcolor{keywordflow}{else} \textcolor{keywordflow}{if} (arg\_match(&arg, &use\_webm, argi)) \{
1298 \textcolor{preprocessor}{#if CONFIG\_WEBM\_IO}
1299       config->write\_webm = 1;
1300       webm\_forced = 1;
1301 \textcolor{preprocessor}{#else}
1302       die(\textcolor{stringliteral}{"Error: --webm specified but webm is disabled."});
1303 \textcolor{preprocessor}{#endif}
1304     \} \textcolor{keywordflow}{else} \textcolor{keywordflow}{if} (arg\_match(&arg, &use\_ivf, argi)) \{
1305       config->write\_webm = 0;
1306       config->write\_ivf = 1;
1307     \} \textcolor{keywordflow}{else} \textcolor{keywordflow}{if} (arg\_match(&arg, &use\_obu, argi)) \{
1308       config->write\_webm = 0;
1309       config->write\_ivf = 0;
1310     \} \textcolor{keywordflow}{else} \textcolor{keywordflow}{if} (arg\_match(&arg, &threads, argi)) \{
1311       config->cfg.g\_threads = arg\_parse\_uint(&arg);
1312     \} \textcolor{keywordflow}{else} \textcolor{keywordflow}{if} (arg\_match(&arg, &profile, argi)) \{
1313       config->cfg.g\_profile = arg\_parse\_uint(&arg);
1314     \} \textcolor{keywordflow}{else} \textcolor{keywordflow}{if} (arg\_match(&arg, &width, argi)) \{
1315       config->cfg.g\_w = arg\_parse\_uint(&arg);
1316     \} \textcolor{keywordflow}{else} \textcolor{keywordflow}{if} (arg\_match(&arg, &height, argi)) \{
1317       config->cfg.g\_h = arg\_parse\_uint(&arg);
1318     \} \textcolor{keywordflow}{else} \textcolor{keywordflow}{if} (arg\_match(&arg, &forced\_max\_frame\_width, argi)) \{
1319       config->cfg.g\_forced\_max\_frame\_width = arg\_parse\_uint(&arg);
1320     \} \textcolor{keywordflow}{else} \textcolor{keywordflow}{if} (arg\_match(&arg, &forced\_max\_frame\_height, argi)) \{
1321       config->cfg.g\_forced\_max\_frame\_height = arg\_parse\_uint(&arg);
1322     \} \textcolor{keywordflow}{else} \textcolor{keywordflow}{if} (arg\_match(&arg, &bitdeptharg, argi)) \{
1323       config->cfg.g\_bit\_depth = arg\_parse\_enum\_or\_int(&arg);
1324     \} \textcolor{keywordflow}{else} \textcolor{keywordflow}{if} (arg\_match(&arg, &inbitdeptharg, argi)) \{
1325       config->cfg.g\_input\_bit\_depth = arg\_parse\_uint(&arg);
1326     \} \textcolor{keywordflow}{else} \textcolor{keywordflow}{if} (arg\_match(&arg, &input\_chroma\_subsampling\_x, argi)) \{
1327       stream->chroma\_subsampling\_x = arg\_parse\_uint(&arg);
1328     \} \textcolor{keywordflow}{else} \textcolor{keywordflow}{if} (arg\_match(&arg, &input\_chroma\_subsampling\_y, argi)) \{
1329       stream->chroma\_subsampling\_y = arg\_parse\_uint(&arg);
1330 \textcolor{preprocessor}{#if CONFIG\_WEBM\_IO}
1331     \} \textcolor{keywordflow}{else} \textcolor{keywordflow}{if} (arg\_match(&arg, &stereo\_mode, argi)) \{
1332       config->stereo\_fmt = arg\_parse\_enum\_or\_int(&arg);
1333 \textcolor{preprocessor}{#endif}
1334     \} \textcolor{keywordflow}{else} \textcolor{keywordflow}{if} (arg\_match(&arg, &timebase, argi)) \{
1335       config->cfg.g\_timebase = arg\_parse\_rational(&arg);
1336       validate\_positive\_rational(arg.name, &config->cfg.g\_timebase);
1337     \} \textcolor{keywordflow}{else} \textcolor{keywordflow}{if} (arg\_match(&arg, &global\_error\_resilient, argi)) \{
1338       config->cfg.g\_error\_resilient = arg\_parse\_uint(&arg);
1339     \} \textcolor{keywordflow}{else} \textcolor{keywordflow}{if} (arg\_match(&arg, &lag\_in\_frames, argi)) \{
1340       config->cfg.g\_lag\_in\_frames = arg\_parse\_uint(&arg);
1341     \} \textcolor{keywordflow}{else} \textcolor{keywordflow}{if} (arg\_match(&arg, &large\_scale\_tile, argi)) \{
1342       config->cfg.large\_scale\_tile = arg\_parse\_uint(&arg);
1343     \} \textcolor{keywordflow}{else} \textcolor{keywordflow}{if} (arg\_match(&arg, &monochrome, argi)) \{
1344       config->cfg.monochrome = 1;
1345     \} \textcolor{keywordflow}{else} \textcolor{keywordflow}{if} (arg\_match(&arg, &full\_still\_picture\_hdr, argi)) \{
1346       config->cfg.full\_still\_picture\_hdr = 1;
1347     \} \textcolor{keywordflow}{else} \textcolor{keywordflow}{if} (arg\_match(&arg, &dropframe\_thresh, argi)) \{
1348       config->cfg.rc\_dropframe\_thresh = arg\_parse\_uint(&arg);
1349     \} \textcolor{keywordflow}{else} \textcolor{keywordflow}{if} (arg\_match(&arg, &resize\_mode, argi)) \{
1350       config->cfg.rc\_resize\_mode = arg\_parse\_uint(&arg);
1351     \} \textcolor{keywordflow}{else} \textcolor{keywordflow}{if} (arg\_match(&arg, &resize\_denominator, argi)) \{
1352       config->cfg.rc\_resize\_denominator = arg\_parse\_uint(&arg);
1353     \} \textcolor{keywordflow}{else} \textcolor{keywordflow}{if} (arg\_match(&arg, &resize\_kf\_denominator, argi)) \{
1354       config->cfg.rc\_resize\_kf\_denominator = arg\_parse\_uint(&arg);
1355     \} \textcolor{keywordflow}{else} \textcolor{keywordflow}{if} (arg\_match(&arg, &superres\_mode, argi)) \{
1356       config->cfg.rc\_superres\_mode = arg\_parse\_uint(&arg);
1357     \} \textcolor{keywordflow}{else} \textcolor{keywordflow}{if} (arg\_match(&arg, &superres\_denominator, argi)) \{
1358       config->cfg.rc\_superres\_denominator = arg\_parse\_uint(&arg);
1359     \} \textcolor{keywordflow}{else} \textcolor{keywordflow}{if} (arg\_match(&arg, &superres\_kf\_denominator, argi)) \{
1360       config->cfg.rc\_superres\_kf\_denominator = arg\_parse\_uint(&arg);
1361     \} \textcolor{keywordflow}{else} \textcolor{keywordflow}{if} (arg\_match(&arg, &superres\_qthresh, argi)) \{
1362       config->cfg.rc\_superres\_qthresh = arg\_parse\_uint(&arg);
1363     \} \textcolor{keywordflow}{else} \textcolor{keywordflow}{if} (arg\_match(&arg, &superres\_kf\_qthresh, argi)) \{
1364       config->cfg.rc\_superres\_kf\_qthresh = arg\_parse\_uint(&arg);
1365     \} \textcolor{keywordflow}{else} \textcolor{keywordflow}{if} (arg\_match(&arg, &end\_usage, argi)) \{
1366       config->cfg.rc\_end\_usage = arg\_parse\_enum\_or\_int(&arg);
1367     \} \textcolor{keywordflow}{else} \textcolor{keywordflow}{if} (arg\_match(&arg, &target\_bitrate, argi)) \{
1368       config->cfg.rc\_target\_bitrate = arg\_parse\_uint(&arg);
1369     \} \textcolor{keywordflow}{else} \textcolor{keywordflow}{if} (arg\_match(&arg, &min\_quantizer, argi)) \{
1370       config->cfg.rc\_min\_quantizer = arg\_parse\_uint(&arg);
1371     \} \textcolor{keywordflow}{else} \textcolor{keywordflow}{if} (arg\_match(&arg, &max\_quantizer, argi)) \{
1372       config->cfg.rc\_max\_quantizer = arg\_parse\_uint(&arg);
1373     \} \textcolor{keywordflow}{else} \textcolor{keywordflow}{if} (arg\_match(&arg, &undershoot\_pct, argi)) \{
1374       config->cfg.rc\_undershoot\_pct = arg\_parse\_uint(&arg);
1375     \} \textcolor{keywordflow}{else} \textcolor{keywordflow}{if} (arg\_match(&arg, &overshoot\_pct, argi)) \{
1376       config->cfg.rc\_overshoot\_pct = arg\_parse\_uint(&arg);
1377     \} \textcolor{keywordflow}{else} \textcolor{keywordflow}{if} (arg\_match(&arg, &buf\_sz, argi)) \{
1378       config->cfg.rc\_buf\_sz = arg\_parse\_uint(&arg);
1379     \} \textcolor{keywordflow}{else} \textcolor{keywordflow}{if} (arg\_match(&arg, &buf\_initial\_sz, argi)) \{
1380       config->cfg.rc\_buf\_initial\_sz = arg\_parse\_uint(&arg);
1381     \} \textcolor{keywordflow}{else} \textcolor{keywordflow}{if} (arg\_match(&arg, &buf\_optimal\_sz, argi)) \{
1382       config->cfg.rc\_buf\_optimal\_sz = arg\_parse\_uint(&arg);
1383     \} \textcolor{keywordflow}{else} \textcolor{keywordflow}{if} (arg\_match(&arg, &bias\_pct, argi)) \{
1384       config->cfg.rc\_2pass\_vbr\_bias\_pct = arg\_parse\_uint(&arg);
1385       \textcolor{keywordflow}{if} (global->passes < 2)
1386         warn(\textcolor{stringliteral}{"option %s ignored in one-pass mode.\(\backslash\)n"}, arg.name);
1387     \} \textcolor{keywordflow}{else} \textcolor{keywordflow}{if} (arg\_match(&arg, &minsection\_pct, argi)) \{
1388       config->cfg.rc\_2pass\_vbr\_minsection\_pct = arg\_parse\_uint(&arg);
1389 
1390       \textcolor{keywordflow}{if} (global->passes < 2)
1391         warn(\textcolor{stringliteral}{"option %s ignored in one-pass mode.\(\backslash\)n"}, arg.name);
1392     \} \textcolor{keywordflow}{else} \textcolor{keywordflow}{if} (arg\_match(&arg, &maxsection\_pct, argi)) \{
1393       config->cfg.rc\_2pass\_vbr\_maxsection\_pct = arg\_parse\_uint(&arg);
1394 
1395       \textcolor{keywordflow}{if} (global->passes < 2)
1396         warn(\textcolor{stringliteral}{"option %s ignored in one-pass mode.\(\backslash\)n"}, arg.name);
1397     \} \textcolor{keywordflow}{else} \textcolor{keywordflow}{if} (arg\_match(&arg, &fwd\_kf\_enabled, argi)) \{
1398       config->cfg.fwd\_kf\_enabled = arg\_parse\_uint(&arg);
1399     \} \textcolor{keywordflow}{else} \textcolor{keywordflow}{if} (arg\_match(&arg, &kf\_min\_dist, argi)) \{
1400       config->cfg.kf\_min\_dist = arg\_parse\_uint(&arg);
1401     \} \textcolor{keywordflow}{else} \textcolor{keywordflow}{if} (arg\_match(&arg, &kf\_max\_dist, argi)) \{
1402       config->cfg.kf\_max\_dist = arg\_parse\_uint(&arg);
1403     \} \textcolor{keywordflow}{else} \textcolor{keywordflow}{if} (arg\_match(&arg, &kf\_disabled, argi)) \{
1404       config->cfg.kf\_mode = \hyperlink{group__encoder_ggac0498fc02cd368e6d9675cdb0bab5a84af81473ffe0169271763f9c9d05393405}{AOM\_KF\_DISABLED};
1405     \} \textcolor{keywordflow}{else} \textcolor{keywordflow}{if} (arg\_match(&arg, &sframe\_dist, argi)) \{
1406       config->cfg.sframe\_dist = arg\_parse\_uint(&arg);
1407     \} \textcolor{keywordflow}{else} \textcolor{keywordflow}{if} (arg\_match(&arg, &sframe\_mode, argi)) \{
1408       config->cfg.sframe\_mode = arg\_parse\_uint(&arg);
1409     \} \textcolor{keywordflow}{else} \textcolor{keywordflow}{if} (arg\_match(&arg, &save\_as\_annexb, argi)) \{
1410       config->cfg.save\_as\_annexb = arg\_parse\_uint(&arg);
1411     \} \textcolor{keywordflow}{else} \textcolor{keywordflow}{if} (arg\_match(&arg, &tile\_width, argi)) \{
1412       config->cfg.tile\_width\_count =
1413           arg\_parse\_list(&arg, config->cfg.tile\_widths, \hyperlink{aom__encoder_8h_a3ec4904ea175471a03d10705f384d07c}{MAX\_TILE\_WIDTHS});
1414     \} \textcolor{keywordflow}{else} \textcolor{keywordflow}{if} (arg\_match(&arg, &tile\_height, argi)) \{
1415       config->cfg.tile\_height\_count =
1416           arg\_parse\_list(&arg, config->cfg.tile\_heights, \hyperlink{aom__encoder_8h_a446aae868ff07f3971d9e84b6602a890}{MAX\_TILE\_HEIGHTS});
1417 \textcolor{preprocessor}{#if CONFIG\_FILEOPTIONS}
1418     \} \textcolor{keywordflow}{else} \textcolor{keywordflow}{if} (arg\_match(&arg, &ext\_partition, argi)) \{
1419       config->cfg.cfg.ext\_partition = !!arg\_parse\_uint(&arg) > 0;
1420 \textcolor{preprocessor}{#endif}
1421     \} \textcolor{keywordflow}{else} \{
1422       \textcolor{keywordtype}{int} i, match = 0;
1423       \textcolor{keywordflow}{for} (i = 0; ctrl\_args[i]; i++) \{
1424         \textcolor{keywordflow}{if} (arg\_match(&arg, ctrl\_args[i], argi)) \{
1425           match = 1;
1426           \textcolor{keywordflow}{if} (ctrl\_args\_map) \{
1427             set\_config\_arg\_ctrls(config, ctrl\_args\_map[i], &arg);
1428           \}
1429         \}
1430       \}
1431       \textcolor{keywordflow}{if} (!match) argj++;
1432     \}
1433   \}
1434   config->use\_16bit\_internal =
1435       config->cfg.g\_bit\_depth > \hyperlink{group__codec_gga6ed0e98eba4651c1ad845e39498e4153a4c7f55539160206a3fbb2a6cfc9ef89c}{AOM\_BITS\_8} || !CONFIG\_LOWBITDEPTH;
1436   \textcolor{keywordflow}{return} eos\_mark\_found;
1437 \}
1438 
1439 \textcolor{preprocessor}{#define FOREACH\_STREAM(iterator, list)                 \(\backslash\)}
1440 \textcolor{preprocessor}{  for (struct stream\_state *iterator = list; iterator; \(\backslash\)}
1441 \textcolor{preprocessor}{       iterator = iterator->next)}
1442 
1443 \textcolor{keyword}{static} \textcolor{keywordtype}{void} validate\_stream\_config(\textcolor{keyword}{const} \textcolor{keyword}{struct} stream\_state *stream,
1444                                    \textcolor{keyword}{const} \textcolor{keyword}{struct} AvxEncoderConfig *global) \{
1445   \textcolor{keyword}{const} \textcolor{keyword}{struct }stream\_state *streami;
1446   (void)global;
1447 
1448   \textcolor{keywordflow}{if} (!stream->config.cfg.g\_w || !stream->config.cfg.g\_h)
1449     fatal(
1450         \textcolor{stringliteral}{"Stream %d: Specify stream dimensions with --width (-w) "}
1451         \textcolor{stringliteral}{" and --height (-h)"},
1452         stream->index);
1453 
1454   \textcolor{comment}{/* Even if bit depth is set on the command line flag to be lower,}
1455 \textcolor{comment}{   * it is upgraded to at least match the input bit depth.}
1456 \textcolor{comment}{   */}
1457   assert(stream->config.cfg.g\_input\_bit\_depth <=
1458          (\textcolor{keywordtype}{unsigned} \textcolor{keywordtype}{int})stream->config.cfg.g\_bit\_depth);
1459 
1460   \textcolor{keywordflow}{for} (streami = stream; streami; streami = streami->next) \{
1461     \textcolor{comment}{/* All streams require output files */}
1462     \textcolor{keywordflow}{if} (!streami->config.out\_fn)
1463       fatal(\textcolor{stringliteral}{"Stream %d: Output file is required (specify with -o)"},
1464             streami->index);
1465 
1466     \textcolor{comment}{/* Check for two streams outputting to the same file */}
1467     \textcolor{keywordflow}{if} (streami != stream) \{
1468       \textcolor{keyword}{const} \textcolor{keywordtype}{char} *a = stream->config.out\_fn;
1469       \textcolor{keyword}{const} \textcolor{keywordtype}{char} *b = streami->config.out\_fn;
1470       \textcolor{keywordflow}{if} (!strcmp(a, b) && strcmp(a, \textcolor{stringliteral}{"/dev/null"}) && strcmp(a, \textcolor{stringliteral}{":nul"}))
1471         fatal(\textcolor{stringliteral}{"Stream %d: duplicate output file (from stream %d)"},
1472               streami->index, stream->index);
1473     \}
1474 
1475     \textcolor{comment}{/* Check for two streams sharing a stats file. */}
1476     \textcolor{keywordflow}{if} (streami != stream) \{
1477       \textcolor{keyword}{const} \textcolor{keywordtype}{char} *a = stream->config.stats\_fn;
1478       \textcolor{keyword}{const} \textcolor{keywordtype}{char} *b = streami->config.stats\_fn;
1479       \textcolor{keywordflow}{if} (a && b && !strcmp(a, b))
1480         fatal(\textcolor{stringliteral}{"Stream %d: duplicate stats file (from stream %d)"},
1481               streami->index, stream->index);
1482     \}
1483 
1484 \textcolor{preprocessor}{#if CONFIG\_FP\_MB\_STATS}
1485     \textcolor{comment}{/* Check for two streams sharing a mb stats file. */}
1486     \textcolor{keywordflow}{if} (streami != stream) \{
1487       \textcolor{keyword}{const} \textcolor{keywordtype}{char} *a = stream->config.fpmb\_stats\_fn;
1488       \textcolor{keyword}{const} \textcolor{keywordtype}{char} *b = streami->config.fpmb\_stats\_fn;
1489       \textcolor{keywordflow}{if} (a && b && !strcmp(a, b))
1490         fatal(\textcolor{stringliteral}{"Stream %d: duplicate mb stats file (from stream %d)"},
1491               streami->index, stream->index);
1492     \}
1493 \textcolor{preprocessor}{#endif}
1494   \}
1495 \}
1496 
1497 \textcolor{keyword}{static} \textcolor{keywordtype}{void} set\_stream\_dimensions(\textcolor{keyword}{struct} stream\_state *stream, \textcolor{keywordtype}{unsigned} \textcolor{keywordtype}{int} w,
1498                                   \textcolor{keywordtype}{unsigned} \textcolor{keywordtype}{int} h) \{
1499   \textcolor{keywordflow}{if} (!stream->config.cfg.g\_w) \{
1500     \textcolor{keywordflow}{if} (!stream->config.cfg.g\_h)
1501       stream->config.cfg.g\_w = w;
1502     \textcolor{keywordflow}{else}
1503       stream->config.cfg.g\_w = w * stream->config.cfg.g\_h / h;
1504   \}
1505   \textcolor{keywordflow}{if} (!stream->config.cfg.g\_h) \{
1506     stream->config.cfg.g\_h = h * stream->config.cfg.g\_w / w;
1507   \}
1508 \}
1509 
1510 \textcolor{keyword}{static} \textcolor{keyword}{const} \textcolor{keywordtype}{char} *file\_type\_to\_string(\textcolor{keyword}{enum} VideoFileType t) \{
1511   \textcolor{keywordflow}{switch} (t) \{
1512     \textcolor{keywordflow}{case} FILE\_TYPE\_RAW: \textcolor{keywordflow}{return} \textcolor{stringliteral}{"RAW"};
1513     \textcolor{keywordflow}{case} FILE\_TYPE\_Y4M: \textcolor{keywordflow}{return} \textcolor{stringliteral}{"Y4M"};
1514     \textcolor{keywordflow}{default}: \textcolor{keywordflow}{return} \textcolor{stringliteral}{"Other"};
1515   \}
1516 \}
1517 
1518 \textcolor{keyword}{static} \textcolor{keyword}{const} \textcolor{keywordtype}{char} *image\_format\_to\_string(\hyperlink{aom__image_8h_ab71efff8c7f49380fad23b93bc2e9bfc}{aom\_img\_fmt\_t} f) \{
1519   \textcolor{keywordflow}{switch} (f) \{
1520     \textcolor{keywordflow}{case} \hyperlink{aom__image_8h_a930317c04b4bd0a660bb5e744055523cabd778a3d697463e89d12a1117f417b60}{AOM\_IMG\_FMT\_I420}: \textcolor{keywordflow}{return} \textcolor{stringliteral}{"I420"};
1521     \textcolor{keywordflow}{case} \hyperlink{aom__image_8h_a930317c04b4bd0a660bb5e744055523cab2f75281e94ebc0f0bc728ef287cd3e8}{AOM\_IMG\_FMT\_I422}: \textcolor{keywordflow}{return} \textcolor{stringliteral}{"I422"};
1522     \textcolor{keywordflow}{case} \hyperlink{aom__image_8h_a930317c04b4bd0a660bb5e744055523ca89d423506e948ab7d3b98b5750b92655}{AOM\_IMG\_FMT\_I444}: \textcolor{keywordflow}{return} \textcolor{stringliteral}{"I444"};
1523     \textcolor{keywordflow}{case} \hyperlink{aom__image_8h_a930317c04b4bd0a660bb5e744055523cad28244100a2754409f285b77a3db90a0}{AOM\_IMG\_FMT\_YV12}: \textcolor{keywordflow}{return} \textcolor{stringliteral}{"YV12"};
1524     \textcolor{keywordflow}{case} \hyperlink{aom__image_8h_a930317c04b4bd0a660bb5e744055523ca6d845490a6333fca3ac22cc1105deadd}{AOM\_IMG\_FMT\_YV1216}: \textcolor{keywordflow}{return} \textcolor{stringliteral}{"YV1216"};
1525     \textcolor{keywordflow}{case} \hyperlink{aom__image_8h_a930317c04b4bd0a660bb5e744055523ca20a9cf30277260685642b4cfb4e9273b}{AOM\_IMG\_FMT\_I42016}: \textcolor{keywordflow}{return} \textcolor{stringliteral}{"I42016"};
1526     \textcolor{keywordflow}{case} \hyperlink{aom__image_8h_a930317c04b4bd0a660bb5e744055523ca064683ed4260fc6244af6cfc9d261c22}{AOM\_IMG\_FMT\_I42216}: \textcolor{keywordflow}{return} \textcolor{stringliteral}{"I42216"};
1527     \textcolor{keywordflow}{case} \hyperlink{aom__image_8h_a930317c04b4bd0a660bb5e744055523cab9b93d397dedbdd6bfafec84d1f8f0f5}{AOM\_IMG\_FMT\_I44416}: \textcolor{keywordflow}{return} \textcolor{stringliteral}{"I44416"};
1528     \textcolor{keywordflow}{default}: \textcolor{keywordflow}{return} \textcolor{stringliteral}{"Other"};
1529   \}
1530 \}
1531 
1532 \textcolor{keyword}{static} \textcolor{keywordtype}{void} show\_stream\_config(\textcolor{keyword}{struct} stream\_state *stream,
1533                                \textcolor{keyword}{struct} AvxEncoderConfig *global,
1534                                \textcolor{keyword}{struct} AvxInputContext *input) \{
1535 \textcolor{preprocessor}{#define SHOW(field) \(\backslash\)}
1536 \textcolor{preprocessor}{  fprintf(stderr, "    %-28s = %d\(\backslash\)n", #field, stream->config.cfg.field)}
1537 
1538   \textcolor{keywordflow}{if} (stream->index == 0) \{
1539     fprintf(stderr, \textcolor{stringliteral}{"Codec: %s\(\backslash\)n"},
1540             \hyperlink{group__codec_ga013b1f6d96b2cf9489396311a7e5179b}{aom\_codec\_iface\_name}(global->codec->codec\_interface()));
1541     fprintf(stderr, \textcolor{stringliteral}{"Source file: %s File Type: %s Format: %s\(\backslash\)n"},
1542             input->filename, file\_type\_to\_string(input->file\_type),
1543             image\_format\_to\_string(input->fmt));
1544   \}
1545   \textcolor{keywordflow}{if} (stream->next || stream->index)
1546     fprintf(stderr, \textcolor{stringliteral}{"\(\backslash\)nStream Index: %d\(\backslash\)n"}, stream->index);
1547   fprintf(stderr, \textcolor{stringliteral}{"Destination file: %s\(\backslash\)n"}, stream->config.out\_fn);
1548   fprintf(stderr, \textcolor{stringliteral}{"Coding path: %s\(\backslash\)n"},
1549           stream->config.use\_16bit\_internal ? \textcolor{stringliteral}{"HBD"} : \textcolor{stringliteral}{"LBD"});
1550   fprintf(stderr, \textcolor{stringliteral}{"Encoder parameters:\(\backslash\)n"});
1551 
1552   SHOW(g\_usage);
1553   SHOW(g\_threads);
1554   SHOW(g\_profile);
1555   SHOW(g\_w);
1556   SHOW(g\_h);
1557   SHOW(g\_bit\_depth);
1558   SHOW(g\_input\_bit\_depth);
1559   SHOW(g\_timebase.num);
1560   SHOW(g\_timebase.den);
1561   SHOW(g\_error\_resilient);
1562   SHOW(g\_pass);
1563   SHOW(g\_lag\_in\_frames);
1564   SHOW(large\_scale\_tile);
1565   SHOW(rc\_dropframe\_thresh);
1566   SHOW(rc\_resize\_mode);
1567   SHOW(rc\_resize\_denominator);
1568   SHOW(rc\_resize\_kf\_denominator);
1569   SHOW(rc\_superres\_mode);
1570   SHOW(rc\_superres\_denominator);
1571   SHOW(rc\_superres\_kf\_denominator);
1572   SHOW(rc\_superres\_qthresh);
1573   SHOW(rc\_superres\_kf\_qthresh);
1574   SHOW(rc\_end\_usage);
1575   SHOW(rc\_target\_bitrate);
1576   SHOW(rc\_min\_quantizer);
1577   SHOW(rc\_max\_quantizer);
1578   SHOW(rc\_undershoot\_pct);
1579   SHOW(rc\_overshoot\_pct);
1580   SHOW(rc\_buf\_sz);
1581   SHOW(rc\_buf\_initial\_sz);
1582   SHOW(rc\_buf\_optimal\_sz);
1583   SHOW(rc\_2pass\_vbr\_bias\_pct);
1584   SHOW(rc\_2pass\_vbr\_minsection\_pct);
1585   SHOW(rc\_2pass\_vbr\_maxsection\_pct);
1586   SHOW(fwd\_kf\_enabled);
1587   SHOW(kf\_mode);
1588   SHOW(kf\_min\_dist);
1589   SHOW(kf\_max\_dist);
1590 \}
1591 
1592 \textcolor{keyword}{static} \textcolor{keywordtype}{void} open\_output\_file(\textcolor{keyword}{struct} stream\_state *stream,
1593                              \textcolor{keyword}{struct} AvxEncoderConfig *global,
1594                              \textcolor{keyword}{const} \textcolor{keyword}{struct} AvxRational *pixel\_aspect\_ratio) \{
1595   \textcolor{keyword}{const} \textcolor{keywordtype}{char} *fn = stream->config.out\_fn;
1596   \textcolor{keyword}{const} \textcolor{keyword}{struct }\hyperlink{structaom__codec__enc__cfg}{aom\_codec\_enc\_cfg} *\textcolor{keyword}{const} cfg = &stream->config.cfg;
1597 
1598   \textcolor{keywordflow}{if} (cfg->\hyperlink{structaom__codec__enc__cfg_aad58e4d10c7904d50ce959aef202dc64}{g\_pass} == \hyperlink{group__encoder_gga92b6709b58dc3435e3ba652da562eda1ad342b33a290482c20238bfde5d9bea1e}{AOM\_RC\_FIRST\_PASS}) \textcolor{keywordflow}{return};
1599 
1600   stream->file = strcmp(fn, \textcolor{stringliteral}{"-"}) ? fopen(fn, \textcolor{stringliteral}{"wb"}) : set\_binary\_mode(stdout);
1601 
1602   \textcolor{keywordflow}{if} (!stream->file) fatal(\textcolor{stringliteral}{"Failed to open output file"});
1603 
1604   \textcolor{keywordflow}{if} (stream->config.write\_webm && fseek(stream->file, 0, SEEK\_CUR))
1605     fatal(\textcolor{stringliteral}{"WebM output to pipes not supported."});
1606 
1607 \textcolor{preprocessor}{#if CONFIG\_WEBM\_IO}
1608   \textcolor{keywordflow}{if} (stream->config.write\_webm) \{
1609     stream->webm\_ctx.stream = stream->file;
1610     \textcolor{keywordflow}{if} (write\_webm\_file\_header(&stream->webm\_ctx, &stream->encoder, cfg,
1611                                stream->config.stereo\_fmt, global->codec->fourcc,
1612                                pixel\_aspect\_ratio) != 0) \{
1613       fatal(\textcolor{stringliteral}{"WebM writer initialization failed."});
1614     \}
1615   \}
1616 \textcolor{preprocessor}{#else}
1617   (void)pixel\_aspect\_ratio;
1618 \textcolor{preprocessor}{#endif}
1619 
1620   \textcolor{keywordflow}{if} (!stream->config.write\_webm && stream->config.write\_ivf) \{
1621     ivf\_write\_file\_header(stream->file, cfg, global->codec->fourcc, 0);
1622   \}
1623 \}
1624 
1625 \textcolor{keyword}{static} \textcolor{keywordtype}{void} close\_output\_file(\textcolor{keyword}{struct} stream\_state *stream,
1626                               \textcolor{keywordtype}{unsigned} \textcolor{keywordtype}{int} fourcc) \{
1627   \textcolor{keyword}{const} \textcolor{keyword}{struct }\hyperlink{structaom__codec__enc__cfg}{aom\_codec\_enc\_cfg} *\textcolor{keyword}{const} cfg = &stream->config.cfg;
1628 
1629   \textcolor{keywordflow}{if} (cfg->\hyperlink{structaom__codec__enc__cfg_aad58e4d10c7904d50ce959aef202dc64}{g\_pass} == \hyperlink{group__encoder_gga92b6709b58dc3435e3ba652da562eda1ad342b33a290482c20238bfde5d9bea1e}{AOM\_RC\_FIRST\_PASS}) \textcolor{keywordflow}{return};
1630 
1631 \textcolor{preprocessor}{#if CONFIG\_WEBM\_IO}
1632   \textcolor{keywordflow}{if} (stream->config.write\_webm) \{
1633     \textcolor{keywordflow}{if} (write\_webm\_file\_footer(&stream->webm\_ctx) != 0) \{
1634       fatal(\textcolor{stringliteral}{"WebM writer finalization failed."});
1635     \}
1636   \}
1637 \textcolor{preprocessor}{#endif}
1638 
1639   \textcolor{keywordflow}{if} (!stream->config.write\_webm && stream->config.write\_ivf) \{
1640     \textcolor{keywordflow}{if} (!fseek(stream->file, 0, SEEK\_SET))
1641       ivf\_write\_file\_header(stream->file, &stream->config.cfg, fourcc,
1642                             stream->frames\_out);
1643   \}
1644 
1645   fclose(stream->file);
1646 \}
1647 
1648 \textcolor{keyword}{static} \textcolor{keywordtype}{void} setup\_pass(\textcolor{keyword}{struct} stream\_state *stream,
1649                        \textcolor{keyword}{struct} AvxEncoderConfig *global, \textcolor{keywordtype}{int} pass) \{
1650   \textcolor{keywordflow}{if} (stream->config.stats\_fn) \{
1651     \textcolor{keywordflow}{if} (!stats\_open\_file(&stream->stats, stream->config.stats\_fn, pass))
1652       fatal(\textcolor{stringliteral}{"Failed to open statistics store"});
1653   \} \textcolor{keywordflow}{else} \{
1654     \textcolor{keywordflow}{if} (!stats\_open\_mem(&stream->stats, pass))
1655       fatal(\textcolor{stringliteral}{"Failed to open statistics store"});
1656   \}
1657 
1658 \textcolor{preprocessor}{#if CONFIG\_FP\_MB\_STATS}
1659   \textcolor{keywordflow}{if} (stream->config.fpmb\_stats\_fn) \{
1660     \textcolor{keywordflow}{if} (!stats\_open\_file(&stream->fpmb\_stats, stream->config.fpmb\_stats\_fn,
1661                          pass))
1662       fatal(\textcolor{stringliteral}{"Failed to open mb statistics store"});
1663   \} \textcolor{keywordflow}{else} \{
1664     \textcolor{keywordflow}{if} (!stats\_open\_mem(&stream->fpmb\_stats, pass))
1665       fatal(\textcolor{stringliteral}{"Failed to open mb statistics store"});
1666   \}
1667 \textcolor{preprocessor}{#endif}
1668 
1669   stream->config.cfg.g\_pass = global->passes == 2
1670                                   ? pass ? \hyperlink{group__encoder_gga92b6709b58dc3435e3ba652da562eda1a621c3f07937527618dc06e962425f6cc}{AOM\_RC\_LAST\_PASS} : 
      \hyperlink{group__encoder_gga92b6709b58dc3435e3ba652da562eda1ad342b33a290482c20238bfde5d9bea1e}{AOM\_RC\_FIRST\_PASS}
1671                                   : \hyperlink{group__encoder_gga92b6709b58dc3435e3ba652da562eda1a1b4b8ee9c1910fc59ac9dfd9700f3f02}{AOM\_RC\_ONE\_PASS};
1672   \textcolor{keywordflow}{if} (pass) \{
1673     stream->config.cfg.rc\_twopass\_stats\_in = stats\_get(&stream->stats);
1674 \textcolor{preprocessor}{#if CONFIG\_FP\_MB\_STATS}
1675     stream->config.cfg.rc\_firstpass\_mb\_stats\_in =
1676         stats\_get(&stream->fpmb\_stats);
1677 \textcolor{preprocessor}{#endif}
1678   \}
1679 
1680   stream->cx\_time = 0;
1681   stream->nbytes = 0;
1682   stream->frames\_out = 0;
1683 \}
1684 
1685 \textcolor{keyword}{static} \textcolor{keywordtype}{void} initialize\_encoder(\textcolor{keyword}{struct} stream\_state *stream,
1686                                \textcolor{keyword}{struct} AvxEncoderConfig *global) \{
1687   \textcolor{keywordtype}{int} i;
1688   \textcolor{keywordtype}{int} flags = 0;
1689 
1690   flags |= global->show\_psnr ? \hyperlink{group__encoder_gae722c9f9ba9b4ca8dba6bbe7c0692024}{AOM\_CODEC\_USE\_PSNR} : 0;
1691   flags |= stream->config.use\_16bit\_internal ? \hyperlink{group__encoder_gae30bbbdef18e9da3631b69c170533e92}{AOM\_CODEC\_USE\_HIGHBITDEPTH} : 0;
1692 
1693   \textcolor{comment}{/* Construct Encoder Context */}
1694   \hyperlink{group__encoder_gaade68a7d33d30f97dc9a596aa5e065d8}{aom\_codec\_enc\_init}(&stream->encoder, global->codec->codec\_interface(),
1695                      &stream->config.cfg, flags);
1696   ctx\_exit\_on\_error(&stream->encoder, \textcolor{stringliteral}{"Failed to initialize encoder"});
1697 
1698   \textcolor{comment}{/* Note that we bypass the aom\_codec\_control wrapper macro because}
1699 \textcolor{comment}{   * we're being clever to store the control IDs in an array. Real}
1700 \textcolor{comment}{   * applications will want to make use of the enumerations directly}
1701 \textcolor{comment}{   */}
1702   \textcolor{keywordflow}{for} (i = 0; i < stream->config.arg\_ctrl\_cnt; i++) \{
1703     \textcolor{keywordtype}{int} ctrl = stream->config.arg\_ctrls[i][0];
1704     \textcolor{keywordtype}{int} value = stream->config.arg\_ctrls[i][1];
1705     \textcolor{keywordflow}{if} (\hyperlink{group__codec_ga51eb332a40dcacc39000ab8e0be36b79}{aom\_codec\_control\_}(&stream->encoder, ctrl, value))
1706       fprintf(stderr, \textcolor{stringliteral}{"Error: Tried to set control %d = %d\(\backslash\)n"}, ctrl, value);
1707 
1708     ctx\_exit\_on\_error(&stream->encoder, \textcolor{stringliteral}{"Failed to control codec"});
1709   \}
1710   \textcolor{keywordflow}{if} (stream->config.film\_grain\_filename) \{
1711     \hyperlink{group__codec_ga51eb332a40dcacc39000ab8e0be36b79}{aom\_codec\_control\_}(&stream->encoder, 
      \hyperlink{group__aom__encoder_ggae78dde67a6d78f332e9bdba0dde42db5ad5846c6f49d37e65a03c39e68d487097}{AV1E\_SET\_FILM\_GRAIN\_TABLE},
1712                        stream->config.film\_grain\_filename);
1713   \}
1714 
1715 \textcolor{preprocessor}{#if CONFIG\_AV1\_DECODER}
1716   \textcolor{keywordflow}{if} (global->test\_decode != TEST\_DECODE\_OFF) \{
1717     \textcolor{keyword}{const} AvxInterface *decoder = get\_aom\_decoder\_by\_name(global->codec->name);
1718     \hyperlink{structaom__codec__dec__cfg}{aom\_codec\_dec\_cfg\_t} cfg = \{ 0, 0, 0, CONFIG\_LOWBITDEPTH, \{ 1 \} \};
1719     \hyperlink{group__decoder_gafdbfca65b19ab1f6d72b32cd01753b9b}{aom\_codec\_dec\_init}(&stream->decoder, decoder->codec\_interface(), &
      \hyperlink{structaom__codec__enc__cfg_a91c4b8e91211a9cea98a8003ef2e4e65}{cfg}, 0);
1720 
1721     \textcolor{keywordflow}{if} (strcmp(global->codec->name, \textcolor{stringliteral}{"av1"}) == 0) \{
1722       \hyperlink{group__codec_ga6da974f4eeaba1fa74106b28d0fe6ac5}{aom\_codec\_control}(&stream->decoder, \hyperlink{group__aom__decoder_gga3865fd4b3192489baa9a5c3632ebe97ba0795d8084ae8c78528c01587198df9e2}{AV1\_SET\_TILE\_MODE},
1723                         stream->config.cfg.large\_scale\_tile);
1724       ctx\_exit\_on\_error(&stream->decoder, \textcolor{stringliteral}{"Failed to set decode\_tile\_mode"});
1725 
1726       \hyperlink{group__codec_ga6da974f4eeaba1fa74106b28d0fe6ac5}{aom\_codec\_control}(&stream->decoder, \hyperlink{group__aom__decoder_gga3865fd4b3192489baa9a5c3632ebe97ba1fb269c5c5913d9995b6c35d28e2a788}{AV1D\_SET\_IS\_ANNEXB},
1727                         stream->config.cfg.save\_as\_annexb);
1728       ctx\_exit\_on\_error(&stream->decoder, \textcolor{stringliteral}{"Failed to set is\_annexb"});
1729 
1730       \hyperlink{group__codec_ga6da974f4eeaba1fa74106b28d0fe6ac5}{aom\_codec\_control}(&stream->decoder, 
      \hyperlink{group__aom__decoder_gga3865fd4b3192489baa9a5c3632ebe97bac056b4cf80427fd05e3c4c9fc46edb78}{AV1\_SET\_DECODE\_TILE\_ROW}, -1);
1731       ctx\_exit\_on\_error(&stream->decoder, \textcolor{stringliteral}{"Failed to set decode\_tile\_row"});
1732 
1733       \hyperlink{group__codec_ga6da974f4eeaba1fa74106b28d0fe6ac5}{aom\_codec\_control}(&stream->decoder, AV1\_SET\_DECODE\_TILE\_COL, -1);
1734       ctx\_exit\_on\_error(&stream->decoder, \textcolor{stringliteral}{"Failed to set decode\_tile\_col"});
1735     \}
1736   \}
1737 \textcolor{preprocessor}{#endif}
1738 \}
1739 
1740 \textcolor{keyword}{static} \textcolor{keywordtype}{void} encode\_frame(\textcolor{keyword}{struct} stream\_state *stream,
1741                          \textcolor{keyword}{struct} AvxEncoderConfig *global, \textcolor{keyword}{struct} \hyperlink{structaom__image}{aom\_image} *img,
1742                          \textcolor{keywordtype}{unsigned} \textcolor{keywordtype}{int} frames\_in) \{
1743   \hyperlink{group__encoder_ga958524226c9a65251c9e4f7bb78fc606}{aom\_codec\_pts\_t} frame\_start, next\_frame\_start;
1744   \textcolor{keyword}{struct }\hyperlink{structaom__codec__enc__cfg}{aom\_codec\_enc\_cfg} *cfg = &stream->config.cfg;
1745   \textcolor{keyword}{struct }aom\_usec\_timer timer;
1746 
1747   frame\_start =
1748       (cfg->\hyperlink{structaom__codec__enc__cfg_a10664f1fc5b6ec29b77ee13efeeecdf7}{g\_timebase}.\hyperlink{structaom__rational_adeddf2ea01c12b7be66536e0a0fb92c5}{den} * (int64\_t)(frames\_in - 1) * global->framerate.den) /
1749       cfg->\hyperlink{structaom__codec__enc__cfg_a10664f1fc5b6ec29b77ee13efeeecdf7}{g\_timebase}.\hyperlink{structaom__rational_a7b48174411798c780a15f132c4650839}{num} / global->framerate.num;
1750   next\_frame\_start =
1751       (cfg->\hyperlink{structaom__codec__enc__cfg_a10664f1fc5b6ec29b77ee13efeeecdf7}{g\_timebase}.\hyperlink{structaom__rational_adeddf2ea01c12b7be66536e0a0fb92c5}{den} * (int64\_t)(frames\_in)*global->framerate.den) /
1752       cfg->\hyperlink{structaom__codec__enc__cfg_a10664f1fc5b6ec29b77ee13efeeecdf7}{g\_timebase}.\hyperlink{structaom__rational_a7b48174411798c780a15f132c4650839}{num} / global->framerate.num;
1753 
1754   \textcolor{comment}{/* Scale if necessary */}
1755   \textcolor{keywordflow}{if} (img) \{
1756     \textcolor{keywordflow}{if} ((img->\hyperlink{structaom__image_a6c64b1ab918d80d52eb8f5d6d957e825}{fmt} & \hyperlink{aom__image_8h_a607b37d91f75442f54223ecd85f1b6cb}{AOM\_IMG\_FMT\_HIGHBITDEPTH}) &&
1757         (img->\hyperlink{structaom__image_a89f80b1f58d608b9d2080635f4359034}{d\_w} != cfg->\hyperlink{structaom__codec__enc__cfg_a80cb459c5ef3c7e1516f617c4c9d6eab}{g\_w} || img->\hyperlink{structaom__image_ab986419a1f0fff93a2dc505f47194988}{d\_h} != cfg->\hyperlink{structaom__codec__enc__cfg_a37b0f57b63bec8d133df8901d4407ee6}{g\_h})) \{
1758       \textcolor{keywordflow}{if} (img->\hyperlink{structaom__image_a6c64b1ab918d80d52eb8f5d6d957e825}{fmt} != \hyperlink{aom__image_8h_a930317c04b4bd0a660bb5e744055523ca20a9cf30277260685642b4cfb4e9273b}{AOM\_IMG\_FMT\_I42016}) \{
1759         fprintf(stderr, \textcolor{stringliteral}{"%s can only scale 4:2:0 inputs\(\backslash\)n"}, exec\_name);
1760         exit(EXIT\_FAILURE);
1761       \}
1762 \textcolor{preprocessor}{#if CONFIG\_LIBYUV}
1763       \textcolor{keywordflow}{if} (!stream->img) \{
1764         stream->img =
1765             \hyperlink{aom__image_8h_a570db29fbd122951235a08fe9375f6bb}{aom\_img\_alloc}(NULL, \hyperlink{aom__image_8h_a930317c04b4bd0a660bb5e744055523ca20a9cf30277260685642b4cfb4e9273b}{AOM\_IMG\_FMT\_I42016}, cfg->
      \hyperlink{structaom__codec__enc__cfg_a80cb459c5ef3c7e1516f617c4c9d6eab}{g\_w}, cfg->\hyperlink{structaom__codec__enc__cfg_a37b0f57b63bec8d133df8901d4407ee6}{g\_h}, 16);
1766       \}
1767       I420Scale\_16(
1768           (uint16\_t *)img->\hyperlink{structaom__image_ac54dbc5237ca2914f9ec30105dfbe302}{planes}[\hyperlink{aom__image_8h_a2ad22076006b15cf809edcaa33f6d339}{AOM\_PLANE\_Y}], img->\hyperlink{structaom__image_a6dc693d7dbc9eb06c0cdde307ca58372}{stride}[
      \hyperlink{aom__image_8h_a2ad22076006b15cf809edcaa33f6d339}{AOM\_PLANE\_Y}] / 2,
1769           (uint16\_t *)img->\hyperlink{structaom__image_ac54dbc5237ca2914f9ec30105dfbe302}{planes}[AOM\_PLANE\_U], img->\hyperlink{structaom__image_a6dc693d7dbc9eb06c0cdde307ca58372}{stride}[AOM\_PLANE\_U] / 2,
1770           (uint16\_t *)img->\hyperlink{structaom__image_ac54dbc5237ca2914f9ec30105dfbe302}{planes}[AOM\_PLANE\_V], img->\hyperlink{structaom__image_a6dc693d7dbc9eb06c0cdde307ca58372}{stride}[AOM\_PLANE\_V] / 2,
1771           img->\hyperlink{structaom__image_a89f80b1f58d608b9d2080635f4359034}{d\_w}, img->\hyperlink{structaom__image_ab986419a1f0fff93a2dc505f47194988}{d\_h}, (uint16\_t *)stream->img->planes[\hyperlink{aom__image_8h_a2ad22076006b15cf809edcaa33f6d339}{AOM\_PLANE\_Y}],
1772           stream->img->stride[\hyperlink{aom__image_8h_a2ad22076006b15cf809edcaa33f6d339}{AOM\_PLANE\_Y}] / 2,
1773           (uint16\_t *)stream->img->planes[AOM\_PLANE\_U],
1774           stream->img->stride[AOM\_PLANE\_U] / 2,
1775           (uint16\_t *)stream->img->planes[AOM\_PLANE\_V],
1776           stream->img->stride[AOM\_PLANE\_V] / 2, stream->img->d\_w,
1777           stream->img->d\_h, kFilterBox);
1778       img = stream->img;
1779 \textcolor{preprocessor}{#else}
1780       stream->encoder.err = 1;
1781       ctx\_exit\_on\_error(&stream->encoder,
1782                         \textcolor{stringliteral}{"Stream %d: Failed to encode frame.\(\backslash\)n"}
1783                         \textcolor{stringliteral}{"libyuv is required for scaling but is currently "}
1784                         \textcolor{stringliteral}{"disabled.\(\backslash\)n"}
1785                         \textcolor{stringliteral}{"Be sure to specify -DCONFIG\_LIBYUV=1 when running "}
1786                         \textcolor{stringliteral}{"cmake.\(\backslash\)n"},
1787                         stream->index);
1788 \textcolor{preprocessor}{#endif}
1789     \}
1790   \}
1791   \textcolor{keywordflow}{if} (img && (img->\hyperlink{structaom__image_a89f80b1f58d608b9d2080635f4359034}{d\_w} != cfg->\hyperlink{structaom__codec__enc__cfg_a80cb459c5ef3c7e1516f617c4c9d6eab}{g\_w} || img->\hyperlink{structaom__image_ab986419a1f0fff93a2dc505f47194988}{d\_h} != cfg->\hyperlink{structaom__codec__enc__cfg_a37b0f57b63bec8d133df8901d4407ee6}{g\_h})) \{
1792     \textcolor{keywordflow}{if} (img->\hyperlink{structaom__image_a6c64b1ab918d80d52eb8f5d6d957e825}{fmt} != \hyperlink{aom__image_8h_a930317c04b4bd0a660bb5e744055523cabd778a3d697463e89d12a1117f417b60}{AOM\_IMG\_FMT\_I420} && img->\hyperlink{structaom__image_a6c64b1ab918d80d52eb8f5d6d957e825}{fmt} != 
      \hyperlink{aom__image_8h_a930317c04b4bd0a660bb5e744055523cad28244100a2754409f285b77a3db90a0}{AOM\_IMG\_FMT\_YV12}) \{
1793       fprintf(stderr, \textcolor{stringliteral}{"%s can only scale 4:2:0 8bpp inputs\(\backslash\)n"}, exec\_name);
1794       exit(EXIT\_FAILURE);
1795     \}
1796 \textcolor{preprocessor}{#if CONFIG\_LIBYUV}
1797     \textcolor{keywordflow}{if} (!stream->img)
1798       stream->img =
1799           \hyperlink{aom__image_8h_a570db29fbd122951235a08fe9375f6bb}{aom\_img\_alloc}(NULL, \hyperlink{aom__image_8h_a930317c04b4bd0a660bb5e744055523cabd778a3d697463e89d12a1117f417b60}{AOM\_IMG\_FMT\_I420}, cfg->
      \hyperlink{structaom__codec__enc__cfg_a80cb459c5ef3c7e1516f617c4c9d6eab}{g\_w}, cfg->\hyperlink{structaom__codec__enc__cfg_a37b0f57b63bec8d133df8901d4407ee6}{g\_h}, 16);
1800     I420Scale(
1801         img->\hyperlink{structaom__image_ac54dbc5237ca2914f9ec30105dfbe302}{planes}[\hyperlink{aom__image_8h_a2ad22076006b15cf809edcaa33f6d339}{AOM\_PLANE\_Y}], img->\hyperlink{structaom__image_a6dc693d7dbc9eb06c0cdde307ca58372}{stride}[\hyperlink{aom__image_8h_a2ad22076006b15cf809edcaa33f6d339}{AOM\_PLANE\_Y}],
1802         img->\hyperlink{structaom__image_ac54dbc5237ca2914f9ec30105dfbe302}{planes}[AOM\_PLANE\_U], img->\hyperlink{structaom__image_a6dc693d7dbc9eb06c0cdde307ca58372}{stride}[AOM\_PLANE\_U],
1803         img->\hyperlink{structaom__image_ac54dbc5237ca2914f9ec30105dfbe302}{planes}[AOM\_PLANE\_V], img->\hyperlink{structaom__image_a6dc693d7dbc9eb06c0cdde307ca58372}{stride}[AOM\_PLANE\_V], img->\hyperlink{structaom__image_a89f80b1f58d608b9d2080635f4359034}{d\_w}, img->
      \hyperlink{structaom__image_ab986419a1f0fff93a2dc505f47194988}{d\_h},
1804         stream->img->planes[\hyperlink{aom__image_8h_a2ad22076006b15cf809edcaa33f6d339}{AOM\_PLANE\_Y}], stream->img->stride[
      \hyperlink{aom__image_8h_a2ad22076006b15cf809edcaa33f6d339}{AOM\_PLANE\_Y}],
1805         stream->img->planes[AOM\_PLANE\_U], stream->img->stride[AOM\_PLANE\_U],
1806         stream->img->planes[AOM\_PLANE\_V], stream->img->stride[AOM\_PLANE\_V],
1807         stream->img->d\_w, stream->img->d\_h, kFilterBox);
1808     img = stream->img;
1809 \textcolor{preprocessor}{#else}
1810     stream->encoder.err = 1;
1811     ctx\_exit\_on\_error(&stream->encoder,
1812                       \textcolor{stringliteral}{"Stream %d: Failed to encode frame.\(\backslash\)n"}
1813                       \textcolor{stringliteral}{"Scaling disabled in this configuration. \(\backslash\)n"}
1814                       \textcolor{stringliteral}{"To enable, configure with --enable-libyuv\(\backslash\)n"},
1815                       stream->index);
1816 \textcolor{preprocessor}{#endif}
1817   \}
1818 
1819   aom\_usec\_timer\_start(&timer);
1820   \hyperlink{group__encoder_ga6f4a777de5389771e783df7ff1f116d4}{aom\_codec\_encode}(&stream->encoder, img, frame\_start,
1821                    (uint32\_t)(next\_frame\_start - frame\_start), 0);
1822   aom\_usec\_timer\_mark(&timer);
1823   stream->cx\_time += aom\_usec\_timer\_elapsed(&timer);
1824   ctx\_exit\_on\_error(&stream->encoder, \textcolor{stringliteral}{"Stream %d: Failed to encode frame"},
1825                     stream->index);
1826 \}
1827 
1828 \textcolor{keyword}{static} \textcolor{keywordtype}{void} update\_quantizer\_histogram(\textcolor{keyword}{struct} stream\_state *stream) \{
1829   \textcolor{keywordflow}{if} (stream->config.cfg.g\_pass != \hyperlink{group__encoder_gga92b6709b58dc3435e3ba652da562eda1ad342b33a290482c20238bfde5d9bea1e}{AOM\_RC\_FIRST\_PASS}) \{
1830     \textcolor{keywordtype}{int} q;
1831 
1832     \hyperlink{group__codec_ga6da974f4eeaba1fa74106b28d0fe6ac5}{aom\_codec\_control}(&stream->encoder, 
      \hyperlink{group__aom__encoder_ggae78dde67a6d78f332e9bdba0dde42db5a17b924cadd3c942f9e57fe6fc4d5e2ab}{AOME\_GET\_LAST\_QUANTIZER\_64}, &q);
1833     ctx\_exit\_on\_error(&stream->encoder, \textcolor{stringliteral}{"Failed to read quantizer"});
1834     stream->counts[q]++;
1835   \}
1836 \}
1837 
1838 \textcolor{keyword}{static} \textcolor{keywordtype}{void} get\_cx\_data(\textcolor{keyword}{struct} stream\_state *stream,
1839                         \textcolor{keyword}{struct} AvxEncoderConfig *global, \textcolor{keywordtype}{int} *got\_data) \{
1840   \textcolor{keyword}{const} \hyperlink{structaom__codec__cx__pkt}{aom\_codec\_cx\_pkt\_t} *pkt;
1841   \textcolor{keyword}{const} \textcolor{keyword}{struct }\hyperlink{structaom__codec__enc__cfg}{aom\_codec\_enc\_cfg} *cfg = &stream->config.cfg;
1842   \hyperlink{group__codec_gadf9e173c9e02788a9999399edab20a02}{aom\_codec\_iter\_t} iter = NULL;
1843 
1844   *got\_data = 0;
1845   \textcolor{keywordflow}{while} ((pkt = \hyperlink{group__encoder_gaedc4c56b60d4217677cb561066360884}{aom\_codec\_get\_cx\_data}(&stream->encoder, &iter))) \{
1846     \textcolor{keyword}{static} \textcolor{keywordtype}{size\_t} fsize = 0;
1847     \textcolor{keyword}{static} FileOffset ivf\_header\_pos = 0;
1848 
1849     \textcolor{keywordflow}{switch} (pkt->\hyperlink{structaom__codec__cx__pkt_a11e586120c689ece9a7690e72ff384be}{kind}) \{
1850       \textcolor{keywordflow}{case} \hyperlink{group__encoder_ggafeb69da4a9649a54e805f59c26d8dfeda793165d0f219812342f69d5fd9b2b9c8}{AOM\_CODEC\_CX\_FRAME\_PKT}:
1851         ++stream->frames\_out;
1852         \textcolor{keywordflow}{if} (!global->quiet)
1853           fprintf(stderr, \textcolor{stringliteral}{" %6luF"}, (\textcolor{keywordtype}{unsigned} \textcolor{keywordtype}{long})pkt->\hyperlink{structaom__codec__cx__pkt_afb379cd4bfa7692d1d6e85f4e4b2b410}{data}.\hyperlink{structaom__codec__cx__pkt_a4180a6ae59b0d295bc915d4689df4cb0}{frame}.sz);
1854 
1855         update\_rate\_histogram(stream->rate\_hist, cfg, pkt);
1856 \textcolor{preprocessor}{#if CONFIG\_WEBM\_IO}
1857         \textcolor{keywordflow}{if} (stream->config.write\_webm) \{
1858           \textcolor{keywordflow}{if} (write\_webm\_block(&stream->webm\_ctx, cfg, pkt) != 0) \{
1859             fatal(\textcolor{stringliteral}{"WebM writer failed."});
1860           \}
1861         \}
1862 \textcolor{preprocessor}{#endif}
1863         \textcolor{keywordflow}{if} (!stream->config.write\_webm) \{
1864           \textcolor{keywordflow}{if} (stream->config.write\_ivf) \{
1865             \textcolor{keywordflow}{if} (pkt->\hyperlink{structaom__codec__cx__pkt_afb379cd4bfa7692d1d6e85f4e4b2b410}{data}.\hyperlink{structaom__codec__cx__pkt_a4180a6ae59b0d295bc915d4689df4cb0}{frame}.partition\_id <= 0) \{
1866               ivf\_header\_pos = ftello(stream->file);
1867               fsize = pkt->\hyperlink{structaom__codec__cx__pkt_afb379cd4bfa7692d1d6e85f4e4b2b410}{data}.\hyperlink{structaom__codec__cx__pkt_a4180a6ae59b0d295bc915d4689df4cb0}{frame}.sz;
1868 
1869               ivf\_write\_frame\_header(stream->file, pkt->\hyperlink{structaom__codec__cx__pkt_afb379cd4bfa7692d1d6e85f4e4b2b410}{data}.\hyperlink{structaom__codec__cx__pkt_a4180a6ae59b0d295bc915d4689df4cb0}{frame}.pts, fsize);
1870             \} \textcolor{keywordflow}{else} \{
1871               fsize += pkt->\hyperlink{structaom__codec__cx__pkt_afb379cd4bfa7692d1d6e85f4e4b2b410}{data}.\hyperlink{structaom__codec__cx__pkt_a4180a6ae59b0d295bc915d4689df4cb0}{frame}.sz;
1872 
1873               \textcolor{keyword}{const} FileOffset currpos = ftello(stream->file);
1874               fseeko(stream->file, ivf\_header\_pos, SEEK\_SET);
1875               ivf\_write\_frame\_size(stream->file, fsize);
1876               fseeko(stream->file, currpos, SEEK\_SET);
1877             \}
1878           \}
1879 
1880           (void)fwrite(pkt->\hyperlink{structaom__codec__cx__pkt_afb379cd4bfa7692d1d6e85f4e4b2b410}{data}.\hyperlink{structaom__codec__cx__pkt_a4180a6ae59b0d295bc915d4689df4cb0}{frame}.buf, 1, pkt->\hyperlink{structaom__codec__cx__pkt_afb379cd4bfa7692d1d6e85f4e4b2b410}{data}.\hyperlink{structaom__codec__cx__pkt_a4180a6ae59b0d295bc915d4689df4cb0}{frame}.sz,
1881                        stream->file);
1882         \}
1883         stream->nbytes += pkt->\hyperlink{structaom__codec__cx__pkt_afb379cd4bfa7692d1d6e85f4e4b2b410}{data}.\hyperlink{structaom__codec__cx__pkt_a4fc6ea5e240c5df0acbf77aa2fe5ec6f}{raw}.\hyperlink{structaom__fixed__buf_a02f47e8b960c332c60a8aa4b7e37426f}{sz};
1884 
1885         *got\_data = 1;
1886 \textcolor{preprocessor}{#if CONFIG\_AV1\_DECODER}
1887         \textcolor{keywordflow}{if} (global->test\_decode != TEST\_DECODE\_OFF && !stream->mismatch\_seen) \{
1888           \hyperlink{group__decoder_gab03fdb999d1f83a5896869a3ba5f68f7}{aom\_codec\_decode}(&stream->decoder, pkt->\hyperlink{structaom__codec__cx__pkt_afb379cd4bfa7692d1d6e85f4e4b2b410}{data}.\hyperlink{structaom__codec__cx__pkt_a4180a6ae59b0d295bc915d4689df4cb0}{frame}.buf,
1889                            pkt->\hyperlink{structaom__codec__cx__pkt_afb379cd4bfa7692d1d6e85f4e4b2b410}{data}.\hyperlink{structaom__codec__cx__pkt_a4180a6ae59b0d295bc915d4689df4cb0}{frame}.sz, NULL);
1890           \textcolor{keywordflow}{if} (stream->decoder.err) \{
1891             warn\_or\_exit\_on\_error(&stream->decoder,
1892                                   global->test\_decode == TEST\_DECODE\_FATAL,
1893                                   \textcolor{stringliteral}{"Failed to decode frame %d in stream %d"},
1894                                   stream->frames\_out + 1, stream->index);
1895             stream->mismatch\_seen = stream->frames\_out + 1;
1896           \}
1897         \}
1898 \textcolor{preprocessor}{#endif}
1899         \textcolor{keywordflow}{break};
1900       \textcolor{keywordflow}{case} \hyperlink{group__encoder_ggafeb69da4a9649a54e805f59c26d8dfeda7dcdcb6c401cac64ca98b51f52de8d4b}{AOM\_CODEC\_STATS\_PKT}:
1901         stream->frames\_out++;
1902         stats\_write(&stream->stats, pkt->\hyperlink{structaom__codec__cx__pkt_afb379cd4bfa7692d1d6e85f4e4b2b410}{data}.\hyperlink{structaom__codec__cx__pkt_a40d469839bcd8195c3c8e80db6561dbb}{twopass\_stats}.\hyperlink{structaom__fixed__buf_ac1b22da152c9839329d3780208dffd38}{buf},
1903                     pkt->\hyperlink{structaom__codec__cx__pkt_afb379cd4bfa7692d1d6e85f4e4b2b410}{data}.\hyperlink{structaom__codec__cx__pkt_a40d469839bcd8195c3c8e80db6561dbb}{twopass\_stats}.\hyperlink{structaom__fixed__buf_a02f47e8b960c332c60a8aa4b7e37426f}{sz});
1904         stream->nbytes += pkt->\hyperlink{structaom__codec__cx__pkt_afb379cd4bfa7692d1d6e85f4e4b2b410}{data}.\hyperlink{structaom__codec__cx__pkt_a4fc6ea5e240c5df0acbf77aa2fe5ec6f}{raw}.\hyperlink{structaom__fixed__buf_a02f47e8b960c332c60a8aa4b7e37426f}{sz};
1905         \textcolor{keywordflow}{break};
1906 \textcolor{preprocessor}{#if CONFIG\_FP\_MB\_STATS}
1907       \textcolor{keywordflow}{case} \hyperlink{group__encoder_ggafeb69da4a9649a54e805f59c26d8dfedaaa76df44da4c92b08150b8a5326f5ebe}{AOM\_CODEC\_FPMB\_STATS\_PKT}:
1908         stats\_write(&stream->fpmb\_stats, pkt->\hyperlink{structaom__codec__cx__pkt_afb379cd4bfa7692d1d6e85f4e4b2b410}{data}.\hyperlink{structaom__codec__cx__pkt_a8ce39bab39da5a247a27e42eb78386e2}{firstpass\_mb\_stats}.
      \hyperlink{structaom__fixed__buf_ac1b22da152c9839329d3780208dffd38}{buf},
1909                     pkt->\hyperlink{structaom__codec__cx__pkt_afb379cd4bfa7692d1d6e85f4e4b2b410}{data}.\hyperlink{structaom__codec__cx__pkt_a8ce39bab39da5a247a27e42eb78386e2}{firstpass\_mb\_stats}.\hyperlink{structaom__fixed__buf_a02f47e8b960c332c60a8aa4b7e37426f}{sz});
1910         stream->nbytes += pkt->\hyperlink{structaom__codec__cx__pkt_afb379cd4bfa7692d1d6e85f4e4b2b410}{data}.\hyperlink{structaom__codec__cx__pkt_a4fc6ea5e240c5df0acbf77aa2fe5ec6f}{raw}.\hyperlink{structaom__fixed__buf_a02f47e8b960c332c60a8aa4b7e37426f}{sz};
1911         \textcolor{keywordflow}{break};
1912 \textcolor{preprocessor}{#endif}
1913       \textcolor{keywordflow}{case} \hyperlink{group__encoder_ggafeb69da4a9649a54e805f59c26d8dfeda3293bb764f30c11e9583510029578b75}{AOM\_CODEC\_PSNR\_PKT}:
1914 
1915         \textcolor{keywordflow}{if} (global->show\_psnr) \{
1916           \textcolor{keywordtype}{int} i;
1917 
1918           stream->psnr\_sse\_total += pkt->\hyperlink{structaom__codec__cx__pkt_afb379cd4bfa7692d1d6e85f4e4b2b410}{data}.\hyperlink{structaom__codec__cx__pkt_a3a38e942aa0da463260a05eb05f51762}{psnr}.sse[0];
1919           stream->psnr\_samples\_total += pkt->\hyperlink{structaom__codec__cx__pkt_afb379cd4bfa7692d1d6e85f4e4b2b410}{data}.\hyperlink{structaom__codec__cx__pkt_a3a38e942aa0da463260a05eb05f51762}{psnr}.samples[0];
1920           \textcolor{keywordflow}{for} (i = 0; i < 4; i++) \{
1921             \textcolor{keywordflow}{if} (!global->quiet)
1922               fprintf(stderr, \textcolor{stringliteral}{"%.3f "}, pkt->\hyperlink{structaom__codec__cx__pkt_afb379cd4bfa7692d1d6e85f4e4b2b410}{data}.\hyperlink{structaom__codec__cx__pkt_a3a38e942aa0da463260a05eb05f51762}{psnr}.psnr[i]);
1923             stream->psnr\_totals[i] += pkt->\hyperlink{structaom__codec__cx__pkt_afb379cd4bfa7692d1d6e85f4e4b2b410}{data}.\hyperlink{structaom__codec__cx__pkt_a3a38e942aa0da463260a05eb05f51762}{psnr}.psnr[i];
1924           \}
1925           stream->psnr\_count++;
1926         \}
1927 
1928         \textcolor{keywordflow}{break};
1929       \textcolor{keywordflow}{default}: \textcolor{keywordflow}{break};
1930     \}
1931   \}
1932 \}
1933 
1934 \textcolor{keyword}{static} \textcolor{keywordtype}{void} show\_psnr(\textcolor{keyword}{struct} stream\_state *stream, \textcolor{keywordtype}{double} peak, int64\_t bps) \{
1935   \textcolor{keywordtype}{int} i;
1936   \textcolor{keywordtype}{double} ovpsnr;
1937 
1938   \textcolor{keywordflow}{if} (!stream->psnr\_count) \textcolor{keywordflow}{return};
1939 
1940   fprintf(stderr, \textcolor{stringliteral}{"Stream %d PSNR (Overall/Avg/Y/U/V)"}, stream->index);
1941   ovpsnr = sse\_to\_psnr((\textcolor{keywordtype}{double})stream->psnr\_samples\_total, peak,
1942                        (\textcolor{keywordtype}{double})stream->psnr\_sse\_total);
1943   fprintf(stderr, \textcolor{stringliteral}{" %.3f"}, ovpsnr);
1944 
1945   \textcolor{keywordflow}{for} (i = 0; i < 4; i++) \{
1946     fprintf(stderr, \textcolor{stringliteral}{" %.3f"}, stream->psnr\_totals[i] / stream->psnr\_count);
1947   \}
1948   \textcolor{keywordflow}{if} (bps > 0) \{
1949     fprintf(stderr, \textcolor{stringliteral}{" %7"} PRId64 \textcolor{stringliteral}{" bps"}, bps);
1950   \}
1951   fprintf(stderr, \textcolor{stringliteral}{" %7"} PRId64 \textcolor{stringliteral}{" ms"}, stream->cx\_time / 1000);
1952   fprintf(stderr, \textcolor{stringliteral}{"\(\backslash\)n"});
1953 \}
1954 
1955 \textcolor{keyword}{static} \textcolor{keywordtype}{float} usec\_to\_fps(uint64\_t usec, \textcolor{keywordtype}{unsigned} \textcolor{keywordtype}{int} frames) \{
1956   \textcolor{keywordflow}{return} (\textcolor{keywordtype}{float})(usec > 0 ? frames * 1000000.0 / (float)usec : 0);
1957 \}
1958 
1959 \textcolor{keyword}{static} \textcolor{keywordtype}{void} test\_decode(\textcolor{keyword}{struct} stream\_state *stream,
1960                         \textcolor{keyword}{enum} TestDecodeFatality fatal) \{
1961   \hyperlink{structaom__image}{aom\_image\_t} enc\_img, dec\_img;
1962 
1963   \textcolor{keywordflow}{if} (stream->mismatch\_seen) \textcolor{keywordflow}{return};
1964 
1965   \textcolor{comment}{/* Get the internal reference frame */}
1966   \hyperlink{group__codec_ga6da974f4eeaba1fa74106b28d0fe6ac5}{aom\_codec\_control}(&stream->encoder, \hyperlink{group__aom_gga9421a1fa78c0d9587ae5aa6c1cb3d659a410c706a34f5295996658cc5044a700f}{AV1\_GET\_NEW\_FRAME\_IMAGE}, &
      enc\_img);
1967   \hyperlink{group__codec_ga6da974f4eeaba1fa74106b28d0fe6ac5}{aom\_codec\_control}(&stream->decoder, \hyperlink{group__aom_gga9421a1fa78c0d9587ae5aa6c1cb3d659a410c706a34f5295996658cc5044a700f}{AV1\_GET\_NEW\_FRAME\_IMAGE}, &
      dec\_img);
1968 
1969   \textcolor{keywordflow}{if} ((enc\_img.\hyperlink{structaom__image_a6c64b1ab918d80d52eb8f5d6d957e825}{fmt} & \hyperlink{aom__image_8h_a607b37d91f75442f54223ecd85f1b6cb}{AOM\_IMG\_FMT\_HIGHBITDEPTH}) !=
1970       (dec\_img.\hyperlink{structaom__image_a6c64b1ab918d80d52eb8f5d6d957e825}{fmt} & \hyperlink{aom__image_8h_a607b37d91f75442f54223ecd85f1b6cb}{AOM\_IMG\_FMT\_HIGHBITDEPTH})) \{
1971     \textcolor{keywordflow}{if} (enc\_img.\hyperlink{structaom__image_a6c64b1ab918d80d52eb8f5d6d957e825}{fmt} & \hyperlink{aom__image_8h_a607b37d91f75442f54223ecd85f1b6cb}{AOM\_IMG\_FMT\_HIGHBITDEPTH}) \{
1972       \hyperlink{structaom__image}{aom\_image\_t} enc\_hbd\_img;
1973       \hyperlink{aom__image_8h_a570db29fbd122951235a08fe9375f6bb}{aom\_img\_alloc}(&enc\_hbd\_img, enc\_img.\hyperlink{structaom__image_a6c64b1ab918d80d52eb8f5d6d957e825}{fmt} - 
      \hyperlink{aom__image_8h_a607b37d91f75442f54223ecd85f1b6cb}{AOM\_IMG\_FMT\_HIGHBITDEPTH},
1974                     enc\_img.\hyperlink{structaom__image_a89f80b1f58d608b9d2080635f4359034}{d\_w}, enc\_img.\hyperlink{structaom__image_ab986419a1f0fff93a2dc505f47194988}{d\_h}, 16);
1975       aom\_img\_truncate\_16\_to\_8(&enc\_hbd\_img, &enc\_img);
1976       enc\_img = enc\_hbd\_img;
1977     \}
1978     \textcolor{keywordflow}{if} (dec\_img.\hyperlink{structaom__image_a6c64b1ab918d80d52eb8f5d6d957e825}{fmt} & \hyperlink{aom__image_8h_a607b37d91f75442f54223ecd85f1b6cb}{AOM\_IMG\_FMT\_HIGHBITDEPTH}) \{
1979       \hyperlink{structaom__image}{aom\_image\_t} dec\_hbd\_img;
1980       \hyperlink{aom__image_8h_a570db29fbd122951235a08fe9375f6bb}{aom\_img\_alloc}(&dec\_hbd\_img, dec\_img.\hyperlink{structaom__image_a6c64b1ab918d80d52eb8f5d6d957e825}{fmt} - 
      \hyperlink{aom__image_8h_a607b37d91f75442f54223ecd85f1b6cb}{AOM\_IMG\_FMT\_HIGHBITDEPTH},
1981                     dec\_img.\hyperlink{structaom__image_a89f80b1f58d608b9d2080635f4359034}{d\_w}, dec\_img.\hyperlink{structaom__image_ab986419a1f0fff93a2dc505f47194988}{d\_h}, 16);
1982       aom\_img\_truncate\_16\_to\_8(&dec\_hbd\_img, &dec\_img);
1983       dec\_img = dec\_hbd\_img;
1984     \}
1985   \}
1986 
1987   ctx\_exit\_on\_error(&stream->encoder, \textcolor{stringliteral}{"Failed to get encoder reference frame"});
1988   ctx\_exit\_on\_error(&stream->decoder, \textcolor{stringliteral}{"Failed to get decoder reference frame"});
1989 
1990   \textcolor{keywordflow}{if} (!aom\_compare\_img(&enc\_img, &dec\_img)) \{
1991     \textcolor{keywordtype}{int} y[4], u[4], v[4];
1992     \textcolor{keywordflow}{if} (enc\_img.\hyperlink{structaom__image_a6c64b1ab918d80d52eb8f5d6d957e825}{fmt} & \hyperlink{aom__image_8h_a607b37d91f75442f54223ecd85f1b6cb}{AOM\_IMG\_FMT\_HIGHBITDEPTH}) \{
1993       aom\_find\_mismatch\_high(&enc\_img, &dec\_img, y, u, v);
1994     \} \textcolor{keywordflow}{else} \{
1995       aom\_find\_mismatch(&enc\_img, &dec\_img, y, u, v);
1996     \}
1997     stream->decoder.err = 1;
1998     warn\_or\_exit\_on\_error(&stream->decoder, fatal == TEST\_DECODE\_FATAL,
1999                           \textcolor{stringliteral}{"Stream %d: Encode/decode mismatch on frame %d at"}
2000                           \textcolor{stringliteral}{" Y[%d, %d] \{%d/%d\},"}
2001                           \textcolor{stringliteral}{" U[%d, %d] \{%d/%d\},"}
2002                           \textcolor{stringliteral}{" V[%d, %d] \{%d/%d\}"},
2003                           stream->index, stream->frames\_out, y[0], y[1], y[2],
2004                           y[3], u[0], u[1], u[2], u[3], v[0], v[1], v[2], v[3]);
2005     stream->mismatch\_seen = stream->frames\_out;
2006   \}
2007 
2008   \hyperlink{aom__image_8h_afff22f7f3eb9409c5b678d1962f110a8}{aom\_img\_free}(&enc\_img);
2009   \hyperlink{aom__image_8h_afff22f7f3eb9409c5b678d1962f110a8}{aom\_img\_free}(&dec\_img);
2010 \}
2011 
2012 \textcolor{keyword}{static} \textcolor{keywordtype}{void} print\_time(\textcolor{keyword}{const} \textcolor{keywordtype}{char} *label, int64\_t etl) \{
2013   int64\_t hours;
2014   int64\_t mins;
2015   int64\_t secs;
2016 
2017   \textcolor{keywordflow}{if} (etl >= 0) \{
2018     hours = etl / 3600;
2019     etl -= hours * 3600;
2020     mins = etl / 60;
2021     etl -= mins * 60;
2022     secs = etl;
2023 
2024     fprintf(stderr, \textcolor{stringliteral}{"[%3s %2"} PRId64 \textcolor{stringliteral}{":%02"} PRId64 \textcolor{stringliteral}{":%02"} PRId64 \textcolor{stringliteral}{"] "}, label,
2025             hours, mins, secs);
2026   \} \textcolor{keywordflow}{else} \{
2027     fprintf(stderr, \textcolor{stringliteral}{"[%3s  unknown] "}, label);
2028   \}
2029 \}
2030 
2031 \textcolor{keywordtype}{int} main(\textcolor{keywordtype}{int} argc, \textcolor{keyword}{const} \textcolor{keywordtype}{char} **argv\_) \{
2032   \textcolor{keywordtype}{int} pass;
2033   \hyperlink{structaom__image}{aom\_image\_t} raw;
2034   \hyperlink{structaom__image}{aom\_image\_t} raw\_shift;
2035   \textcolor{keywordtype}{int} allocated\_raw\_shift = 0;
2036   \textcolor{keywordtype}{int} use\_16bit\_internal = 0;
2037   \textcolor{keywordtype}{int} input\_shift = 0;
2038   \textcolor{keywordtype}{int} frame\_avail, got\_data;
2039 
2040   \textcolor{keyword}{struct }AvxInputContext input;
2041   \textcolor{keyword}{struct }AvxEncoderConfig global;
2042   \textcolor{keyword}{struct }stream\_state *streams = NULL;
2043   \textcolor{keywordtype}{char} **argv, **argi;
2044   uint64\_t cx\_time = 0;
2045   \textcolor{keywordtype}{int} stream\_cnt = 0;
2046   \textcolor{keywordtype}{int} res = 0;
2047   \textcolor{keywordtype}{int} profile\_updated = 0;
2048 
2049   memset(&input, 0, \textcolor{keyword}{sizeof}(input));
2050   exec\_name = argv\_[0];
2051 
2052   \textcolor{comment}{/* Setup default input stream settings */}
2053   input.framerate.numerator = 30;
2054   input.framerate.denominator = 1;
2055   input.only\_i420 = 1;
2056   input.bit\_depth = 0;
2057 
2058   \textcolor{comment}{/* First parse the global configuration values, because we want to apply}
2059 \textcolor{comment}{   * other parameters on top of the default configuration provided by the}
2060 \textcolor{comment}{   * codec.}
2061 \textcolor{comment}{   */}
2062   argv = argv\_dup(argc - 1, argv\_ + 1);
2063   parse\_global\_config(&global, argc, &argv);
2064 
2065 \textcolor{preprocessor}{#if CONFIG\_FILEOPTIONS}
2066   \textcolor{keywordflow}{if} (argc < 2) usage\_exit();
2067 \textcolor{preprocessor}{#else}
2068   \textcolor{keywordflow}{if} (argc < 3) usage\_exit();
2069 \textcolor{preprocessor}{#endif}
2070 
2071   \textcolor{keywordflow}{switch} (global.color\_type) \{
2072     \textcolor{keywordflow}{case} I420: input.fmt = \hyperlink{aom__image_8h_a930317c04b4bd0a660bb5e744055523cabd778a3d697463e89d12a1117f417b60}{AOM\_IMG\_FMT\_I420}; \textcolor{keywordflow}{break};
2073     \textcolor{keywordflow}{case} I422: input.fmt = \hyperlink{aom__image_8h_a930317c04b4bd0a660bb5e744055523cab2f75281e94ebc0f0bc728ef287cd3e8}{AOM\_IMG\_FMT\_I422}; \textcolor{keywordflow}{break};
2074     \textcolor{keywordflow}{case} I444: input.fmt = \hyperlink{aom__image_8h_a930317c04b4bd0a660bb5e744055523ca89d423506e948ab7d3b98b5750b92655}{AOM\_IMG\_FMT\_I444}; \textcolor{keywordflow}{break};
2075     \textcolor{keywordflow}{case} YV12: input.fmt = \hyperlink{aom__image_8h_a930317c04b4bd0a660bb5e744055523cad28244100a2754409f285b77a3db90a0}{AOM\_IMG\_FMT\_YV12}; \textcolor{keywordflow}{break};
2076   \}
2077 
2078   \{
2079     \textcolor{comment}{/* Now parse each stream's parameters. Using a local scope here}
2080 \textcolor{comment}{     * due to the use of 'stream' as loop variable in FOREACH\_STREAM}
2081 \textcolor{comment}{     * loops}
2082 \textcolor{comment}{     */}
2083     \textcolor{keyword}{struct }stream\_state *stream = NULL;
2084 
2085     \textcolor{keywordflow}{do} \{
2086       stream = new\_stream(&global, stream);
2087       stream\_cnt++;
2088       \textcolor{keywordflow}{if} (!streams) streams = stream;
2089     \} \textcolor{keywordflow}{while} (parse\_stream\_params(&global, stream, argv));
2090   \}
2091 
2092   \textcolor{comment}{/* Check for unrecognized options */}
2093   \textcolor{keywordflow}{for} (argi = argv; *argi; argi++)
2094     \textcolor{keywordflow}{if} (argi[0][0] == \textcolor{charliteral}{'-'} && argi[0][1])
2095       die(\textcolor{stringliteral}{"Error: Unrecognized option %s\(\backslash\)n"}, *argi);
2096 
2097   FOREACH\_STREAM(stream, streams) \{
2098     check\_encoder\_config(global.disable\_warning\_prompt, &global,
2099                          &stream->config.cfg);
2100   \}
2101 
2102   \textcolor{comment}{/* Handle non-option arguments */}
2103   input.filename = argv[0];
2104 
2105   \textcolor{keywordflow}{if} (!input.filename) \{
2106     fprintf(stderr, \textcolor{stringliteral}{"No input file specified!\(\backslash\)n"});
2107     usage\_exit();
2108   \}
2109 
2110   \textcolor{comment}{/* Decide if other chroma subsamplings than 4:2:0 are supported */}
2111   \textcolor{keywordflow}{if} (global.codec->fourcc == AV1\_FOURCC) input.only\_i420 = 0;
2112 
2113   \textcolor{keywordflow}{for} (pass = global.pass ? global.pass - 1 : 0; pass < global.passes; pass++) \{
2114     \textcolor{keywordtype}{int} frames\_in = 0, seen\_frames = 0;
2115     int64\_t estimated\_time\_left = -1;
2116     int64\_t average\_rate = -1;
2117     int64\_t lagged\_count = 0;
2118 
2119     open\_input\_file(&input, global.csp);
2120 
2121     \textcolor{comment}{/* If the input file doesn't specify its w/h (raw files), try to get}
2122 \textcolor{comment}{     * the data from the first stream's configuration.}
2123 \textcolor{comment}{     */}
2124     \textcolor{keywordflow}{if} (!input.width || !input.height) \{
2125       FOREACH\_STREAM(stream, streams) \{
2126         \textcolor{keywordflow}{if} (stream->config.cfg.g\_w && stream->config.cfg.g\_h) \{
2127           input.width = stream->config.cfg.g\_w;
2128           input.height = stream->config.cfg.g\_h;
2129           \textcolor{keywordflow}{break};
2130         \}
2131       \};
2132     \}
2133 
2134     \textcolor{comment}{/* Update stream configurations from the input file's parameters */}
2135     \textcolor{keywordflow}{if} (!input.width || !input.height)
2136       fatal(
2137           \textcolor{stringliteral}{"Specify stream dimensions with --width (-w) "}
2138           \textcolor{stringliteral}{" and --height (-h)"});
2139 
2140     \textcolor{comment}{/* If input file does not specify bit-depth but input-bit-depth parameter}
2141 \textcolor{comment}{     * exists, assume that to be the input bit-depth. However, if the}
2142 \textcolor{comment}{     * input-bit-depth paramter does not exist, assume the input bit-depth}
2143 \textcolor{comment}{     * to be the same as the codec bit-depth.}
2144 \textcolor{comment}{     */}
2145     \textcolor{keywordflow}{if} (!input.bit\_depth) \{
2146       FOREACH\_STREAM(stream, streams) \{
2147         \textcolor{keywordflow}{if} (stream->config.cfg.g\_input\_bit\_depth)
2148           input.bit\_depth = stream->config.cfg.g\_input\_bit\_depth;
2149         \textcolor{keywordflow}{else}
2150           input.bit\_depth = stream->config.cfg.g\_input\_bit\_depth =
2151               (int)stream->config.cfg.g\_bit\_depth;
2152       \}
2153       \textcolor{keywordflow}{if} (input.bit\_depth > 8) input.fmt |= \hyperlink{aom__image_8h_a607b37d91f75442f54223ecd85f1b6cb}{AOM\_IMG\_FMT\_HIGHBITDEPTH};
2154     \} \textcolor{keywordflow}{else} \{
2155       FOREACH\_STREAM(stream, streams) \{
2156         stream->config.cfg.g\_input\_bit\_depth = input.bit\_depth;
2157       \}
2158     \}
2159 
2160     FOREACH\_STREAM(stream, streams) \{
2161       \textcolor{keywordflow}{if} (input.fmt != \hyperlink{aom__image_8h_a930317c04b4bd0a660bb5e744055523cabd778a3d697463e89d12a1117f417b60}{AOM\_IMG\_FMT\_I420} && input.fmt != 
      \hyperlink{aom__image_8h_a930317c04b4bd0a660bb5e744055523ca20a9cf30277260685642b4cfb4e9273b}{AOM\_IMG\_FMT\_I42016}) \{
2162         \textcolor{comment}{/* Automatically upgrade if input is non-4:2:0 but a 4:2:0 profile}
2163 \textcolor{comment}{           was selected. */}
2164         \textcolor{keywordflow}{switch} (stream->config.cfg.g\_profile) \{
2165           \textcolor{keywordflow}{case} 0:
2166             \textcolor{keywordflow}{if} (input.bit\_depth < 12 && (input.fmt == \hyperlink{aom__image_8h_a930317c04b4bd0a660bb5e744055523ca89d423506e948ab7d3b98b5750b92655}{AOM\_IMG\_FMT\_I444} ||
2167                                          input.fmt == \hyperlink{aom__image_8h_a930317c04b4bd0a660bb5e744055523cab9b93d397dedbdd6bfafec84d1f8f0f5}{AOM\_IMG\_FMT\_I44416})) \{
2168               \textcolor{keywordflow}{if} (!stream->config.cfg.monochrome) \{
2169                 stream->config.cfg.g\_profile = 1;
2170                 profile\_updated = 1;
2171               \}
2172             \} \textcolor{keywordflow}{else} \textcolor{keywordflow}{if} (input.bit\_depth == 12 || input.fmt == \hyperlink{aom__image_8h_a930317c04b4bd0a660bb5e744055523cab2f75281e94ebc0f0bc728ef287cd3e8}{AOM\_IMG\_FMT\_I422} ||
2173                        input.fmt == \hyperlink{aom__image_8h_a930317c04b4bd0a660bb5e744055523ca064683ed4260fc6244af6cfc9d261c22}{AOM\_IMG\_FMT\_I42216}) \{
2174               stream->config.cfg.g\_profile = 2;
2175               profile\_updated = 1;
2176             \}
2177             \textcolor{keywordflow}{break};
2178           \textcolor{keywordflow}{case} 1:
2179             \textcolor{keywordflow}{if} (input.bit\_depth == 12 || input.fmt == \hyperlink{aom__image_8h_a930317c04b4bd0a660bb5e744055523cab2f75281e94ebc0f0bc728ef287cd3e8}{AOM\_IMG\_FMT\_I422} ||
2180                 input.fmt == \hyperlink{aom__image_8h_a930317c04b4bd0a660bb5e744055523ca064683ed4260fc6244af6cfc9d261c22}{AOM\_IMG\_FMT\_I42216}) \{
2181               stream->config.cfg.g\_profile = 2;
2182               profile\_updated = 1;
2183             \} \textcolor{keywordflow}{else} \textcolor{keywordflow}{if} (input.bit\_depth < 12 &&
2184                        (input.fmt == \hyperlink{aom__image_8h_a930317c04b4bd0a660bb5e744055523cabd778a3d697463e89d12a1117f417b60}{AOM\_IMG\_FMT\_I420} ||
2185                         input.fmt == \hyperlink{aom__image_8h_a930317c04b4bd0a660bb5e744055523ca20a9cf30277260685642b4cfb4e9273b}{AOM\_IMG\_FMT\_I42016})) \{
2186               stream->config.cfg.g\_profile = 0;
2187               profile\_updated = 1;
2188             \}
2189             \textcolor{keywordflow}{break};
2190           \textcolor{keywordflow}{case} 2:
2191             \textcolor{keywordflow}{if} (input.bit\_depth < 12 && (input.fmt == \hyperlink{aom__image_8h_a930317c04b4bd0a660bb5e744055523ca89d423506e948ab7d3b98b5750b92655}{AOM\_IMG\_FMT\_I444} ||
2192                                          input.fmt == \hyperlink{aom__image_8h_a930317c04b4bd0a660bb5e744055523cab9b93d397dedbdd6bfafec84d1f8f0f5}{AOM\_IMG\_FMT\_I44416})) \{
2193               stream->config.cfg.g\_profile = 1;
2194               profile\_updated = 1;
2195             \} \textcolor{keywordflow}{else} \textcolor{keywordflow}{if} (input.bit\_depth < 12 &&
2196                        (input.fmt == \hyperlink{aom__image_8h_a930317c04b4bd0a660bb5e744055523cabd778a3d697463e89d12a1117f417b60}{AOM\_IMG\_FMT\_I420} ||
2197                         input.fmt == \hyperlink{aom__image_8h_a930317c04b4bd0a660bb5e744055523ca20a9cf30277260685642b4cfb4e9273b}{AOM\_IMG\_FMT\_I42016})) \{
2198               stream->config.cfg.g\_profile = 0;
2199               profile\_updated = 1;
2200             \} \textcolor{keywordflow}{else} \textcolor{keywordflow}{if} (input.bit\_depth == 12 &&
2201                        input.file\_type == FILE\_TYPE\_Y4M) \{
2202               \textcolor{comment}{// Note that here the input file values for chroma subsampling}
2203               \textcolor{comment}{// are used instead of those from the command line.}
2204               \hyperlink{group__codec_ga6da974f4eeaba1fa74106b28d0fe6ac5}{aom\_codec\_control}(&stream->encoder, 
      \hyperlink{group__aom__encoder_ggae78dde67a6d78f332e9bdba0dde42db5a283dd3f4387e5f3a754fea0d206b1cb0}{AV1E\_SET\_CHROMA\_SUBSAMPLING\_X},
2205                                 input.y4m.dst\_c\_dec\_h >> 1);
2206               \hyperlink{group__codec_ga6da974f4eeaba1fa74106b28d0fe6ac5}{aom\_codec\_control}(&stream->encoder, 
      \hyperlink{group__aom__encoder_ggae78dde67a6d78f332e9bdba0dde42db5a501a9453d5790f32c001e9877d3db40c}{AV1E\_SET\_CHROMA\_SUBSAMPLING\_Y},
2207                                 input.y4m.dst\_c\_dec\_v >> 1);
2208             \} \textcolor{keywordflow}{else} \textcolor{keywordflow}{if} (input.bit\_depth == 12 &&
2209                        input.file\_type == FILE\_TYPE\_RAW) \{
2210               \hyperlink{group__codec_ga6da974f4eeaba1fa74106b28d0fe6ac5}{aom\_codec\_control}(&stream->encoder, 
      \hyperlink{group__aom__encoder_ggae78dde67a6d78f332e9bdba0dde42db5a283dd3f4387e5f3a754fea0d206b1cb0}{AV1E\_SET\_CHROMA\_SUBSAMPLING\_X},
2211                                 stream->chroma\_subsampling\_x);
2212               \hyperlink{group__codec_ga6da974f4eeaba1fa74106b28d0fe6ac5}{aom\_codec\_control}(&stream->encoder, 
      \hyperlink{group__aom__encoder_ggae78dde67a6d78f332e9bdba0dde42db5a501a9453d5790f32c001e9877d3db40c}{AV1E\_SET\_CHROMA\_SUBSAMPLING\_Y},
2213                                 stream->chroma\_subsampling\_y);
2214             \}
2215             \textcolor{keywordflow}{break};
2216           \textcolor{keywordflow}{default}: \textcolor{keywordflow}{break};
2217         \}
2218       \}
2219       \textcolor{comment}{/* Automatically set the codec bit depth to match the input bit depth.}
2220 \textcolor{comment}{       * Upgrade the profile if required. */}
2221       \textcolor{keywordflow}{if} (stream->config.cfg.g\_input\_bit\_depth >
2222           (\textcolor{keywordtype}{unsigned} \textcolor{keywordtype}{int})stream->config.cfg.g\_bit\_depth) \{
2223         stream->config.cfg.g\_bit\_depth = stream->config.cfg.g\_input\_bit\_depth;
2224         \textcolor{keywordflow}{if} (!global.quiet) \{
2225           fprintf(stderr,
2226                   \textcolor{stringliteral}{"Warning: automatically updating bit depth to %d to "}
2227                   \textcolor{stringliteral}{"match input format.\(\backslash\)n"},
2228                   stream->config.cfg.g\_input\_bit\_depth);
2229         \}
2230       \}
2231       \textcolor{keywordflow}{if} (stream->config.cfg.g\_bit\_depth > 10) \{
2232         \textcolor{keywordflow}{switch} (stream->config.cfg.g\_profile) \{
2233           \textcolor{keywordflow}{case} 0:
2234           \textcolor{keywordflow}{case} 1:
2235             stream->config.cfg.g\_profile = 2;
2236             profile\_updated = 1;
2237             \textcolor{keywordflow}{break};
2238           \textcolor{keywordflow}{default}: \textcolor{keywordflow}{break};
2239         \}
2240       \}
2241       \textcolor{keywordflow}{if} (stream->config.cfg.g\_bit\_depth > 8) \{
2242         stream->config.use\_16bit\_internal = 1;
2243       \}
2244       \textcolor{keywordflow}{if} (profile\_updated && !global.quiet) \{
2245         fprintf(stderr,
2246                 \textcolor{stringliteral}{"Warning: automatically updating to profile %d to "}
2247                 \textcolor{stringliteral}{"match input format.\(\backslash\)n"},
2248                 stream->config.cfg.g\_profile);
2249       \}
2250       \textcolor{comment}{/* Set limit */}
2251       stream->config.cfg.g\_limit = global.limit;
2252     \}
2253 
2254     FOREACH\_STREAM(stream, streams) \{
2255       set\_stream\_dimensions(stream, input.width, input.height);
2256     \}
2257     FOREACH\_STREAM(stream, streams) \{ validate\_stream\_config(stream, &global); \}
2258 
2259     \textcolor{comment}{/* Ensure that --passes and --pass are consistent. If --pass is set and}
2260 \textcolor{comment}{     * --passes=2, ensure --fpf was set.}
2261 \textcolor{comment}{     */}
2262     \textcolor{keywordflow}{if} (global.pass && global.passes == 2) \{
2263       FOREACH\_STREAM(stream, streams) \{
2264         \textcolor{keywordflow}{if} (!stream->config.stats\_fn)
2265           die(\textcolor{stringliteral}{"Stream %d: Must specify --fpf when --pass=%d"}
2266               \textcolor{stringliteral}{" and --passes=2\(\backslash\)n"},
2267               stream->index, global.pass);
2268       \}
2269     \}
2270 
2271 \textcolor{preprocessor}{#if !CONFIG\_WEBM\_IO}
2272     FOREACH\_STREAM(stream, streams) \{
2273       \textcolor{keywordflow}{if} (stream->config.write\_webm) \{
2274         stream->config.write\_webm = 0;
2275         stream->config.write\_ivf = 0;
2276         warn(\textcolor{stringliteral}{"aomenc compiled w/o WebM support. Writing OBU stream."});
2277       \}
2278     \}
2279 \textcolor{preprocessor}{#endif}
2280 
2281     \textcolor{comment}{/* Use the frame rate from the file only if none was specified}
2282 \textcolor{comment}{     * on the command-line.}
2283 \textcolor{comment}{     */}
2284     \textcolor{keywordflow}{if} (!global.have\_framerate) \{
2285       global.framerate.num = input.framerate.numerator;
2286       global.framerate.den = input.framerate.denominator;
2287     \}
2288     FOREACH\_STREAM(stream, streams) \{
2289       stream->config.cfg.g\_timebase.den = global.framerate.num;
2290       stream->config.cfg.g\_timebase.num = global.framerate.den;
2291     \}
2292     \textcolor{comment}{/* Show configuration */}
2293     \textcolor{keywordflow}{if} (global.verbose && pass == 0) \{
2294       FOREACH\_STREAM(stream, streams) \{
2295         show\_stream\_config(stream, &global, &input);
2296       \}
2297     \}
2298 
2299     \textcolor{keywordflow}{if} (pass == (global.pass ? global.pass - 1 : 0)) \{
2300       \textcolor{keywordflow}{if} (input.file\_type == FILE\_TYPE\_Y4M)
2301         \textcolor{comment}{/*The Y4M reader does its own allocation.}
2302 \textcolor{comment}{          Just initialize this here to avoid problems if we never read any}
2303 \textcolor{comment}{          frames.*/}
2304         memset(&raw, 0, \textcolor{keyword}{sizeof}(raw));
2305       \textcolor{keywordflow}{else}
2306         \hyperlink{aom__image_8h_a570db29fbd122951235a08fe9375f6bb}{aom\_img\_alloc}(&raw, input.\hyperlink{structaom__image_a6c64b1ab918d80d52eb8f5d6d957e825}{fmt}, input.width, input.height, 32);
2307 
2308       FOREACH\_STREAM(stream, streams) \{
2309         stream->rate\_hist =
2310             init\_rate\_histogram(&stream->config.cfg, &global.framerate);
2311       \}
2312     \}
2313 
2314     FOREACH\_STREAM(stream, streams) \{ setup\_pass(stream, &global, pass); \}
2315     FOREACH\_STREAM(stream, streams) \{ initialize\_encoder(stream, &global); \}
2316     FOREACH\_STREAM(stream, streams) \{
2317       open\_output\_file(stream, &global, &input.pixel\_aspect\_ratio);
2318     \}
2319 
2320     \textcolor{keywordflow}{if} (strcmp(global.codec->name, \textcolor{stringliteral}{"av1"}) == 0 ||
2321         strcmp(global.codec->name, \textcolor{stringliteral}{"av1"}) == 0) \{
2322       \textcolor{comment}{// Check to see if at least one stream uses 16 bit internal.}
2323       \textcolor{comment}{// Currently assume that the bit\_depths for all streams using}
2324       \textcolor{comment}{// highbitdepth are the same.}
2325       FOREACH\_STREAM(stream, streams) \{
2326         \textcolor{keywordflow}{if} (stream->config.use\_16bit\_internal) \{
2327           use\_16bit\_internal = 1;
2328         \}
2329         input\_shift = (int)stream->config.cfg.g\_bit\_depth -
2330                       stream->config.cfg.g\_input\_bit\_depth;
2331       \};
2332     \}
2333 
2334     frame\_avail = 1;
2335     got\_data = 0;
2336 
2337     \textcolor{keywordflow}{while} (frame\_avail || got\_data) \{
2338       \textcolor{keyword}{struct }aom\_usec\_timer timer;
2339 
2340       \textcolor{keywordflow}{if} (!global.limit || frames\_in < global.limit) \{
2341         frame\_avail = read\_frame(&input, &raw);
2342 
2343         \textcolor{keywordflow}{if} (frame\_avail) frames\_in++;
2344         seen\_frames =
2345             frames\_in > global.skip\_frames ? frames\_in - global.skip\_frames : 0;
2346 
2347         \textcolor{keywordflow}{if} (!global.quiet) \{
2348           \textcolor{keywordtype}{float} fps = usec\_to\_fps(cx\_time, seen\_frames);
2349           fprintf(stderr, \textcolor{stringliteral}{"\(\backslash\)rPass %d/%d "}, pass + 1, global.passes);
2350 
2351           \textcolor{keywordflow}{if} (stream\_cnt == 1)
2352             fprintf(stderr, \textcolor{stringliteral}{"frame %4d/%-4d %7"} PRId64 \textcolor{stringliteral}{"B "}, frames\_in,
2353                     streams->frames\_out, (int64\_t)streams->nbytes);
2354           \textcolor{keywordflow}{else}
2355             fprintf(stderr, \textcolor{stringliteral}{"frame %4d "}, frames\_in);
2356 
2357           fprintf(stderr, \textcolor{stringliteral}{"%7"} PRId64 \textcolor{stringliteral}{" %s %.2f %s "},
2358                   cx\_time > 9999999 ? cx\_time / 1000 : cx\_time,
2359                   cx\_time > 9999999 ? \textcolor{stringliteral}{"ms"} : \textcolor{stringliteral}{"us"}, fps >= 1.0 ? fps : fps * 60,
2360                   fps >= 1.0 ? \textcolor{stringliteral}{"fps"} : \textcolor{stringliteral}{"fpm"});
2361           print\_time(\textcolor{stringliteral}{"ETA"}, estimated\_time\_left);
2362         \}
2363 
2364       \} \textcolor{keywordflow}{else} \{
2365         frame\_avail = 0;
2366       \}
2367 
2368       \textcolor{keywordflow}{if} (frames\_in > global.skip\_frames) \{
2369         \hyperlink{structaom__image}{aom\_image\_t} *frame\_to\_encode;
2370         \textcolor{keywordflow}{if} (input\_shift || (use\_16bit\_internal && input.bit\_depth == 8)) \{
2371           assert(use\_16bit\_internal);
2372           \textcolor{comment}{// Input bit depth and stream bit depth do not match, so up}
2373           \textcolor{comment}{// shift frame to stream bit depth}
2374           \textcolor{keywordflow}{if} (!allocated\_raw\_shift) \{
2375             \hyperlink{aom__image_8h_a570db29fbd122951235a08fe9375f6bb}{aom\_img\_alloc}(&raw\_shift, raw.\hyperlink{structaom__image_a6c64b1ab918d80d52eb8f5d6d957e825}{fmt} | 
      \hyperlink{aom__image_8h_a607b37d91f75442f54223ecd85f1b6cb}{AOM\_IMG\_FMT\_HIGHBITDEPTH},
2376                           input.width, input.height, 32);
2377             allocated\_raw\_shift = 1;
2378           \}
2379           aom\_img\_upshift(&raw\_shift, &raw, input\_shift);
2380           frame\_to\_encode = &raw\_shift;
2381         \} \textcolor{keywordflow}{else} \{
2382           frame\_to\_encode = &raw;
2383         \}
2384         aom\_usec\_timer\_start(&timer);
2385         \textcolor{keywordflow}{if} (use\_16bit\_internal) \{
2386           assert(frame\_to\_encode->\hyperlink{structaom__image_a6c64b1ab918d80d52eb8f5d6d957e825}{fmt} & \hyperlink{aom__image_8h_a607b37d91f75442f54223ecd85f1b6cb}{AOM\_IMG\_FMT\_HIGHBITDEPTH});
2387           FOREACH\_STREAM(stream, streams) \{
2388             \textcolor{keywordflow}{if} (stream->config.use\_16bit\_internal)
2389               encode\_frame(stream, &global,
2390                            frame\_avail ? frame\_to\_encode : NULL, frames\_in);
2391             \textcolor{keywordflow}{else}
2392               assert(0);
2393           \};
2394         \} \textcolor{keywordflow}{else} \{
2395           assert((frame\_to\_encode->\hyperlink{structaom__image_a6c64b1ab918d80d52eb8f5d6d957e825}{fmt} & \hyperlink{aom__image_8h_a607b37d91f75442f54223ecd85f1b6cb}{AOM\_IMG\_FMT\_HIGHBITDEPTH}) == 0);
2396           FOREACH\_STREAM(stream, streams) \{
2397             encode\_frame(stream, &global, frame\_avail ? frame\_to\_encode : NULL,
2398                          frames\_in);
2399           \}
2400         \}
2401         aom\_usec\_timer\_mark(&timer);
2402         cx\_time += aom\_usec\_timer\_elapsed(&timer);
2403 
2404         FOREACH\_STREAM(stream, streams) \{ update\_quantizer\_histogram(stream); \}
2405 
2406         got\_data = 0;
2407         FOREACH\_STREAM(stream, streams) \{
2408           get\_cx\_data(stream, &global, &got\_data);
2409         \}
2410 
2411         \textcolor{keywordflow}{if} (!got\_data && input.length && streams != NULL &&
2412             !streams->frames\_out) \{
2413           lagged\_count = global.limit ? seen\_frames : ftello(input.file);
2414         \} \textcolor{keywordflow}{else} \textcolor{keywordflow}{if} (input.length) \{
2415           int64\_t remaining;
2416           int64\_t rate;
2417 
2418           \textcolor{keywordflow}{if} (global.limit) \{
2419             \textcolor{keyword}{const} int64\_t frame\_in\_lagged = (seen\_frames - lagged\_count) * 1000;
2420 
2421             rate = cx\_time ? frame\_in\_lagged * (int64\_t)1000000 / cx\_time : 0;
2422             remaining = 1000 * (global.limit - global.skip\_frames -
2423                                 seen\_frames + lagged\_count);
2424           \} \textcolor{keywordflow}{else} \{
2425             \textcolor{keyword}{const} int64\_t input\_pos = ftello(input.file);
2426             \textcolor{keyword}{const} int64\_t input\_pos\_lagged = input\_pos - lagged\_count;
2427             \textcolor{keyword}{const} int64\_t input\_limit = input.length;
2428 
2429             rate = cx\_time ? input\_pos\_lagged * (int64\_t)1000000 / cx\_time : 0;
2430             remaining = input\_limit - input\_pos + lagged\_count;
2431           \}
2432 
2433           average\_rate =
2434               (average\_rate <= 0) ? rate : (average\_rate * 7 + rate) / 8;
2435           estimated\_time\_left = average\_rate ? remaining / average\_rate : -1;
2436         \}
2437 
2438         \textcolor{keywordflow}{if} (got\_data && global.test\_decode != TEST\_DECODE\_OFF) \{
2439           FOREACH\_STREAM(stream, streams) \{
2440             test\_decode(stream, global.test\_decode);
2441           \}
2442         \}
2443       \}
2444 
2445       fflush(stdout);
2446       \textcolor{keywordflow}{if} (!global.quiet) fprintf(stderr, \textcolor{stringliteral}{"\(\backslash\)033[K"});
2447     \}
2448 
2449     \textcolor{keywordflow}{if} (stream\_cnt > 1) fprintf(stderr, \textcolor{stringliteral}{"\(\backslash\)n"});
2450 
2451     \textcolor{keywordflow}{if} (!global.quiet) \{
2452       FOREACH\_STREAM(stream, streams) \{
2453         \textcolor{keyword}{const} int64\_t bpf =
2454             seen\_frames ? (int64\_t)(stream->nbytes * 8 / seen\_frames) : 0;
2455         \textcolor{keyword}{const} int64\_t bps = bpf * global.framerate.num / global.framerate.den;
2456         fprintf(stderr,
2457                 \textcolor{stringliteral}{"\(\backslash\)rPass %d/%d frame %4d/%-4d %7"} PRId64 \textcolor{stringliteral}{"B %7"} PRId64
2458                 \textcolor{stringliteral}{"b/f %7"} PRId64
2459                 \textcolor{stringliteral}{"b/s"}
2460                 \textcolor{stringliteral}{" %7"} PRId64 \textcolor{stringliteral}{" %s (%.2f fps)\(\backslash\)033[K\(\backslash\)n"},
2461                 pass + 1, global.passes, frames\_in, stream->frames\_out,
2462                 (int64\_t)stream->nbytes, bpf, bps,
2463                 stream->cx\_time > 9999999 ? stream->cx\_time / 1000
2464                                           : stream->cx\_time,
2465                 stream->cx\_time > 9999999 ? \textcolor{stringliteral}{"ms"} : \textcolor{stringliteral}{"us"},
2466                 usec\_to\_fps(stream->cx\_time, seen\_frames));
2467       \}
2468     \}
2469 
2470     \textcolor{keywordflow}{if} (global.show\_psnr) \{
2471       \textcolor{keywordflow}{if} (global.codec->fourcc == AV1\_FOURCC) \{
2472         FOREACH\_STREAM(stream, streams) \{
2473           int64\_t bps = 0;
2474           \textcolor{keywordflow}{if} (stream->psnr\_count && seen\_frames && global.framerate.den) \{
2475             bps = (int64\_t)stream->nbytes * 8 * (int64\_t)global.framerate.num /
2476                   global.framerate.den / seen\_frames;
2477           \}
2478           show\_psnr(stream, (1 << stream->config.cfg.g\_input\_bit\_depth) - 1,
2479                     bps);
2480         \}
2481       \} \textcolor{keywordflow}{else} \{
2482         FOREACH\_STREAM(stream, streams) \{ show\_psnr(stream, 255.0, 0); \}
2483       \}
2484     \}
2485 
2486     FOREACH\_STREAM(stream, streams) \{ \hyperlink{group__codec_ga9b60e186f61ba2d6ab2b8069b76a15c5}{aom\_codec\_destroy}(&stream->encoder); \}
2487 
2488     \textcolor{keywordflow}{if} (global.test\_decode != TEST\_DECODE\_OFF) \{
2489       FOREACH\_STREAM(stream, streams) \{ \hyperlink{group__codec_ga9b60e186f61ba2d6ab2b8069b76a15c5}{aom\_codec\_destroy}(&stream->decoder); \}
2490     \}
2491 
2492     close\_input\_file(&input);
2493 
2494     \textcolor{keywordflow}{if} (global.test\_decode == TEST\_DECODE\_FATAL) \{
2495       FOREACH\_STREAM(stream, streams) \{ res |= stream->mismatch\_seen; \}
2496     \}
2497     FOREACH\_STREAM(stream, streams) \{
2498       close\_output\_file(stream, global.codec->fourcc);
2499     \}
2500 
2501     FOREACH\_STREAM(stream, streams) \{
2502       stats\_close(&stream->stats, global.passes - 1);
2503     \}
2504 
2505 \textcolor{preprocessor}{#if CONFIG\_FP\_MB\_STATS}
2506     FOREACH\_STREAM(stream, streams) \{
2507       stats\_close(&stream->fpmb\_stats, global.passes - 1);
2508     \}
2509 \textcolor{preprocessor}{#endif}
2510 
2511     \textcolor{keywordflow}{if} (global.pass) \textcolor{keywordflow}{break};
2512   \}
2513 
2514   \textcolor{keywordflow}{if} (global.show\_q\_hist\_buckets) \{
2515     FOREACH\_STREAM(stream, streams) \{
2516       show\_q\_histogram(stream->counts, global.show\_q\_hist\_buckets);
2517     \}
2518   \}
2519 
2520   \textcolor{keywordflow}{if} (global.show\_rate\_hist\_buckets) \{
2521     FOREACH\_STREAM(stream, streams) \{
2522       show\_rate\_histogram(stream->rate\_hist, &stream->config.cfg,
2523                           global.show\_rate\_hist\_buckets);
2524     \}
2525   \}
2526   FOREACH\_STREAM(stream, streams) \{ destroy\_rate\_histogram(stream->rate\_hist); \}
2527 
2528 \textcolor{preprocessor}{#if CONFIG\_INTERNAL\_STATS}
2529   \textcolor{comment}{/* TODO(jkoleszar): This doesn't belong in this executable. Do it for now,}
2530 \textcolor{comment}{   * to match some existing utilities.}
2531 \textcolor{comment}{   */}
2532   \textcolor{keywordflow}{if} (!(global.pass == 1 && global.passes == 2)) \{
2533     FOREACH\_STREAM(stream, streams) \{
2534       FILE *f = fopen(\textcolor{stringliteral}{"opsnr.stt"}, \textcolor{stringliteral}{"a"});
2535       \textcolor{keywordflow}{if} (stream->mismatch\_seen) \{
2536         fprintf(f, \textcolor{stringliteral}{"First mismatch occurred in frame %d\(\backslash\)n"},
2537                 stream->mismatch\_seen);
2538       \} \textcolor{keywordflow}{else} \{
2539         fprintf(f, \textcolor{stringliteral}{"No mismatch detected in recon buffers\(\backslash\)n"});
2540       \}
2541       fclose(f);
2542     \}
2543   \}
2544 \textcolor{preprocessor}{#endif}
2545 
2546   \textcolor{keywordflow}{if} (allocated\_raw\_shift) \hyperlink{aom__image_8h_afff22f7f3eb9409c5b678d1962f110a8}{aom\_img\_free}(&raw\_shift);
2547   \hyperlink{aom__image_8h_afff22f7f3eb9409c5b678d1962f110a8}{aom\_img\_free}(&raw);
2548   free(argv);
2549   free(streams);
2550   \textcolor{keywordflow}{return} res ? EXIT\_FAILURE : EXIT\_SUCCESS;
2551 \}
\end{DoxyCodeInclude}
 